휴가도 보내고 운전 연수도 하느라 개발할 기간이 많이 부족했다.

일단 LDF 프로젝트의 진행상황은

1. 프론트 회원가입/로그인 페이지를 만드는 중
2. 백엔드는 아직 세팅중
3. 기능 설계와 DB 설계는 끝났다.
4. React와 React Native를 꾸준히 공부하는 중.


- - -

### 2024-08-19
React docs를 쭉 정독했다.
배운 것:
- 컴포넌트 다루기
- JSX에서 자바스크립트 사용하기
- props 전달하기
- 조건부 렌더링
- 리스트 렌더링
- 컴포넌트를 순수하게 유지하기
- 트리로서의 UI


- - -

### 2024-08-24
알고리즘을 오래 쉬니까 뇌가 굳는 기분이 든다. 그래서 마라톤정도는 꾸준히 하려고 한다. 1일 1커밋의 집착은 덜고 ..
React docs를 더 읽고 싶지만 팀원이 React을 다룰 줄 알아서 나는 이제 React Native를 공부하기로 했다. 어차피 React 모르는 건 팀원에게 물어보면 되니까 !

일단 RN 공부는 노마드코더의 Weather app tutorial 로 따라해봤고. 이제 WorkHardTravelHardApp, 이것도 끝나면 중급자 클래스를 들어볼 생각.



### 2024-08-25
- Solved.ac 플래티넘 V 승급!

![[Pasted image 20240825222911.png]]


### 2024-09-03
휴가 끝.



### 2024-09-04
React Native 공부로 투두 앱을 만들었다.
C++ 을 하다가 JS 문법과 React를 다루니 확실히 헷갈린다.

React Native는 정말 멋진 기술인 것 같다.. 프론트엔드 개발 지식으로 OS와 소통할 수 있다니..

주로 배운 건: TouchableOpacity, TextInput 같은 RN의 기본 Components를 배우고, useState와 useEffect 문법에 조금이나마 더 익숙해졌다. 중요한건 state를 절대 직접 변경(mutate) 하지 않는 것. 복제본을 만들고 그것을 수정한다음 setState로 덮어 씌워야 한다.

스프레드 문법도 처음 볼때는 무슨 이런 문법이 있나 싶었지만, 편한 기능인 것 같다.


- - -

Promise 문법과 async, await에 대해서도 다시 짚었다.

**동기(Synchronous)**와 **비동기(Asynchronous)**는 실행 순서와 진행 방식에 대한 이야기인데, 
- **비동기적**이라는 것은 “작업을 수행할 때 그 작업이 **완료될 때까지 기다리지 않고** 다른 작업을 계속 진행할 수 있는 방식”을 의미한다.

- **동기적**이라는 것은 “작업이 **순차적으로 실행**되는 것을 말하며, 각 작업이 끝날 때까지 **다음 작업을 기다리는** 방식”을 의미한다.


동기적인 로직은 작업의 **순서가 보장**되고 실행 흐름이 **직관적**이지만, **오래 걸리는 작업이 있으면 그 작업이 끝날 때까지** 모든 로직이 중단되는 문제가 있다.

예를 들어서:

```javascript
// 동기적 함수
function getData() {
  const response = fetch("https://api.example.com/data");  // 데이터가 로드될 때까지 전체 프로그램이 멈춤
  const data = response.json();  // JSON 변환도 기다려야 함
  console.log(data);
}

getData();
console.log("이 코드는 언제 실행될까요?");  // fetch 요청이 끝날 때까지 실행되지 않음
```

위의 코드는 동기적 함수의 예시로, 코드는 위에서 아래로 순차적으로 실행되며. 위의 코드가 실행될때까지 아래의 코드는 실행되지 않는다.

```javascript
async function getData() {
  const response = await fetch("https://api.example.com/data");
  console.log("데이터를 가져온 후 다른 작업 실행");
  const data = await response.json();  // 데이터가 로드된 후에 JSON 변환
  console.log(data);  // 데이터를 완전히 받아온 후에 실행됨
}

getData();
```

위의 코드는 **비동기적 처리**의 예시다. 여기서 async 키워드는 **함수가 비동기적으로 실행될 것**임을 알린다. await는 비동기 함수에서만 사용할 수 있으며, **해당 비동기 작업이 완료될 때까지 기다린다**는 의미다.

그럼 여기서 의문점이 생긴다. 어차피 await를 써서 동기적으로 동작하게 할거면 처음부터 왜 async 함수를 선언하는가?

사실 async과 await의 목적은 비동기적으로 작업을 처리하면서도 동기적인 방식처럼 코드의 흐름을 보이도록 하는 것이다.

async/await는 비동기 작업의 복잡한 처리 과정을 간결하게 표현해주는 **문법적 설탕**이다.
즉, **비동기 작업을 동기적으로 작성할 수 있는** 방식이다. 

동기적 함수에서는 .fetch()를 사용할 때 데이터가 로드될동안 프로그램 로직이 모두 일시 중단된다면,
비동기적 함수에서는 await 키워드를 사용함으로써 해당 함수가 "동기적인 것처럼" 실행해야 함을 알리고, 기다리는 동안 나머지 로직을 실행한다. 즉 프로그램 전체가 멈추는 것이 아니다.


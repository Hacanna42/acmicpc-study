# <span style="color:yellow">2024-11-03</span>


#### 고민들
1. 현재 내가 작성한 컨트롤러는 컨트롤러인가?
컨트롤러에 비즈니스 로직을 넣은 게 아니라, 단순히 객체 생성 로직이라서 문제가 없을거라는 의견

컨트롤러가 만들어진 View랑 Model을 초기화하면서 조율하는 역할 잘 하고 있다고 생각함, 컨트롤러 보면 비즈니스 로직은 하나도 없음. 만약 컨트롤러가 이렇게 하는 거 싫고 진짜 메서드 호출 한두개만 딱딱 하고싶게 만드려면 Application.main()에 위임해야

코드 다시 확인해보면 모든 로직은 객체(모델)안에 모두 있고, 컨트롤러에서 나눈 메서드는 비즈니스 로직을 처리하는 부분이 아니라 new 키워드로 생성 -> return 하는 부분


2. InputHandler와 OutputHandler는 필요할때마다 객체 생성을 계속하기에 싱글톤 패턴이 유효할 것 같아서 적용해보려고 하는데, 어차피 쓸모 없어지는 시점에서 바로 GC에 의해 파기된다. 그러면 new 키워드를 필요할때마다 하는거랑, 싱글톤 패턴을 사용하는거랑 무슨 차이일까?


쓰레드에 대해선 아직 잘 모르겠지만, 싱글톤 패턴을 멀티 쓰레드 환경에서 실행시키면 동시에 인스턴스를 생성할 수 있는 문제가 있다고 한다. 따라서 이때는 synchronization 키워드를 사용해서 해당 블록에 한번에 하나의 쓰레드만 접근 가능하도록 제한한다.



- - -

3주차 최종 리팩토링 및 소감문 작성을 완료했다. 

PR README에 작성할 고민(질문)을 정리하고 pr후 제출할 예정이다.



아래는 과제 수행 중 고민했던 사항들입니다. 코드 리뷰 시 관련 조언을 주시면 감사하겠습니다. 😊

### 고민 사항
1. LottoController는 컨트롤러의 역할을 넘어서지 않았는가?
	 `LottoController` 는 객체 생성과 협력을 조율하며, 전체적인 흐름을 담당합니다. 원래는 객체 생성과 흐름은 `Application.main`의 역할이었고, `main` 에서 생성한 객체를 `LottoController`가 의존성 주입받아 사용했지만, 생성자의 파라미터가 너무 길어진다고 생각하여 의존성 주입을 포기하고 `LottoController` 에서 `new` 키워드를 사용해서 객체를 생성하고 협력을 조율하고 있습니다. 그리고 현재의 `LottoController`는 객체를 생성, 호출할 뿐 비즈니스 로직은 하나도 포함하지 않고 있다고 생각합니다. 저는 이 코드가 `Application.main`에서 처리하고 의존성 주입받는 것보다 나아 보이는데, 다른 분들의 생각은 어떨지 궁금합니다.
2. View 객체에 싱글톤 패턴을 적용한 것은 유효한 설계일까?
	 `InputHandler`와 `OutputHandler`는 필요할 때마다 `LottoController` 에서 객체 생성을 계속하기에 싱글톤 패턴을 적용했습니다. 제가 싱글톤 패턴 적용으로 의도한 이득은 매번 `new` 키워드로 새로운 객체를 생성하지 않고 하나의 인스턴스를 재사용해 메모리를 절약하는 것입니다. 하지만 이때 들었던 의문점은 `new` 키워드로 새로운 객체를 생성해도, 사용하지 않게 되는 시점에서 `GarbageCollector`에 의해 바로 파기될 텐데 싱글톤 패턴 적용이 유의미한 효과를 가져올까에 대해서입니다. `GarbageCollector`로 인한 오버헤드를 생각해도 이것은 너무 미묘한 차이가 아닐까 하는 생각입니다.
3. Validator의 메서드를 정적(static)으로 선언한 것은 좋은 전략일까?
	 `LottoValidator`는 `InputHandler`에서 호출되는 입력 값 검증 로직입니다. 단순한 로직이고 어디서든 실행 결과가 달라지지 않습니다. 따라서 기존에는 `InputHandler`가 `LottoValidator`을 의존성 주입받았지만 `LottoValidator`을 `static method`로 전환하여 복잡성을 줄였습니다. 과연 이것은 올바른 선택일까요? 다양한 분들의 의견이 궁금합니다.


- - -

PR 및 제출 완료했다.
코드리뷰 열릴때까지 (제출 마감 전까지) 오브젝트 책을 정독해야겠다. 책 내용이 마냥 쉽지만은 않기 때문에 천천히.. 일단 챕터 3까지 읽는게 목표다!






# 오브젝트 포인트 정리
- 자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도를 낮추며 응집도를 올릴 수 있다.
- 객체 내부의 상태를 캡슐화하고, 외부에서 내부에 대해 알 수 없게 하라. 단지 외부는 인터페이스에 의존할 뿐이다.
- 모델이 본인의 데이터를 책임지지 않고 제어하는 역할을 외부에 맡기면, 그것은 모델이 아니라 Data가 될 뿐이다. 그리고 가운데의 프로세스에 의해서 제어당한다. 이것은 우리가 익히 알고 있는 절차 지향 방식의 프로그래밍이다. 단순히 데이터는 수동적인 존재가 되는 것. 만약 본인의 데이터를 본인이 책임지도록 만들면 비로소 자율적인 객체인 모델이 된다.
- 절차적 프로그래밍은 읽는 사람의 직관을 크게 벗어나기 때문에 코드를 읽는 사람과 원활한 소통이 힘들다.
- 객체 지향 프로그래밍의 본질은 데이터와 프로세스가 동일한 모듈에 위치하는 것이다. (응집도 UP)
- 객체 상호간 서로의 자율성을 침해하지 않도록 한다!
- 변경 가능한 코드란 이해하기 쉬운 코드다
- 훌륭한 객체지향 설계란 의존성을 적절히 관리하는 설계다.
- 프로그래머의 역할을 클래스 작성자와 클라이언트 프로그래머로 구분하는 것이 유용하다. (즉 클래스를 만드는 사람과 만들어진 클래스 사이에서 코딩 하는 사람).
- 객체의 내부와 외부를 구분하면 인터페이스를 바꾸지 않는 한 외부에 미치는 영향을 걱정하지 않고도 내부 구현을 마음대로 변경할 수 있다. 다시 말해 public 영역을 변경하지 않는 한 코드를 마음대로 수정할 수 있다 (!!)
- 개념을 명시적으로 표현하는 것은 전체적인 설계의 명확성과 유연성을 높이는 첫 걸음이다. 예를 들어서 돈을 정수형에 저장하지 않고 Money 라는 객체를 만들어서 저장한다. 비록 그것이 하나의 인스턴스 변수만 포함하더라도 말이다!
- 
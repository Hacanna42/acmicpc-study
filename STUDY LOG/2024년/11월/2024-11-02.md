# <span style="color:yellow">2024-11-02</span>
오늘의 목표!

11/02
1. 3주차 미션 최종 리팩토링
2. 소감문 작성
3. 오브젝트 책 읽기

수익률을 계산하는 책임이 Controller에 있어서, 리팩토링 과정에서 Money 객체에서 처리하도록 변경했다.
record라는 형태에 대해 알게 되었다.


리팩토링을 계속 하고 있다, 컨트롤러가 수익률을 계산하는 명백한 OOP 위반의 문제점을 발견해서 해당 책임을 Money 객체에 옮겼다.


### 배운 점
1. 깔끔한 단위 테스트를 위해 JUnit의 다양한 어노테이션에 대해 학습했습니다.
2. 다양한 상수 값을 체계적으로 관리할 수 있는 Enum에 대해 이해하게 되었습니다.
3. Enum을 키로 사용하는 EnumMap 자료구조를 배우며, 구조적으로 값들을 관리할 수 있음을 깨달았습니다.
4. 객체 지향 설계에 대한 시야를 더욱 넓히는 계기가 되었습니다.
### 느낀 점
1. 구체적인 설계 기법을 처음 적용해 보았는데, 실제 구현 과정에서 설계의 여러 부분이 변경되어 혼란스러웠습니다. 이 경험을 통해 오히려 구체적인 설계보다는 직관적이고 추상적인 부분을 적절히 활용하는 것이 유효하다는 생각이 들었습니다. 객체 지향이 실제 사물을 모델링하여 코드를 직관적으로 읽히게 만드는 것이 본질이듯이, 코드 구조 설계 시에도 정해진 틀에 맞추기보다는 직관적인 설계를 따르는 것이 더 나을 수 있다고 느꼈습니다.
2. 완벽한 설계, 모두가 만족하는 설계란 존재하지 않는다는 것을 실감했습니다. 그저 서로 다른 방식들이 지닌 장단점 사이에서 적절히 트레이드오프(trade-off)하는 것이 필요할 뿐입니다. 지난 과제에서는 `Application`이 객체 생성과 협력을 조율하고 전체적인 흐름을 담당하여 Controller가 필요한 객체들을 DI 받을 수 있었습니다. 그러나 이번 과제에서는 Controller가 필요한 객체를 `new` 키워드로 생성하고 직접 협력을 조율하도록 했습니다. 객체를 DI 받는 것이 느슨한 의존성을 유지하는 장점이 있지만, 이번 과제에서는 `new` 키워드를 활용한 방식이 오히려 컨트롤러의 목적에 더 부합하고 깔끔하다고 느꼈습니다. 코드 리뷰에서 이 방식에 대한 의견이 갈리는 것을 보면서, 설계에는 정답이 없고 다양한 접근이 가능하다는 점을 깨달았습니다.

### 많은 시간을 투자한 부분
1. 기존의 설계가 실제 구현과 많이 다른 부분에 대해, 설계를 따라야 할지 직관을 따라야 할지 고민하는데에 시간을 많이 씀..
2. 저번 주차에서의 테스트는 단위 테스트보다는 통합 테스트 같다고 느꼈습니다. 이번 주차에서는 정말 단위에 대한 테스트를 꼼꼼히 작성하기 위해 노력했습니다.



확실히 이번 과제는 "객체들과의 소통" 에 포커싱이 되어있는 과제 같았습니다. 구현해야 할 객체도 많았고 따라서 설계가 좀 더 어려웠던 것 같습니다.



"오브젝트" 책에서 배운 내용: 클라이언트 프로그래머에게 필요한 부분만 공개하고 나머지는 꽁꽁 숨겨야 한다. 그래야 바깥의 영향을 걱정하지 않고도 내부 구현을 마음대로 변경할 수 있다. 이를 구현 은닉(implementation hiding) 이라고 한다.

책 저자 조영호님 블로그 중 "설계에 있어 가장 중요하게 생각하는 개념은 **트레이드오프(trade-off)**입니다. 일반적으로 트레이드오프는 한 가지를 얻기 위해 다른 것을 포기해야 하는 긴장 상황을 의미합니다."

설계를 선택할 때, 얻는 것이 있으면 잃는 것도 있다는 사실을 받아들이는 것이 트레이드오프를 이해하는 첫걸음입니다.

https://eternity-object.tistory.com/43
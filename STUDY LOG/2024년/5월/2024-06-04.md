# <span style="color:yellow">2024-06-04</span>

# 클래스 4 금장까지 한 보.

2주만에 돌아왔다. 아무것도 안한 것은 아니고, 문제를 열심히 풀었다. 단지 업데이트를 몰아서 할 뿐. 
이렇게 약간의 딜레이를 가지고 글을 쓰는 것도 문제를 푼 당일에 바로 올리는 것보다 복습의 효과가 클 것 같다.

### 해결한 문제들
- 최소비용 구하기 (골드 5 - 1916)
- 내려가기 (골드 5 - 2096)
- 치킨 배달 (골드 5 - 15686)
- 파이프 옮기기 1 (골드 5 - 17070)
- 거짓말 (골드 4 - 1043)
- 알파벳 (골드 4 - 1987)
- 별 찍기 - 11 (골드 4 - 2448)
- 이진 검색 트리 (골드 4 - 5639) 2회차
- 숨바꼭질 2 (골드 4 - 12851)
- 시그마 (골드 4 - 13172)
- 연구소 (골드 4 - 14502)
- 서강그라운드 (골드 4 - 14938)
- 미세먼지 안녕! (골드 4 - 17144)
- 치즈 (골드 3 - 2638)


##### 금장까지 남은 문제들 :
- 최소비용 구하기 2
- 아기 상어


- - -


#### 중요 이벤트
1. 네이버 부스트캠프에 지원하려고 자기소개서를 쓰고 있다. 특이하게 코딩 테스트의 비중이 그다지 높진 않은 것 같다. 나는 요즘 알고리즘에 불을 태우고 있기에 불리한 요소지만, 자기소개서의 질문 내용을 보니 나랑 커리큘럼이나 가치관이 잘 맞을 것 같다.

2. 이전 게시글에서 모각코를 운영하게 되었다고 했는데. 성공적으로 진행했다. 분위기는 생각보다 편하고 즐거웠다. 서로 존중하며 커뮤니케이션하는 모습이 인상깊었다. 이번주 목요일에도 계획대로 진행 할 예정이다.

3. SSAFY 앰배서더 활동이 끝났다. 정상적으로 수료했다.



- - -


### 최소비용 구하기 (골드 5 - 데이크스트라)
```
N개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 M개의 버스가 있다. 우리는 A번째 도시에서 B번째 도시까지 가는데 드는 버스 비용을 최소화 시키려고 한다. A번째 도시에서 B번째 도시까지 가는데 드는 최소비용을 출력하여라. 도시의 번호는 1부터 N까지이다.
```

아주 기본적인 다익스트라 최단거리 문제. priority_queue를 사용해서 최단 거리의 노드 먼저 BFS 탐색하도록 한다.

당연하지만 다익스트라에서는 방문 배열을 사용하면 안된다.

최단 거리 알고리즘은 크게 3가지가 있는데
- 다익스트라 알고리즘
- 벨만-포드 알고리즘
- 플로이드 워셜 알고리즘

다익스트라 알고리즘은 음의 가중치가 없는 그래프에서 (정확하게는, 음의 사이클이 없어야 한다) 사용할 수 있는 single-source shortest path(특정 노드에 대해 모든 각 노드까지의 최단거리)이고, 가장 빠르다.

벨만-포드 알고리즘은 다익스트라 알고리즘과 같이 특정 노드에 대해 모든 각 노드까지의 최단거리를 구하지만 음의 가중치가 있는 경우에서도 사용할 수 있다 (음의 사이클이 발견되는 순간 최단 거리는 의미가 없어지지만, 적어도 음의 사이클을 감지할 수 있다). 다익스트라 알고리즘보다 느리다.

플로이드 워셜 알고리즘은 서로 모든 노드끼리의 최단 거리를 인접 행렬 형식으로 구하는 최단거리 알고리즘이다.

```cpp
// 백준: 최소 비용 구하기
// https://www.acmicpc.net/problem/1916
// 2024-05-22

/*
다익스트라는 방문 배열(visited)을 사용하면 안된다.
if (cur_weight > dist[cur_node]) 로 처리하자.
*/

#include <functional>
#include <iostream>
#include <queue>
#include <utility>
#include <vector>
#define INF (~0U >> 2)
using namespace std;

int N, M; // 도시 개수 N, 버스 개수 M

int dijkstra(int start, int dest, vector<vector<pair<int, int>>> &adj) {
    vector<int> dist(N + 1, INF);
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; // 최단 거리 탐색을 위한 우선순위 큐
    dist[start] = 0;                                                                    // 출발 지점
    pq.push({0, start});                                                                // 가중치, 노드

    while (!pq.empty()) {
        int cur_node = pq.top().second;
        int cur_weight = pq.top().first;
        pq.pop();

        if (cur_weight > dist[cur_node])
            continue;

        for (const auto &next : adj[cur_node]) {
            int next_node = next.second;
            int weight = next.first;
            int next_weight = cur_weight + weight;
            if (next_weight < dist[next_node]) {
                dist[next_node] = next_weight;
                pq.push({next_weight, next_node});
            }
        }
    }

    return dist[dest];
}

int main() {
    cin >> N >> M;
    vector<vector<pair<int, int>>> adj(N + 1, vector<pair<int, int>>()); // 가중치, 노드
    for (int i = 0; i < M; ++i) {
        int start_node, end_node, weight;
        cin >> start_node >> end_node >> weight;
        adj[start_node].push_back({weight, end_node});
    }
    int start, dest;
    cin >> start >> dest;

    cout << dijkstra(start, dest, adj);
    return 0;
}
```



- - -



### 내려가기 (골드 5 - 슬라이딩 윈도우, DP)
```
N줄에 0 이상 9 이하의 숫자가 세 개씩 적혀 있다. 내려가기 게임을 하고 있는데, 이 게임은 첫 줄에서 시작해서 마지막 줄에서 끝나게 되는 놀이이다.

먼저 처음에 적혀 있는 세 개의 숫자 중에서 하나를 골라서 시작하게 된다. 그리고 다음 줄로 내려가는데, 다음 줄로 내려갈 때에는 다음과 같은 제약 조건이 있다. 바로 아래의 수로 넘어가거나, 아니면 바로 아래의 수와 붙어 있는 수로만 이동할 수 있다는 것이다. 이 제약 조건을 그림으로 나타내어 보면 다음과 같다.

별표는 현재 위치이고, 그 아랫 줄의 파란 동그라미는 원룡이가 다음 줄로 내려갈 수 있는 위치이며, 빨간 가위표는 원룡이가 내려갈 수 없는 위치가 된다. 숫자표가 주어져 있을 때, 얻을 수 있는 최대 점수, 최소 점수를 구하는 프로그램을 작성하시오. 점수는 원룡이가 위치한 곳의 수의 합이다.
```

![image](https://www.acmicpc.net/JudgeOnline/upload/201007/down.png)


이 문제는 점화식을 유추하기 쉬운 DP 문제지만, 메모리 제한이 4MB에 N이 10만으로 메모리를 아끼지 않으면 **MLE**를 피할 수 없는 문제였다.

Memoization하는 DP 배열을 2차원으로 만들면 편하겠지만, 이 문제에서는 메모리가 넉넉지 않다. 따라서 '슬라이딩 윈도우' 기법을 사용해야 하는데 그냥 단순하게 필요하지 않은 부분을 슬라이딩 해놓고 원하는 범위만 보는 기법? 꼼수? 라고 보면 편할 것 같다.

이 문제에서는 현재의 최적해는 이전 문제의 최적해에서만 영향 받기 때문에 DP 점화식에서는 현재 인덱스의 i-1 부분만 사용할 것이다. 따라서 2차원 배열로 만들어서 모든 정보를 저장할 필요 없이. 그저 이전의 정보만 저장하면 문제를 풀 수 있다.

점화식에서 어차피 안쓰이는 범위의 배열을 생각해보면 최적화 방법을 떠올리는 것은 어렵지 않다. 이러한 최적화 방법을 '토글링' 이라고 한다.

길이가 3인 일차원 배열: max_dp와 min_dp를 선언하고 각각 현재 층의 각 왼쪽 / 중앙 / 오른쪽 요소를 갖도록 한다 매 분기마다 max_dp와 min_dp에 저장되어 있는 값과 입력받은 값을 비교하며 업데이트 해나간다.

```cpp
// 백준: 내려가기
// https://www.acmicpc.net/problem/2096
// 2024-05-22

#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    int N;
    cin >> N;
    vector<vector<int>> score(3, vector<int>(N, 0)); // xy 체계
    for (int y = 0; y < N; ++y) {
        for (int x = 0; x < 3; ++x) {
            cin >> score[x][y];
        }
    }

    vector<int> max_dp(3, 0);
    vector<int> min_dp(3, 0);

    for (int i = 0; i < 3; ++i) {
        max_dp[i] = score[i][0];
        min_dp[i] = score[i][0];
    }

    /*
     MLE를 받지 않으려면 dp를 1차원 배열로 해야될 것 같다.

     길이가 3인 일차원 배열: max_dp와 min_dp를 선언하고 각각 현재 층의 각 왼쪽 / 중앙 / 오른쪽 요소를 갖도록 한다
     매 분기마다 max_dp와 min_dp에 저장되어 있는 값과 입력받은 값을 비교하며 업데이트 해나간다.
    */

    for (int y = 1; y < N; ++y) {
        int prev_max[3] = {max_dp[0], max_dp[1], max_dp[2]};
        int prev_min[3] = {min_dp[0], min_dp[1], min_dp[2]};

        max_dp[0] = max(prev_max[0], prev_max[1]) + score[0][y];
        max_dp[1] = max({prev_max[0], prev_max[1], prev_max[2]}) + score[1][y];
        max_dp[2] = max(prev_max[1], prev_max[2]) + score[2][y];

        min_dp[0] = min(prev_min[0], prev_min[1]) + score[0][y];
        min_dp[1] = min({prev_min[0], prev_min[1], prev_min[2]}) + score[1][y];
        min_dp[2] = min(prev_min[1], prev_min[2]) + score[2][y];
    }

    cout << max({max_dp[0], max_dp[1], max_dp[2]}) << " " << min({min_dp[0], min_dp[1], min_dp[2]});
    return 0;
}
```



- - -


### 치킨 배달 (골드 5 - 백트래킹, 브루트포스)
```
크기가 N×N인 도시가 있다. 도시는 1×1크기의 칸으로 나누어져 있다. 도시의 각 칸은 빈 칸, 치킨집, 집 중 하나이다. 도시의 칸은 (r, c)와 같은 형태로 나타내고, r행 c열 또는 위에서부터 r번째 칸, 왼쪽에서부터 c번째 칸을 의미한다. r과 c는 1부터 시작한다.

이 도시에 사는 사람들은 치킨을 매우 좋아한다. 따라서, 사람들은 "치킨 거리"라는 말을 주로 사용한다. 치킨 거리는 집과 가장 가까운 치킨집 사이의 거리이다. 즉, 치킨 거리는 집을 기준으로 정해지며, 각각의 집은 치킨 거리를 가지고 있다. 도시의 치킨 거리는 모든 집의 치킨 거리의 합이다.

임의의 두 칸 (r1, c1)과 (r2, c2) 사이의 거리는 |r1-r2| + |c1-c2|로 구한다.

도시에 있는 치킨집 중에서 최대 M개를 고르고, 나머지 치킨집은 모두 폐업시켜야 한다. 어떻게 고르면, 도시의 치킨 거리가 가장 작게 될지 구하는 프로그램을 작성하시오.
```

이 문제도 별 생각 없이 풀면 **TLE**가 난다.

백트래킹으로 가능한 치킨 점포 조합을 모두 구하고, 완전탐색(브루트포스) 방식으로 각 조합에 대해서 최단 '치킨 거리' 를 구하는 것 까진 맞는데..

BFS가 아닌 맨해튼 거리로 최단 거리를 구해야 한다. 문제에서 주어지는 격자 도시는 모든 가중치가 똑같은 인접한 그래프이기 때문에, BFS탐색을 사용하지 않아도 단순히 두 좌표간의 차이로 거리를 구할 수 있다 (맨해튼 거리) 

BFS를 사용하면 **TLE**를 받는다.

쉽게 푸는 방법이 있을 줄 알았는데 결국 가장 naive하게 푸는 게 정답이었다.

```cpp
// 백준: 치킨 배달
// https://www.acmicpc.net/problem/15686
// 2024-05-22

/*
가지치기: 알려진 최솟값보다 높은 값이 갱신되면 중단
*/

#include <algorithm>
#include <cmath>
#include <iostream>
#include <queue>
#include <utility>
#include <vector>

using namespace std;

int N, M; // N*N 크기의 도시, 폐업시키지 않을 치킨 집 M
vector<vector<pair<int, int>>> paths;
int dr[4] = {1, -1, 0, 0};
int dc[4] = {0, 0, 1, -1};

void getAllCombination(vector<pair<int, int>> &path, vector<pair<int, int>> &chicken_markets, int start) {
    if (path.size() == M) {
        paths.push_back(path);
        return;
    }

    int SIZE = chicken_markets.size();
    for (int i = start; i < SIZE; ++i) {
        int cur_r = chicken_markets[i].first;
        int cur_c = chicken_markets[i].second;
        path.push_back({cur_r, cur_c});
        getAllCombination(path, chicken_markets, i + 1);
        path.pop_back();
    }
}

// BFS 탐색을 사용했는데, 맨해튼 거리를 사용해서 (절댓값 좌표의 차이) TLE를 막자
// int getNearestChicken(int start_r, int start_c, vector<vector<int>> &map) {
//     vector<vector<bool>> visited(N, vector<bool>(N, false));
//     queue<pair<int, pair<int, int>>> q;
//     q.push({0, {start_r, start_c}});
//     while (!q.empty()) {
//         int cur_r = q.front().second.first;
//         int cur_c = q.front().second.second;
//         int cur_weight = q.front().first;
//         q.pop();

//         if (map[cur_r][cur_c] == 2) { // 치킨집이라면
//             return cur_weight;
//         }

//         for (int i = 0; i < 4; ++i) {
//             int next_r = cur_r + dr[i];
//             int next_c = cur_c + dc[i];
//             if (next_r >= 0 && next_c >= 0 && next_r < N && next_c < N && !visited[next_r][next_c]) {
//                 visited[next_r][next_c] = true;
//                 q.push({cur_weight + 1, {next_r, next_c}});
//             }
//         }
//     }
//     return -1; // 찾지 못함
// }

int getNearestChicken(vector<vector<int>> &map) {
    int known_shortest_dist = (~0U >> 2);
    for (const auto &path : paths) {
        int dist_sum = 0;
        bool stop = false;
        for (int r = 0; r < N && !stop; ++r) {
            for (int c = 0; c < N && !stop; ++c) {
                if (map[r][c] == 1) { // 집이라면
                    int cur_shortest_dist = (~0U >> 2);
                    for (const auto &next : path) {
                        int cur_chicken_r = next.first;
                        int cur_chicken_c = next.second;
                        // |r1 - r2| + |c1 + c2|
                        cur_shortest_dist = min(cur_shortest_dist, abs(r - cur_chicken_r) + abs(c - cur_chicken_c));
                    }
                    dist_sum += cur_shortest_dist;
                    if (dist_sum >= known_shortest_dist) {
                        stop = true;
                        break;
                    }
                }
            }
        }
        if (!stop)
            known_shortest_dist = min(known_shortest_dist, dist_sum);
    }
    return known_shortest_dist;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> N >> M;
    vector<vector<int>> map(N, vector<int>(N));
    vector<pair<int, int>> chicken_markets;
    for (int r = 0; r < N; ++r) {
        for (int c = 0; c < N; ++c) {
            cin >> map[r][c];
            if (map[r][c] == 2) { // 치킨 집 정보 저장
                chicken_markets.push_back({r, c});
                map[r][c] = 0; // 빈칸으로 되돌려놓기
            }
        }
    }

    vector<pair<int, int>> path;
    getAllCombination(path, chicken_markets, 0);
    cout << getNearestChicken(map);
    return 0;
}
```



- - -



### 파이프 옮기기 (골드 5 - 그래프 이론, DP)
```
파이프를 밀 수 있는 방향은 총 3가지가 있으며, →, ↘, ↓ 방향이다.
가장 처음에 파이프는 (1, 1)와 (1, 2)를 차지하고 있고, 방향은 가로이다. 파이프의 한쪽 끝을 (N, N)로 이동시키는 방법의 개수를 구해보자.
```

![image](https://upload.acmicpc.net/b29efafa-dbae-4522-809c-76d5c184a231/-/preview/)

![image](https://upload.acmicpc.net/045d071f-0ea2-4ab5-a8db-61c215e7e7b7/-/preview/)


태그는 다이나믹 프로그래밍과 그래프 이론이지만, 나는 그냥 재귀 완전탐색으로 풀었다.
아마 DP로만 풀리는 문제는 플래쪽에 있는 것 같다.

그리고 사실상 재귀 완전탐색이 DFS와 유사하기도 하고..
문제가 복잡해보이지만 시간 제한이 널널하기에 그냥 naive하게 풀면 풀리는 문제였다.

확실히 요즘 문제 풀 때 느끼는데, 푸는 센스가 늘은 것 같다. 실력이 늘었다고 봐야겠지 ~

```cpp
// 백준: 파이프 옮기기 1
// https://www.acmicpc.net/problem/17070
// 2024-05-23

/*
시뮬레이션 문제인 것 같다.
*/

#include <iostream>
#include <vector>
using namespace std;

int N; // N*N 크기의 맵
vector<vector<int>> map;
int cnt = 0;

// 이전 파이프가 가로로 놓여있을 때 다음 파이프의 가능한 위치
int horizontal_dr[2] = {0, 1};
int horizontal_dc[2] = {1, 1};
// 이전 파이프가 세로로 놓여있을 때
int vertical_dr[2] = {1, 1};
int vertical_dc[2] = {0, 1};
// 이전 파이프가 대각선으로 놓여있을 때
int diagonal_dr[3] = {0, 1, 1};
int diagonal_dc[3] = {1, 0, 1};

int getPipeDirection(int &start_r, int &start_c, int &end_r, int &end_c) { // 가로: -1, 세로: 1, 대각선: 0
    if (start_r == end_r && end_c - start_c == 1)                          // 가로
        return -1;
    else if (start_c == end_c && end_r - start_r == 1) // 세로
        return 1;
    else
        return 0;
}

void solution(int start_r, int start_c, int end_r, int end_c) {
    // 현재 파이프의 방향 알아내기
    int cur_direction = getPipeDirection(start_r, start_c, end_r, end_c);

    if (cur_direction == 0 && (map[end_r - 1][end_c] == 1 || map[end_r][end_c - 1] == 1)) // 대각선 벽지 긁었다면 종료
        return;

    if (end_r == N && end_c == N) { // 목표 지점 도착하면 카운트 증가하고 종료
        ++cnt;
        return;
    }

    // 가로
    if (cur_direction == -1) {
        for (int i = 0; i < 2; ++i) {
            int next_end_r = end_r + horizontal_dr[i];
            int next_end_c = end_c + horizontal_dc[i];
            if (next_end_r <= N && next_end_c <= N && map[next_end_r][next_end_c] == 0) { // VALID CHECK
                solution(end_r, end_c, next_end_r, next_end_c);
            }
        }
    }

    // 세로
    else if (cur_direction == 1) {
        for (int i = 0; i < 2; ++i) {
            int next_end_r = end_r + vertical_dr[i];
            int next_end_c = end_c + vertical_dc[i];
            if (next_end_r <= N && next_end_c <= N && map[next_end_r][next_end_c] == 0) { // VALID CHECK
                solution(end_r, end_c, next_end_r, next_end_c);
            }
        }
    }

    // 대각선
    else if (cur_direction == 0) {
        for (int i = 0; i < 3; ++i) {
            int next_end_r = end_r + diagonal_dr[i];
            int next_end_c = end_c + diagonal_dc[i];
            if (next_end_r <= N && next_end_c <= N && map[next_end_r][next_end_c] == 0) {
                solution(end_r, end_c, next_end_r, next_end_c);
            }
        }
    }

    return;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> N;
    map.assign(N + 1, vector<int>(N + 1, 0)); // index from 1
    for (int r = 1; r <= N; ++r) {
        for (int c = 1; c <= N; ++c) {
            cin >> map[r][c];
        }
    }

    solution(1, 1, 1, 2);
    cout << cnt;
    return 0;
}
```



- - -


### 거짓말 (골드 4 - 분리 집합, 그래프 이론)
```
지민이는 파티에 가서 이야기 하는 것을 좋아한다. 파티에 갈 때마다, 지민이는 지민이가 가장 좋아하는 이야기를 한다. 지민이는 그 이야기를 말할 때, 있는 그대로 진실로 말하거나 엄청나게 과장해서 말한다. 당연히 과장해서 이야기하는 것이 훨씬 더 재미있기 때문에, 되도록이면 과장해서 이야기하려고 한다. 하지만, 지민이는 거짓말쟁이로 알려지기는 싫어한다. 문제는 몇몇 사람들은 그 이야기의 진실을 안다는 것이다. 따라서 이런 사람들이 파티에 왔을 때는, 지민이는 진실을 이야기할 수 밖에 없다. 당연히, 어떤 사람이 어떤 파티에서는 진실을 듣고, 또다른 파티에서는 과장된 이야기를 들었을 때도 지민이는 거짓말쟁이로 알려지게 된다. 지민이는 이런 일을 모두 피해야 한다.

사람의 수 N이 주어진다. 그리고 그 이야기의 진실을 아는 사람이 주어진다. 그리고 각 파티에 오는 사람들의 번호가 주어진다. 지민이는 모든 파티에 참가해야 한다. 이때, 지민이가 거짓말쟁이로 알려지지 않으면서, 과장된 이야기를 할 수 있는 파티 개수의 최댓값을 구하는 프로그램을 작성하시오.
```

문제를 읽고 그래프 탐색으로 풀 수 있을 것 같다는 생각을 했다. 각 사람들을 노드로 두고, 같은 파티에 참여하는 사람들끼리 간선을 모두 이으면. 

"진실을 알고 있는 사람과 간선이 연결되어 있다면. 어떻게든 진실을 알 수 있는 사람이다." 라고 생각했다.
따라서 진실을 알고 있는 사람과 간선이 연결되어 있지 않은 사람들끼리만 이루어져있는 파티에서만 과장을 할 수 있다.

그리고 naive한 아이디어에서 한 단계 더 나아갔다.
분리 집합과 유사한 것 같아서 Union-find를 사용하는 문제라고 확신했다.

분리 집합에 대한 이해가 부족했는데 이를 연습할 수 있는 문제였다. 높은 트리에 낮은 트리를 붙여야 트리가 너무 깊어지는 것을 막을 수 있다.

```cpp
// 백준: 거짓말
// 2024-05-23
// https://www.acmicpc.net/problem/1043

/*
그래프 탐색 같다.
각 사람들을 노드로 두고, 같은 파티에 참여하는 사람끼리 간선을 잇는다.
진실을 알고 있는 사람과 간선이 연결되어 있다면. 어떻게든 진실을 알 수 있는 사람이다.
따라서 진실을 알고 있는 사람과 간선이 연결되어 있지 않은 사람들끼리만 이루어져있는 파티에서만 과장을 할 수 있다.

근데 문제는 간선 정보 추가할 때 파티에 참가한 사람 모두를 엮어야 되는데 이게 너무 비효율적이다.
Union-find를 사용해야 할 것 같다.

PS. Union-find를 연습할 수 있는 교육적인 문제. 높은 트리에 낮은 트리를 붙여야 트리가 너무 깊어지는 것을 막을 수 있다.
*/

#include <iostream>
#include <vector>
using namespace std;

vector<int> parents;
vector<int> node_rank;

// union-find
int find_root(int x) {
    if (parents[x] != x)
        parents[x] = find_root(parents[x]);
    return parents[x];
}

void union_root(int x, int y) {
    x = find_root(x);
    y = find_root(y);

    if (x != y) {
        if (node_rank[x] < node_rank[y])
            parents[x] = y;
        else if (node_rank[x] > node_rank[y])
            parents[y] = x;
        else {
            parents[y] = x;
            node_rank[x]++;
        }
    }
}

int main() {
    int N, M; // 사람의 수 N, 파티의 수 M
    cin >> N >> M;

    int truthNum; // 진실을 아는 사람의 수
    cin >> truthNum;
    vector<int> truthPeople(truthNum);
    for (int i = 0; i < truthNum; ++i) {
        cin >> truthPeople[i];
    }

    parents.assign(N + 1, 0);
    node_rank.assign(N + 1, 0);
    for (int i = 1; i <= N; ++i) {
        parents[i] = i;
    }

    // 파티 입력받기
    vector<vector<int>> parties(M);
    for (int i = 0; i < M; ++i) {
        int partyNum; // 파티에 오는 사람들
        cin >> partyNum;
        parties[i].resize(partyNum);
        for (int j = 0; j < partyNum; ++j) {
            cin >> parties[i][j];
        }

        // 파티 참석자 모두 union_root
        for (int j = 1; j < partyNum; ++j) {
            union_root(parties[i][0], parties[i][j]);
        }
    }

    // 진실을 아는 사람의 루트 알아내기
    int truthRoot = -1;
    if (truthNum > 0) {
        truthRoot = find_root(truthPeople[0]);
        for (int i = 1; i < truthNum; ++i) {
            union_root(truthPeople[0], truthPeople[i]);
        }
        truthRoot = find_root(truthPeople[0]);
    }

    // 모든 파티를 순회하면서 진실을 아는 사람과 root가 같은 참석자가 없는지 체크
    int cnt = 0;
    for (const auto &party : parties) {
        bool flag = true;
        for (const auto &person : party) {
            if (find_root(person) == truthRoot) { // 진실을 아는 사람과 루트가 같다면
                flag = false;
                break;
            }
        }
        if (flag)
            cnt++;
    }

    cout << cnt;
    return 0;
}
```




- - -


### 알파벳 (백트래킹, 그래프 이론)
```
세로 
R칸, 가로 C칸으로 된 표 모양의 보드가 있다. 보드의 각 칸에는 대문자 알파벳이 하나씩 적혀 있고, 좌측 상단 칸 1행 1열 에는 말이 놓여 있다.

말은 상하좌우로 인접한 네 칸 중의 한 칸으로 이동할 수 있는데, 새로 이동한 칸에 적혀 있는 알파벳은 지금까지 지나온 모든 칸에 적혀 있는 알파벳과는 달라야 한다. 즉, 같은 알파벳이 적힌 칸을 두 번 지날 수 없다.

좌측 상단에서 시작해서, 말이 최대한 몇 칸을 지날 수 있는지를 구하는 프로그램을 작성하시오. 말이 지나는 칸은 좌측 상단의 칸도 포함된다.
```

간단하다. 그냥 그래프 탐색 + 백트래킹 문제인데, 이미 밟은 알파벳을 밟으면 안되니까 체크하면서 가면 된다.
근데 문제는 이미 밟은 알파벳을 배열에 char형태로 담거나 unordered_set 같은걸로 담으면 **TLE**가 난다. set이 생각보다 해쉬 함수 과정에서 오버헤드가 많이 나는 것 같다. 약간의 속도 차이가 누적되어서 큰 차이를 만든다.

알파벳의 개수는 26개이기 때문에 bool 형태의 vector index에 할당해서 방문을 체크하거나, 비트 마스킹을 사용해서 효율적으로 처리할 수 있다.

나는 비트마스킹을 이용해서 처리했다.
비트마스킹의 기초를 다지게 된 교육적인 문제다.

```cpp
// 백준: 알파벳
// https://www.acmicpc.net/problem/1987
// 2024-05-23

/*
전형적인 백트래킹 + DFS 문제에
unique 알파벳을 저장하는데에 제일 효율적인 unordered_set으로 알파벳 체크 + 방문체크
방문 체크 배열을 따로 만들 필요가 없다. 어차피 이미 방문한 위치의 경우 알파벳이 겹쳐서 재방문하지 못한다.
unordered_set으로 알파벳을 관리해도 TLE가 난다. 비트마스킹을 해야 한다. 32비트 정수형에서 저장할 수 있는 상태는 총 32개.
대소문자 알파벳의 개수는 26개이기 때문에 충분히 가능하다.

PS. 비트마스킹의 기초를 다지게 된 교육적인 문제.
*/

#include <iostream>
// #include <unordered_set>
#include <vector>
using namespace std;

int dr[4] = {1, -1, 0, 0};
int dc[4] = {0, 0, 1, -1};

int R, C; // R*C의 보드
vector<vector<char>> map;

int known_farthest_depth = 0;

void solution(int depth, int cur_r, int cur_c, int bitmask) {
    if (known_farthest_depth < depth)
        known_farthest_depth = depth;

    for (int i = 0; i < 4; ++i) {
        int next_r = cur_r + dr[i];
        int next_c = cur_c + dc[i];
        if (next_r >= 0 && next_c >= 0 && next_r < R && next_c < C) { // VALID CHECK
            int next_char_bit = 1 << (map[next_r][next_c] - 'A');
            if ((bitmask & next_char_bit) == 0) { // 아직 나오지 않은 알파벳
                solution(depth + 1, next_r, next_c, bitmask | next_char_bit);
                // bitmask &= ~next_char_bit; 재귀 호출 인자에서 값을 변경해서 보내기에, 백트래킹 필요 없음.
            }
        }
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> R >> C;
    map.assign(R, vector<char>(C, '\0'));
    for (int r = 0; r < R; ++r) {
        for (int c = 0; c < C; ++c) {
            cin >> map[r][c];
        }
    }

    // unordered_set<char> set;
    int start_bitmask = 1 << (map[0][0] - 'A');
    // set.insert(map[0][0]); // 시작 지점 추가
    solution(1, 0, 0, start_bitmask);
    cout << known_farthest_depth;
    return 0;
}
```


- - -


### 별 찍기 - 11 (골드 4 - 재귀)
예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요. 라는 간단 명료한 문제지만
재귀 분할정복을 이용해서 풀어야 하는 상당히 머리 아픈 문제.
겁을 먹지 않고 패턴을 찾아서 접근하면 풀 수 있다.. 하지만 처음엔 어떻게 접근해야 할지 감도 잡지 못했다.

일단 공백으로 가득 찬 2차원 배열을 만들고 천천히 채워 나간다는 발상을 하고나서는 마음이 그나마 편안해졌다.

```
                       *                        
                      * *                       
                     *****                      
                    *     *                     
                   * *   * *                    
                  ***** *****                   
                 *           *                  
                * *         * *                 
               *****       *****                
              *     *     *     *               
             * *   * *   * *   * *              
            ***** ***** ***** *****             
           *                       *            
          * *                     * *           
         *****                   *****          
        *     *                 *     *         
       * *   * *               * *   * *        
      ***** *****             ***** *****       
     *           *           *           *      
    * *         * *         * *         * *     
   *****       *****       *****       *****    
  *     *     *     *     *     *     *     *   
 * *   * *   * *   * *   * *   * *   * *   * *  
***** ***** ***** ***** ***** ***** ***** *****
```


별을 이런 식으로 채워야 하는데 어떻게 겁을 안 먹을 수가 있을까?



1. 제일 기본 형태를 생각해보자
N은 항상 3x2^k 수이기 때문에 3x2^0인 3이 N이 될 수 있는 최소의 수이다.
따라서 제일 기본 형태는 다음과 같고: 이를 그리는 함수를 만들었다.
```
  *                        
 * *                       
*****
```

```cpp
void draw(int r, int c) {
    output[r][c] = '*';
    output[r + 1][c - 1] = '*';
    output[r + 1][c + 1] = '*';
    output[r + 2][c - 2] = '*';
    output[r + 2][c - 1] = '*';
    output[r + 2][c] = '*';
    output[r + 2][c + 1] = '*';
    output[r + 2][c + 2] = '*';
}
```

~~개노가다~~


2. 이제 전체 배열의 좌표를 받고, 기준에 맞게 분할한다.
위 기본 형태의 삼각형이 나올때는 N == 3 이 됐을때 뿐이다. 따라서 재귀 함수의 기저 조건으로 N == 3일때 위의 기본 삼각형을 그리도록 한다.

잘 보면 문제에서 주어진 패턴은 모두 기본 삼각형으로만 이루어져 있다. 따라서 적절한 기준으로 배열을 분할하고 적절한 좌표로 draw 함수를 호출해주기만 하면 완성이다.

```cpp
void solution(int len, int r, int c) {
    if (len == 3) {
        draw(r, c);
        return;
    }

    solution(len / 2, r, c);                     // 윗 부분
    solution(len / 2, r + len / 2, c - len / 2); // 왼쪽 부분
    solution(len / 2, r + len / 2, c + len / 2); // 오른쪽 부분
}
```

코드는 쉽지만 도출 과정이 결코 쉽지 않다.
비쥬얼적 공포를 선사하는 문제. 좌표 관리가 너무 헷갈린다.

```cpp
// 백준: 별 찍기 - 11
// 2024-05-23
// https://www.acmicpc.net/problem/2448

/*
Divide and Conquer
으아아아아아악

빈 벡터 공간을 공백으로 채워놓고 그리자는 생각을 하기 전까진, 접근 하기도 힘들었다.
*/

#include <iostream>
#include <vector>
using namespace std;
vector<vector<char>> output;

void draw(int r, int c) {
    output[r][c] = '*';
    output[r + 1][c - 1] = '*';
    output[r + 1][c + 1] = '*';
    output[r + 2][c - 2] = '*';
    output[r + 2][c - 1] = '*';
    output[r + 2][c] = '*';
    output[r + 2][c + 1] = '*';
    output[r + 2][c + 2] = '*';
}

void solution(int len, int r, int c) {
    if (len == 3) {
        draw(r, c);
        return;
    }

    solution(len / 2, r, c);                     // 윗 부분
    solution(len / 2, r + len / 2, c - len / 2); // 왼쪽 부분
    solution(len / 2, r + len / 2, c + len / 2); // 오른쪽 부분
}

int main() {
    ios_base::sync_with_stdio(false);
    cout.tie(nullptr);
    int N;
    cin >> N;
    output.assign(N, vector<char>(N * 2 - 1, ' '));

    solution(N, 0, N - 1);

    for (int r = 0; r < N; ++r) {
        for (int c = 0; c < N * 2 - 1; ++c) {
            cout << output[r][c];
        }
        cout << "\n";
    }

    return 0;
}
```



- - -



### 이진 검색 트리 (골드 4 - 트리)
```
이진 검색 트리는 다음과 같은 세 가지 조건을 만족하는 이진 트리이다.

- 노드의 왼쪽 서브트리에 있는 모든 노드의 키는 노드의 키보다 작다.
- 노드의 오른쪽 서브트리에 있는 모든 노드의 키는 노드의 키보다 크다.
- 왼쪽, 오른쪽 서브트리도 이진 검색 트리이다.
- 
전위 순회 (루트-왼쪽-오른쪽)은 루트를 방문하고, 왼쪽 서브트리, 오른쪽 서브 트리를 순서대로 방문하면서 노드의 키를 출력한다. 후위 순회 (왼쪽-오른쪽-루트)는 왼쪽 서브트리, 오른쪽 서브트리, 루트 노드 순서대로 키를 출력한다. 예를 들어, 아래의 이진 검색 트리의 전위 순회 결과는 50 30 24 5 28 45 98 52 60 이고, 후위 순회 결과는 5 28 24 45 30 60 52 98 50 이다.

이진 검색 트리를 전위 순회한 결과가 주어졌을 때, 이 트리를 후위 순회한 결과를 구하는 프로그램을 작성하시오.
```


![image](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/upload/images/bsearchtree.png)


어떻게 접근해야 할지 감이 안잡혔던 문제. 결국에 트리의 삽입 메서드에 대해 배웠고. 이를 이용해서 풀었다.
이진 검색 트리의 특성은 문제에서 알려준 것과 같이:

- 노드의 왼쪽 서브트리에 있는 모든 노드의 키는 노드의 키보다 작다.
- 노드의 오른쪽 서브트리에 있는 모든 노드의 키는 노드의 키보다 크다.
- 왼쪽, 오른쪽 서브트리도 이진 검색 트리이다.

이다. 따라서 트리의 insert(삽입) 메서드는 위와 같은 규칙으로 자신의 자리를 찾아 나가게 재귀적으로 구현할 수 있다.

먼저, TreeNode 구조체를 만든다. 노드 구조체는 가장 기본적인 value와, 자신의 왼쪽 자식과 오른쪽 자식의 메모리 주소를 가리키고 있다.

```cpp
struct TreeNode {
    int value;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : value(x), left(nullptr), right(nullptr) {}
};
```

( 설명 추가 )

```cpp
TreeNode *insert(TreeNode *root, int value) {
    if (root == nullptr) {
        return new TreeNode(value);
    }

    if (value > root->value) {
        root->right = insert(root->right, value);
    }
    if (value < root->value) {
        root->left = insert(root->left, value);
    }

    return root;
}
```


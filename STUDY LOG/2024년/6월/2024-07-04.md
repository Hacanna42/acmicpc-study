재밌는 일정이 모두 끝~
보석 도둑 문제를 풀었는데 (1202) 정말 어려웠다. 그만큼 재밌고 복잡한..
단순 for 탐색은 안되고 pq를 써야 하는 이유와 .. 그 로직이 꽤나 ...


그리디적으로 제일 작은 용량의 가방에서 허용되는 제일 큰 가치의 보석을 넣으면 항상 최댓값을 찾을 수 있는데
어떻게 하면 이걸 효율적으로 찾을 수 있을까에 대한 문제다
보석을 무게 오름차순으로 정렬하고, 가방도 최대 용량 오름차순으로 정렬해서
가장 작은 용량부터, 넣을 수 있는 보석들의 정보를 pq에 추가하고 pq.top(),
또 다음 용량에서 새롭게 넣을 수 있게 된 보석을 pq에 추가하고 pq.top() 하는 방식으로 풀었다.

엣지 케이스로 현재 가방 용량에서 넣을 수 있는 보석이 아예 없을수도 있으니 pq.empty()  체크도 매번 해야한다.


발상이 너무 어려웠지만 재미있는 문제였습니다. 핵심은 각 가방에 넣을 수 있는 최대 가치 보석을 찾는 건데 어떻게든 중복 계산을 피하면 풀 수 있어 보였습니다. 정렬과 우선순위 큐를 잘 이용해서 제일 작은 용량의 가방부터 최대 가치 보석을 순차적으로 탐색하는 방식으로 풀었고 이런 방법을 사용하지 않는다면 매 크기의 가방 탐색마다 중복 계산을 감수해야 합니다.


보석을 무게 오름차순으로 정렬.
가방도 한계 용량 오름차순으로 정렬.
제일 작은 가방 용량부터, 넣을 수 있는 보석을 priority_queue에 추가 .top()을 가방에 넣음.
다음 가방 용량으로 넘어가면서 새롭게 고려 가능해진 보석을 pq에 추가.. 반복
만약 pq를 사용하지 않고 배열을 for로 탐색하면 매 크기의 가방 탐색마다 중복 계산을 감수해야 함
memoization으로도 풀 수 있지 않을까 하는 의문점이 듦.


- - -

합이 0인 네 정수 문제도 풀었다..
골드 2는 아이디어 구상에서 결이 다름을 느꼈다 ...
이걸 이런식으로 풀다니 ~ 
MITM 으로 O(N^4) 문제를 O(N^2) 문제 두개로 나누고 투 포인터를 이용해서 효율적으로 탐색한다.
포인터 인덱스를 옮기기전에 인접한 인덱스에 같은 요소가 있을 수 있으므로 포인터 인덱스를 섣불리 옮기면 안된다.

인접 인덱스의 같은 요소 개수를 모두 파악하고 곱셈으로 모든 조합을 구해야 한다.
그리고 ,, A B C D 배열이 모두 길이가 4000이고 요소가 모두 0일경우 int 범위를 초과할 수도 있다.




2024.07.06
선분 교차 2 문제를 풀다가 ccw라는 개념을 만났고
벡터에서 막혀서 음,, 이제 알고리즘을 더 진행하려면 수학을 확실히 잡아야겠다는 생각이 심화되었다.
그래서 책을 구매했다
1. 컴퓨팅 사고력을 키우는 이산수학 
2. 문제 해결을 위한 알고리즘 with 수학

아이패드로 풀 예정.
분명 수학이 알고리즘 실력 향상에 도움이 된다만 ........
뭔가 멈춰지는 기분이긴 하다.
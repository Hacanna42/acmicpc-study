재밌는 일정이 모두 끝~
보석 도둑 문제를 풀었는데 (1202) 정말 어려웠다. 그만큼 재밌고 복잡한..
단순 for 탐색은 안되고 pq를 써야 하는 이유와 .. 그 로직이 꽤나 ...


그리디적으로 제일 작은 용량의 가방에서 허용되는 제일 큰 가치의 보석을 넣으면 항상 최댓값을 찾을 수 있는데
어떻게 하면 이걸 효율적으로 찾을 수 있을까에 대한 문제다
보석을 무게 오름차순으로 정렬하고, 가방도 최대 용량 오름차순으로 정렬해서
가장 작은 용량부터, 넣을 수 있는 보석들의 정보를 pq에 추가하고 pq.top(),
또 다음 용량에서 새롭게 넣을 수 있게 된 보석을 pq에 추가하고 pq.top() 하는 방식으로 풀었다.

엣지 케이스로 현재 가방 용량에서 넣을 수 있는 보석이 아예 없을수도 있으니 pq.empty()  체크도 매번 해야한다.


발상이 너무 어려웠지만 재미있는 문제였습니다. 핵심은 각 가방에 넣을 수 있는 최대 가치 보석을 찾는 건데 어떻게든 중복 계산을 피하면 풀 수 있어 보였습니다. 정렬과 우선순위 큐를 잘 이용해서 제일 작은 용량의 가방부터 최대 가치 보석을 순차적으로 탐색하는 방식으로 풀었고 이런 방법을 사용하지 않는다면 매 크기의 가방 탐색마다 중복 계산을 감수해야 합니다.


보석을 무게 오름차순으로 정렬.
가방도 한계 용량 오름차순으로 정렬.
제일 작은 가방 용량부터, 넣을 수 있는 보석을 priority_queue에 추가 .top()을 가방에 넣음.
다음 가방 용량으로 넘어가면서 새롭게 고려 가능해진 보석을 pq에 추가.. 반복
만약 pq를 사용하지 않고 배열을 for로 탐색하면 매 크기의 가방 탐색마다 중복 계산을 감수해야 함
memoization으로도 풀 수 있지 않을까 하는 의문점이 듦.
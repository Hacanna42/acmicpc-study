# <span style="color:yellow">2024-01-17</span>

컨디션이 괜찮아져서 새벽부터 공부를 시작했다.
오늘은 어제 풀다 말은 이분탐색 문제를 마저 풀겠다.

# 오늘의 백준
```
1300 K번째 수(골드 1)
12015 가장 긴 증가하는 부분 수열 2(골드 2)
```

1300번 문제는 Idea를 생각하기 매우 힘든 문제였다.
I * J  를 ij로 두는 배열의 i행은 i의 배수 형태를 띈다. 따라서, N/i 의 몫은 i번째 행에 N보다 작은 수의 개수와 똑같다.

이분 탐색에서 low를 1, high을 N\*N으로 두고 mid에 대해서 각 행의 몫을 합산하면 배열에서 mid보다 작거나 같은 값이 몇개인지 알 수 있다. 이를 이용해서 K번째 index가 어디인지 구한다는 것은, K보다 작거나 같은 값이 K와 같거나 이상인 곳을 구하는 것이다. 이를 이분탐색으로 구현하면 풀 수 있는 문제였다. 


12015 문제도 아이디어를 생각하기 힘든 문제였다. 그래도 한번 배운 이상 까먹진 않을 것 같다.
해법은 lower_bound를 이용한 것이다. lower_bound를 이분탐색을 통해 구현할 수 있다.
이전 수보다 큰 수가 들어오면 push 하고, 작은 수가 들어오면 lower_bound로 덮어 씌우는 방식으로 최장증가부분수열을 구한다.



- - -
일어나서 할 것
- [ ] Heap과 priority queue STL 직접 구현해보기
- [ ] 우선순위 큐, 동적 계획법 2 풀기.

```
11279 최대 힙(실버 2)
1927 최소 힙(실버 2)
```

11279 문제는 우선순위 큐, 힙을 사용하는 문제로. C++ queue STL의 priority_queue를 쓰면 쉽게 해결 할 수 있었다.

1927 문제는 최소 힙을 구현하는 문제인데, STL에 있는 priority_queue의 최대 힙을 최소 힙으로 동작하게 만드려면 비교 함수를 수정해야 한다.
비교 함수를 수정하는 방식은 std::sort의 compare 함수랑 비슷할 줄 알았는데, 조금 다르다.
람다 함수나 operator()를 오버로드하는 객체를 만들어야 한다.
조금 복잡해서 그냥 std::greater<> 를 쓰면 된다.
한번쯤 operator나 람다 함수를 써서 구현하는 법도 알아보면 ... 도움은 될듯.

# <span style="color:yellow">2024-01-17</span>

컨디션이 괜찮아져서 새벽부터 공부를 시작했다.
오늘은 어제 풀다 말은 이분탐색 문제를 마저 풀겠다.

# 오늘의 백준
```
1300 K번째 수(골드 1)
12015 가장 긴 증가하는 부분 수열 2(골드 2)
```

1300번 문제는 Idea를 생각하기 매우 힘든 문제였다.
I * J  를 ij로 두는 배열의 i행은 i의 배수 형태를 띈다. 따라서, N/i 의 몫은 i번째 행에 N보다 작은 수의 개수와 똑같다.

이분 탐색에서 low를 1, high을 N\*N으로 두고 mid에 대해서 각 행의 몫을 합산하면 배열에서 mid보다 작거나 같은 값이 몇개인지 알 수 있다. 이를 이용해서 K번째 index가 어디인지 구한다는 것은, K보다 작거나 같은 값이 K와 같거나 이상인 곳을 구하는 것이다. 이를 이분탐색으로 구현하면 풀 수 있는 문제였다. 


12015 문제도 아이디어를 생각하기 힘든 문제였다. 그래도 한번 배운 이상 까먹진 않을 것 같다.
해법은 lower_bound를 이용한 것이다. lower_bound를 이분탐색을 통해 구현할 수 있다.
이전 수보다 큰 수가 들어오면 push 하고, 작은 수가 들어오면 lower_bound로 덮어 씌우는 방식으로 최장증가부분수열을 구한다.



- - -
일어나서 할 것
- [ ] Heap과 priority queue STL 직접 구현해보기
- [ ] 우선순위 큐, 동적 계획법 2 풀기.
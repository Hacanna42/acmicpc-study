# <span style="color:yellow">2024-01-17</span>

컨디션이 괜찮아져서 새벽부터 공부를 시작했다.
오늘은 어제 풀다 말은 이분탐색 문제를 마저 풀겠다.

# 오늘의 백준
```
1300 K번째 수(골드 1)
12015 가장 긴 증가하는 부분 수열 2(골드 2)
```

1300번 문제는 Idea를 생각하기 매우 힘든 문제였다.
I * J  를 ij로 두는 배열의 i행은 i의 배수 형태를 띈다. 따라서, N/i 의 몫은 i번째 행에 N보다 작은 수의 개수와 똑같다.

이분 탐색에서 low를 1, high을 N\*N으로 두고 mid에 대해서 각 행의 몫을 합산하면 배열에서 mid보다 작거나 같은 값이 몇개인지 알 수 있다. 이를 이용해서 K번째 index가 어디인지 구한다는 것은, K보다 작거나 같은 값이 K와 같거나 이상인 곳을 구하는 것이다. 이를 이분탐색으로 구현하면 풀 수 있는 문제였다. 


12015 문제도 아이디어를 생각하기 힘든 문제였다. 그래도 한번 배운 이상 까먹진 않을 것 같다.
해법은 lower_bound를 이용한 것이다. lower_bound를 이분탐색을 통해 구현할 수 있다.
이전 수보다 큰 수가 들어오면 push 하고, 작은 수가 들어오면 lower_bound로 덮어 씌우는 방식으로 최장증가부분수열을 구한다.



- - -
일어나서 할 것
- [ ] Heap과 priority queue STL 직접 구현해보기
- [ ] 우선순위 큐, 동적 계획법 2 풀기.

```
11279 최대 힙(실버 2)
1927 최소 힙(실버 2)
11268 절댓값 힙(실버 1)
11066 파일 합치기(골드 3)
```

11279 문제는 우선순위 큐, 힙을 사용하는 문제로. C++ queue STL의 priority_queue를 쓰면 쉽게 해결 할 수 있었다.

1927 문제는 최소 힙을 구현하는 문제인데, STL에 있는 priority_queue의 최대 힙을 최소 힙으로 동작하게 만드려면 비교 함수를 수정해야 한다.
비교 함수를 수정하는 방식은 std::sort의 compare 함수랑 비슷할 줄 알았는데, 조금 다르다.
람다 함수나 operator()를 오버로드하는 객체를 만들어야 한다.
조금 복잡해서 그냥 std::greater<> 를 쓰면 된다.
한번쯤 operator나 람다 함수를 써서 구현하는 법도 알아보면 ... 도움은 될듯.

11268 절댓값 힙은 직접 힙의 compare 함수를 커스텀해서, 절댓값으로 비교하게 만드는 문제다.
C++ queue STL의 priority_queue와 operator() 함수를 오버로딩해서 새로운 비교 함수를 만들면 쉽게 풀 수 있는 문제였다.

푸는 도중 새로운 개념을 알았다:
- 함수 객체(Function Object)또는 펑터(Functor)
클래스 또는 구조체의 인스턴스를 함수처럼 호출할 수 있게 하는 방법으로, ``operator()(int a, int b) {}`` 식으로 쓴다.

인자를 소괄호에 넘기기 전에,, 앞에 소괄호를 이미 열고 닫는 문법이라니.. 생소하다.


이렇게 우선순위 큐 레벨은 끝났다.
다음은 DP 심화 레벨이다.

Idea만 생각해보고, 아직 풀진 못했다.
오늘도 컨디션이 좀 안좋아서.. (며칠 전부터 두통이 심해졌다) 여기까지 하고 내일 재개하겠다.


# 최종 평가
```ElonMusk
일자: 2024-01-17
평가사: 최고급 평가사 일론머스크
평가 대상: 사용자의 학습 내용 및 진도

학습 내용:
1. 백준 이분 탐색 고급 문제 해결
   - 문제 #1300 (K번째 수), #12015 (가장 긴 증가하는 부분 수열 2)
2. 우선순위 큐 관련 문제 해결 및 STL 구현 학습
   - 문제 #11279 (최대 힙), #1927 (최소 힙), #11268 (절댓값 힙)
3. 함수 객체(Function Object) 및 Functor 개념 학습
4. 동적 계획법 심화 문제 준비

진도 분석:
- 이분 탐색 고급 문제에 대한 해결능력은 알고리즘 이해의 심화를 보여줌.
- 우선순위 큐와 관련된 문제 해결 및 STL 구현 학습은 자료 구조에 대한 이해를 강화함.
- 함수 객체와 Functor 개념의 학습은 프로그래밍 언어에 대한 깊은 이해를 나타냄.

핵심 개념 평가:
1. 이분 탐색 - 문제 #1300과 #12015의 해결은 이 알고리즘의 심화된 이해를 보여줍니다. 특히, K번째 수 문제는 복잡한 이분 탐색 적용을 요구하는 높은 난이도의 문제입니다.
2. 우선순위 큐와 STL 구현 - #11279, #1927, #11268 문제 해결을 통해 우선순위 큐의 구현 및 응용 능력을 높였습니다. 이는 자료 구조에 대한 실제적 이해를 의미합니다.
3. 함수 객체(Function Object)와 Functor - 프로그래밍 언어의 더 깊은 측면을 탐색하는 중요한 단계입니다.

향후 학습 방향:
- 이분 탐색과 우선순위 큐에 대한 학습을 통해 알고리즘과 자료 구조에 대한 이해를 더욱 확장할 필요가 있습니다.
- 동적 계획법 심화 학습을 통해 알고리즘 문제 해결 능력을 더욱 강화할 수 있을 것입니다.

점수: 90/100

점수 산정 근거: 이분 탐색 고급 문제 해결 능력과 우선순위 큐 관련 문제 해결 및 STL 구현 학습의 진척을 높이 평가하나, 연속된 컨디션 저하로 인해 학습 진도가 완전히 이루어지지 않은 점을 고려하여 일부 감점함.

오늘의 학습은 이분 탐색과 우선순위 큐, 그리고 STL 구현에 중점을 둔 것으로 보입니다. 특히 문제 #1300과 #12015의 해결은 이분 탐색에 대한 깊은 이해를 보여줍니다. 또한, 우선순위 큐와 관련된 문제들을 해결하고, STL을 직접 구현해본 것은 자료 구조에 대한 실질적인 이해를 보여주는 중요한 단계입니다. 함수 객체(Function Object)와 Functor의 개념 학습은 프로그래밍 언어에 대한 더 깊은 이해로 이어질 것입니다. 동적 계획법 심화 학습으로의 이동은 앞으로의 학습에 더 큰 도전을 제시할 것입니다. 지속적인 학습과 도전으로 알고리즘과 프로그래밍 언어에 대한 깊은 이해를 계속 발전시켜 나가시길 바랍니다.
```

# <span style="color:yellow">2024-01-09</span>

# 오늘의 백준
```level22
백준 레벨 22: 백트래킹
14888 연산자 끼워넣기(실버 1)
14889 스타트와 링크(실버 1)

백준 레벨 23: 동적 계획법 1
24416 알고리즘 수업 - 피보나치 수(브론즈 1)

```

14888 문제는 삼성SW 역량 기출문제였는데, 생각보다 어렵진 않았고 구현하는 부분이 재밌었다.
확실히 공통 수학 조건식 하나 머리 쥐어짜서 고민하는 것보단, DFS랑 백트래킹같이 시뮬레이션 류라고 해야할까 그런게 좀 더 개발할 때 재밌는 것 같다.

이번 문제는 모든 연산자를 대입해보며 최댓값과 최솟값을 구하는 문제였는데, DFS 재귀 함수에서 총합의 변수 상태 관리에 로직 에러가 있어서 살짝 고생했다.
어차피 flow가 가지별로 가기 때문에 전역으로 선언해놓고 return 하기 전에 0으로 되돌려 놓는 방법을 썼는데, 유효한 방법은 DFS 호출할 때 current_sum 값을 같이 보내줘서 각 가지마다 다른 값을 참조하도록 하는 방법이 유효했다.

14889 문제는 14888 문제보다 어려웠다. 어려웠던 이유는 조합에서 로직을 잘못 생각해서 작동은 하지만 비효율적인 알고리즘을 작성했고, 계속 시간 초과가 떴다.

큰 이유는 두가지였다.
1. 사람이 6명일 때, 팀을 가른다고 하면 팀1에 3명을 선택하면 팀2는 자동으로 결정되는데 이를 간과하고 팀1과 팀2의 모든 조합에 대해 탐색해서 리소스를 낭비했다.
2. 반복문에서 인덱스를 계속 0부터 N까지 돌려서 이미 고려된 사람에 대한 조합을 다시 고려하는 실수를 했다.

위의 로직 개선점을 모두 수정하고 다시 제출하니 정답 처리되었다.

```cpp
// 백준: 스타트와 링크
// https://www.acmicpc.net/problem/14889
// 2024-01-09

#include <limits.h>

#include <algorithm>
#include <cmath>
#include <iostream>
#include <vector>

int N;
int answer = INT_MAX;
std::vector<std::vector<int> > v;
std::vector<int> speclist;

void dfs(int idx, int L, std::vector<bool>& team) {
    if (L == N / 2) {
        int start = 0, link = 0;
        for (int i = 0; i < N; ++i) {
            for (int j = 0; j < N; ++j) {
                if (team[i] && team[j]) start += v[i][j];
                if (!team[i] && !team[j]) link += v[i][j];
            }
        }
        answer = std::min(answer, abs(start - link));
        return;
    }

    for (int i = idx; i < N; ++i) {
        if (!team[i]) {
            team[i] = true;
            dfs(i + 1, L + 1, team);
            team[i] = false;
        }
    }
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    std::cin >> N;
    v.assign(N, std::vector<int>(N));
    std::vector<bool> team(N, false);
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j) {
            std::cin >> v[i][j];
        }
    }

    dfs(0, 0, team);
    std::cout << answer;
    return 0;
}
```

DFS와 백트래킹은 이제 정말 알겠다. 근데 조합은 여전히 헷갈리는 부분이 있는 것 같다.
DFS 재귀 호출에서 상태를 계속 관리하는건 DFS 함수 자체의 인자로 넘겨야 하는데, 이것도 계속 간과하고 있다.

이로써 백준 레벨 22: 백트래킹 문제에 대한 모든 풀이를 완료하였다 (총 8문제)

이제 백준 레벨 23: 동적 계획법 1을 풀 예정이다.


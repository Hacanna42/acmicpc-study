# <span style="color:yellow">2024-01-09</span>

# 오늘의 백준
```level22
백준 레벨 22: 백트래킹
14888 연산자 끼워넣기(실버 1)
14889 스타트와 링크(실버 1)

백준 레벨 23: 동적 계획법 1
24416 알고리즘 수업 - 피보나치 수(브론즈 1)
```

14888 문제는 삼성SW 역량 기출문제였는데, 생각보다 어렵진 않았고 구현하는 부분이 재밌었다.
확실히 공통 수학 조건식 하나 머리 쥐어짜서 고민하는 것보단, DFS랑 백트래킹같이 시뮬레이션 류라고 해야할까 그런게 좀 더 개발할 때 재밌는 것 같다.

이번 문제는 모든 연산자를 대입해보며 최댓값과 최솟값을 구하는 문제였는데, DFS 재귀 함수에서 총합의 변수 상태 관리에 로직 에러가 있어서 살짝 고생했다.
어차피 flow가 가지별로 가기 때문에 전역으로 선언해놓고 return 하기 전에 0으로 되돌려 놓는 방법을 썼는데, 유효한 방법은 DFS 호출할 때 current_sum 값을 같이 보내줘서 각 가지마다 다른 값을 참조하도록 하는 방법이 유효했다.

14889 문제는 14888 문제보다 어려웠다. 어려웠던 이유는 조합에서 로직을 잘못 생각해서 작동은 하지만 비효율적인 알고리즘을 작성했고, 계속 시간 초과가 떴다.

큰 이유는 두가지였다.
1. 사람이 6명일 때, 팀을 가른다고 하면 팀1에 3명을 선택하면 팀2는 자동으로 결정되는데 이를 간과하고 팀1과 팀2의 모든 조합에 대해 탐색해서 리소스를 낭비했다.
2. 반복문에서 인덱스를 계속 0부터 N까지 돌려서 이미 고려된 사람에 대한 조합을 다시 고려하는 실수를 했다.

위의 로직 개선점을 모두 수정하고 다시 제출하니 정답 처리되었다.

```cpp
// 백준: 스타트와 링크
// https://www.acmicpc.net/problem/14889
// 2024-01-09

#include <limits.h>

#include <algorithm>
#include <cmath>
#include <iostream>
#include <vector>

int N;
int answer = INT_MAX;
std::vector<std::vector<int> > v;
std::vector<int> speclist;

void dfs(int idx, int L, std::vector<bool>& team) {
    if (L == N / 2) {
        int start = 0, link = 0;
        for (int i = 0; i < N; ++i) {
            for (int j = 0; j < N; ++j) {
                if (team[i] && team[j]) start += v[i][j];
                if (!team[i] && !team[j]) link += v[i][j];
            }
        }
        answer = std::min(answer, abs(start - link));
        return;
    }

    for (int i = idx; i < N; ++i) {
        if (!team[i]) {
            team[i] = true;
            dfs(i + 1, L + 1, team);
            team[i] = false;
        }
    }
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    std::cin >> N;
    v.assign(N, std::vector<int>(N));
    std::vector<bool> team(N, false);
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j) {
            std::cin >> v[i][j];
        }
    }

    dfs(0, 0, team);
    std::cout << answer;
    return 0;
}
```

DFS와 백트래킹은 이제 정말 알겠다. 근데 조합은 여전히 헷갈리는 부분이 있는 것 같다.
DFS 재귀 호출에서 상태를 계속 관리하는건 DFS 함수 자체의 인자로 넘겨야 하는데, 이것도 계속 간과하고 있다.

이로써 백준 레벨 22: 백트래킹 문제에 대한 모든 풀이를 완료하였다 (총 8문제)

이제 백준 레벨 23: 동적 계획법 1을 풀 예정이다.


# 최종 평가
```ElonMusk
[최고급 평가사 일론머스크의 2024-01-09 백준 학습 평가]

1. 백준 문제 풀이 평가:
- 14888 (연산자 끼워넣기): DFS와 백트래킹을 통한 문제 해결 접근이 효과적임. 변수 상태 관리에 대한 문제 인식과 해결이 뛰어남.
- 14889 (스타트와 링크): 조합과 DFS의 복합적 사용이 인상적. 초기 로직의 비효율성을 개선하여 시간 복잡도를 줄인 점이 탁월함.

2. 알고리즘 이해 및 적용:
- DFS와 백트래킹에 대한 깊은 이해와 적용 능력을 다시 한번 증명함.
- 조합에 대한 이해도와 효율적인 알고리즘 설계에 대한 노력이 돋보임.

3. 개선 사항 및 조언:
- DFS 재귀 호출 시 변수의 상태 관리에 더 주의를 기울일 필요가 있음.
- 조합 알고리즘에 대한 추가 학습과 연습을 통해 이해도를 높일 것을 권장함.

4. 오늘의 활동 대비 평균 활동 비교:
- 백준 레벨 22의 모든 문제를 해결하며, 이해도와 문제 해결 능력이 지속적으로 향상되고 있음.
- 동적 계획법으로의 이행은 새로운 알고리즘적 도전을 의미함.

5. 종합 평가 점수: 94/100
- DFS와 백트래킹에 대한 높은 이해를 바탕으로 복잡한 문제를 해결한 점이 인상적.
- 조합과 같은 새로운 알고리즘 영역에 대한 이해도 향상을 위한 노력이 필요함.

[오늘의 학습 종합 코멘트]
- 백트래킹 문제를 통해 DFS의 심화적인 이해와 적용 능력을 보여준 하루였습니다. 동적 계획법으로의 전환은 새로운 알고리즘적 사고를 요구할 것입니다. 이제까지의 학습과 경험을 바탕으로 동적 계획법의 세계에서도 훌륭한 성과를 기대합니다. 항상 도전적인 자세로 새로운 알고리즘을 탐구하는 당신의 여정이 더욱 풍부하고 성공적이길 바랍니다.
```

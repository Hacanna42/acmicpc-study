# <span style="color:yellow">2024-01-06</span>

# 오늘의 백준
```level20
26069 붙임성 좋은 총총이
2108 통계학
20920 영단어 암기는 괴로워
```

map, set은 균형 이진 트리(대부분 레드-블랙)을 사용하고, 삽입 조회에 O(log n)만큼 걸린다.
하지만 unordered는 내부적으로 해시 테이블을 사용하고, 해시 테이블은 들어오는 key 값을 해시 함수로 변환하고 변환된 값에 대응하는 해시 버킷에 할당한다. 따라서 key에 매칭되는 value를 찾는데에 드는 비용은 key를 해시로 바꾸고 해시 인덱스의 버킷을 조회하는 과정으로 O(1)이다.

따라서 거의 웬만한 상황에서는 (정렬이 필요 없다면) unordered를 쓰는것이 적당하지만, 만약 해시 충돌(데이터가 너무 많거나, 데이터의 분포가 적절하지 않을때) 가 일어난다면 해시 버킷을 특정해도 한 버킷에 여러 데이터가 있을 수 있기 때문에 거기서 모든 데이터를 다시 검색해야 한다. 따라서 최악의 경우 log(n)이 걸릴 수 있다.

결론적으로, 대부분의 경우에서 unordered는 O(1)로 std::set, std::map의 O(log n)보다 월등하나, 최악의 경우 unordered의 시간 복잡도가 O(n)이 될 수 있고, 이 경우는 std::set, std::map이 유리하다.

따라서, 26069번 문제: 붙임성 좋은 총총이의 경우. 총총이와 만났던 사람을 추적하는 전염 모델이므로 따로 value값을 저장할 필요가 없고 **중복**여부를 검사하는 것만으로 충분하다.
값을 정렬할 필요도 없고, 데이터의 크기가 최대 2000(줄의 수가 1000이고, 각 줄에 2명씩 입력되기에)이므로, 해시의 충돌 고려는 무의미하다고 판단해 std::unordered_set으로 결정했다.


2108 문제를 풀며 static_cast\<type\>식으로 캐스팅 하는것과, 그냥 단순하게 (type) 식으로 캐스팅 하는것의 차이를 알게 되었다.
static_cast가 좀 더 안전하고 엄격하다, 웬만하면 static_cast를 쓰자.
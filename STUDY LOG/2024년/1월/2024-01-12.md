# <span style="color:yellow">2024-01-12</span>

오늘은 DP 문제를 마저 끝내고, 다음 클래스로 넘어갈 예정이다.

# 오늘의 백준
```DP
백준 레벨 23: 동적 계획법 1
2565 전깃줄(골드 5)
9251 LCS(골드 5)
12865 평범한 배낭(골드 5)

백준 레벨 24: 누적 합
11659 구간 합 구하기 4(실버 3)
2559 수열(실버 3)
16139 인간-컴퓨터 상호작용(실버 1)
```

2565 전깃줄 문제는 LIS의 변형 문제였는데, 막 엄청난 변형은 아니었고 LIS 수열 구성의 아이디어만 찾아내면 쉽게 구현할 수 있는 문제였다.

전봇대 A - B 사이에 연결된 수열이 주어질 때, 전깃줄 A의 순서를 기준으로 B를 정렬하고. 그 수열의 LIS가 교차하지 않고 구성할 수 있는 전깃줄의 총 개수라는 것이다 !..
전깃줄 문제를 LIS로 풀 수 있을줄은 정말 상상도 못한 아이디어었다. 구현은 쉬웠지만 아이디어때문에 시작점도 잘못 짚게 될때 약간의 무력함을 느낀다. 어쨌든 흥미로운 문제였다.

9251 LCS 문제는 LIS와 비슷한 방법일 줄 알았으나 거의 다른 방법이었다.
두 수열에서 이중포문을 돌리면서 memoization을 업데이트 하면 되는 간단한 방법이었다.
근데 하나의 팁이 있다면, memoization의 index -1에 접근하면서 segmentation fault가 날 수 있으니까 index를 일부러 1 늘리고 \[0\]에는 그냥 초기값을 넣고 처리하면 segmentation fault도 피하면서 정확성을 챙길 수 있었다.


12865 평범한 배낭(골드 5) 는 처음 보는 knapsack 문제였다. DP를 활용해서 풀 수 있는데 로직이나 점화식을 도출해내는 과정이 정말 어려웠다.
일단 처음에 ``DP[i]``의 정의는 한번에 제대로 잡았다. 무게가 i일때, 최대 가치합을 말한다.
따라서, DP적으로. 그니까 이 문제를 큰 관점에서 절차적으로 보면 N개의 물건에 대해 가능한 경우의 수는
1. 넣거나
2. 안 넣거나

무조건 둘 중 하나이다. 따라서 점화식을 아래와 같이 구성할 수 있다.
``W = 고려하는 물건의 무게 | V = 고려하는 물건의 가치``
``DP[i] = max(DP[i-1], DP[i-W] + V``
따라서, N개의 물건에 대해서 W가 가방보다 작을경우에 위의 점화식을 적절하게 실행하면 DP의 최댓값에서 가방의 최대가치합을 도출해낼 수 있다.

점화식만 구축하면 쉽게 풀 수 있는 문제였다. 근데 점화식을 구하는데 한시간정도는 쓴 것 같다.
처음에는 DP적으로 생각하지 못하고 모든 조합에 대해 가장 큰 가치합을 구해야 한다고 생각해서 먼저 무게 W에 대한 각 물건들의 가치 테이블을 만들고, 그 가치테이블에서 조합으로 가장 큰 가치합을 구하고 DP에 넘기는 방법을 사용했는데... 이건 DP가 아니다.

항상 명심하자. DP는 가장 간단한 경우의 수부터 고려를 해야한다. 문제를 크게 봐야한다.
가방에 넣는 물건들의 최대 가치합을 구하기 위해선, 가방에 물건을 넣거나 | 넣지 말아야 한다.
가방에 물건을 넣으면 넣은 물건만큼 가치가 증가하고, 남은 무게만큼 새로운 물건을 집어넣을 수 있다.
가방에 물건을 넣지 않으면 원래 가방의 가치를 그대로 가져간다.

이로써, 백준 레벨 23: 동적 계획법 1에 대한 풀이를 모두 완료했다.
이제, 레벨 24: 누적합 차례이다.

복습의 필요성도 서서히 느끼고 있다.
스택, 큐, 덱, 집합, 맵, 정렬, 조합, 재귀, 백트래킹, DFS 등.. 다시 재고할 필요가 있다.
원래는 클래스를 먼저 모두 깨서 기초를 다지고, 랜덤 문제를 풀며 복습도 같이 하려고 했는데
뭔가 이정도의 빠른 템포로 가면, 뒤에 가서 앞의 내용을 몇가지 잊어버릴 것 같다. 


- - -


11659 구간 합 구하기는 누적합 테크닉을 쓰면 쉽게 풀 수 있는 문제.
수열 A의 구간 합을 구하려면
0부터 A.size()까지의 누적합을 각 인덱스에 저장하고 연산하면 된다. 이건 쉽게 추론할 수 있는 알고리즘이었다.

2559 수열 문제는 구간누적합에서 반복문으로 n구간동안의 최대누적합을 구하는 간단한 알고리즘 구현 문제였다.

16139 인간-컴퓨터 상호작용 문제는 누적합을 숫자가 아니라 문자에 대입해서 빠르게 20만자 미만 문자열에서 특정 구간에 특정 알파벳이 몇개 나오는지 반환하는 알고리즘을 작성하는 문제였다.
누적합 알고리즘을 조금만 변형하면, 문자에 대해 각 인덱스 i에 출현하는 알파벳의 누적 개수를 기록하고, l과 r이 주어졌을 때 둘의 차를 이용해 특정 알파벳의 출현 회수를 알 수 있었다. 

말은 간단한데 실제로 구현은 조금 복잡했다. 알파벳의 총 출현 횟수를 저장하기 위한 배열도 따로 만들어야 했고, 다른 각 문자열의 인덱스에 대해 prefix를 업데이트 해주면서, 그 알파벳을 제외한 다른 알파벳의 prefix도 이전 prefix와 동일하게 업데이트 해줘야 나중에 L과 R에 대해서 차합을 구할 때 오류가 없었다.

문제는 부분 점수 문제로 2000자 길이의 문자열 2000개를 1초안에 정리하면 50점.
20만자 길이의 문자열 ?개를 1초안에 정리하면 50점 
총 100점의 문제였고 만점으로 통과했다.

```cpp
// 백준: 인간-컴퓨터 상호작용
// https://www.acmicpc.net/problem/16139
// 2024-01-12

#include <iostream>
#include <string>
#include <vector>

int main() {
    // 문자열 입력
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    std::string str;
    std::getline(std::cin, str);
    std::vector<std::vector<int> > prefix_alphabets(
        26, std::vector<int>(str.length(), 0));
    std::vector<int> prefix_each(26, 0);
    for (int i = 0; i < str.length(); ++i) {
        for (int j = 0; j < 26; ++j) {
            if (i != 0) prefix_alphabets[j][i] = prefix_alphabets[j][i - 1];
        }
        prefix_alphabets[(str[i] - 'a')][i] = ++prefix_each[(str[i] - 'a')];
    }

    // 질문 개수 입력
    int N;
    std::cin >> N;
    for (int i = 0; i < N; ++i) {
        char goal_alphabet;
        int range1, range2;
        std::cin >> goal_alphabet >> range1 >> range2;
        int result = prefix_alphabets[(goal_alphabet - 'a')][range2];
        if (range1 > 0)
            result -= prefix_alphabets[(goal_alphabet - 'a')][range1 - 1];
        std::cout << result << "\n";
    }
    return 0;
}
```


이렇게 오늘은 어제 풀다가 만 백준 레벨 23: 동적 계획법 1의 나머지 문제들과 백준 레벨 24: 누적 합의 세가지 문제를 끝마쳤다.

내일은 누적합 차트를 완전히 끝내고 그리디 알고리즘을 배울 차례다.
악명 높은 그리디 ... 내일 드디어 체험하게 된다.


# 최종 평가
```ElonMusk
[최고급 평가사 일론머스크의 2024-01-12 백준 학습 평가]

1. 오늘의 백준 학습 평가:
- 백준 레벨 23 (동적 계획법 1)을 완료하며, 복잡한 DP 문제 해결 능력을 입증함.
- 2565 (전깃줄): LIS 개념을 새로운 맥락에서 적용하며, 창의적인 문제 해결 방식을 보임.
- 9251 (LCS): 다차원 배열을 사용한 DP 접근 방식과, 알고리즘의 메모리 관리에 대한 이해를 보임.
- 12865 (평범한 배낭): 점화식의 정확한 도출과, DP를 이용한 복잡한 문제 해결 능력을 입증함.

- 백준 레벨 24 (누적 합) 시작:
- 11659 (구간 합 구하기 4), 2559 (수열): 누적 합을 이용한 문제 해결 방식에 대한 빠른 적응력을 보임.
- 16139 (인간-컴퓨터 상호작용): 문자열과 누적 합의 조합을 통해 고급 문제 해결 방식을 표현함.

2. 알고리즘 이해 및 적용:
- DP 문제 해결을 위한 점화식 구성 능력이 뛰어남.
- 누적 합의 개념을 이해하고, 새로운 문제 유형에 효과적으로 적용함.

3. 개선 사항 및 조언:
- 복잡한 DP 문제에 대한 점화식 구성 시, 초기 아이디어에서 빠르게 접근할 수 있는 방법을 모색할 것.
- 누적 합과 같이 새로운 알고리즘 유형을 학습할 때, 기본 개념을 확고히 하고 다양한 문제에 적용해보는 연습이 필요함.

4. 오늘의 활동 대비 평균 활동 비교:
- 새로운 유형의 문제를 효율적으로 해결하며, 전일 대비 더 복잡한 알고리즘 문제에 대한 이해도와 적용 능력을 보임.

5. 종합 평가 점수: 96/100
- DP의 복잡한 문제 해결과 누적 합 문제에 대한 빠른 이해와 적응력이 인상적.
- 알고리즘적 사고력과 문제 해결 능력이 지속적으로 향상되고 있음.

[오늘의 학습 종합 코멘트]
- 오늘은 다양한 DP 문제와 새로운 유형인 누적 합 문제를 해결하며 알고리즘적 사고력을 더욱 발전시켰습니다. 복잡한 문제에 대한 접근 방식에서 창의성과 논리적 사고가 돋보였으며, 새로운 문제 유형에 대한 빠른 적응력도 인상적이었습니다. 앞으로의 그리디 알고리즘 학습에서도 이러한 성장이 지속되기를 기대합니다. 계속해서 멋진 도전을 이어가시길 바랍니다!
```
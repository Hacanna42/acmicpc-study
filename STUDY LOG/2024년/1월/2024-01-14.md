# <span style="color:yellow">2024-01-13</span>

오늘은 그리디를 중점으로 학습할 예정이다.

# 오늘의 백준
```level25
11399 ATM(실버 4)
1541 잃어버린 괄호(실버 2)
13305 주유소(실버 3)
```

11399 는 그리디의 기본 동작 원리를 바탕으로 하는 매우 쉬운 문제였다.

1541 잃어버린 괄호 문제는 탐욕적 조건을 제대로 설정하고 풀면 쉬운 문제였다.
단, 입력 문자열을 적절하게 처리하는것이 조금 어려울 수 있었다.

13305 주유소 문제는 너무 재미있었다, 도시 N 사이의 도로 K에 대해, 각각의 도시엔 주유소와 각각의 기름값이 있고 가장 최소 지출로 도시의 끝까지 도달하는 수를 구하는 문제였다.

발상을 하는 부분도 재밌었고, 구현 부분도 재밌었다. 생각하는 모든것이 순조로웠고 구현하는 모든것이 순조로워서 기분이 좋았다. 단 한번의 시도로 만점을 받아냈다. 아름답다 ㅎㅎ

이로써 그리디 알고리즘이 끝났다. 그리디 알고리즘은 다른 어려운 문제와 결합되어야 어려울 듯 하다. 기본적인 개념은 쉬운 듯 하다. 

```cpp
// 백준: 주유소
// https://www.acmicpc.net/problem/13305
// 2024-01-14

#include <iostream>
#include <vector>
std::vector<long> city_price;
std::vector<long> distance_between_city;
long gas_min_price = 1000000000;
int cities_num;
long long until_arrive = 0;
long long pos_now = 0;
long long current_expenses = 0;

void input();
void greedy();

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    input();
    greedy();
    std::cout << current_expenses;
    return 0;
}

void greedy() {
    int city = 0;
    while (city != cities_num - 1) {
        // 현재 지역이 전역에서 가장 싼 곳이라면
        if (city_price[city] <= gas_min_price) {
            current_expenses += (until_arrive - pos_now) * city_price[city];
            break;
            // 도착
        }

        // 아니라면 다음 싼 지역을 찾는다
        bool isCheapCityExist = false;
        for (int i = city + 1; i < cities_num; ++i) {
            // 현재보다 값이 싼 도시를 찾았다면
            if (city_price[i] < city_price[city]) {
                // 그 도시까지 필요한 기름이 몇인지 구한다
                int need = 0;
                for (int j = city; j < i; ++j) {
                    need += distance_between_city[j];
                }
                // 그 도시까지 갈 수 있는 기름을 현재 도시에서 사고 간다
                current_expenses += need * city_price[city];
                city = i;
                pos_now += need;
                isCheapCityExist = true;
                break;
            }
        }

        // 만약 현재 도시가 가장 싼 곳이라면 여기서 남은 기름을 모두 산다.
        if (!isCheapCityExist) {
            current_expenses += (until_arrive - pos_now) * city_price[city];
            break;
            // 도착
        }
    }
}

void input() {
    std::cin >> cities_num;

    // 도시간 거리 입력
    for (int i = 0; i < cities_num - 1; ++i) {
        long distance;
        std::cin >> distance;
        until_arrive += distance;
        distance_between_city.push_back(distance);
    }

    // 도시당 주유 가격 입력
    for (int i = 0; i < cities_num; ++i) {
        long gas_price;
        std::cin >> gas_price;
        if (gas_price < gas_min_price) gas_min_price = gas_price;
        city_price.push_back(gas_price);
    }
}
```


쉴 시간이 어디있겠는가? 
이제 분할 정복 차례다. 분할 정복은 재귀적 요소도 들어가 있고, 인간친화적인 구성은 아니라서 어려운 문제는 한도 끝도 없이 어려울 것 같다. Divide and Conquer라는 이름부터 어렵다.

```level26
2630 색종이 만들기(실버 2)
```


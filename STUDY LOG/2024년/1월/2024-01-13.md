오늘은 누적합 레벨의 문제를 마저 풀고, 그리디 알고리즘의 기초를 다질 예정이다.

# 오늘의 백준
```level24
10986 나머지 합(골드 3)
11660 구간 합 구하기 5(실버 1)
```

나머지 합 문제는 쉽지 않았다.. 수학적 기믹의 활용이 필요했고 이를 알아내는 과정에서 시간을 많이 소요했다.
결국에 정리하면 솔루션은 이렇다.
나머지 합 문제는: 수열 A가 주어지면, 합이 M으로 나누어 떨어지는 쌍의 조합 개수를 구해야 한다.
어렵지 않은 문제지만 효율적으로 풀어야 했다. 시간제한 1초에 1천만개의 숫자를 정리해야한다. 심지어 각 숫자도 최대 100억 이하이다. 

아이디어는 다음과 같다: M으로 나눠 떨어진다는 것은, 결국에 M의 배수라는 뜻이다. 이 말은 이렇게 볼 수 있다:
M으로 나눈 나머지가 같은 두수가 있다면. 그 두수를 합한 값은 M의 배수이다.

따라서, 누적합에서 알 수 있듯이 특정 구간의 합은 각 prefix끼리의 계산으로 알 수 있고, 누적합을 특정 수 M의 나머지로 저장하면서 계산하면 prefix의 계산으로 특정 구간을 M으로 나눈 나머지를 도출해낼 수 있다. 
만약 두 위치의 모듈러 누적합이 동일한 나머지를 가진다면, 두 위치 사이의 배열의 합이 M의 배수라는 것이다. ``((prefix[j] - prefix[i]) % M == 0 이면 prefix[i] % M == prefix[j] % M 이므로)``
따라서 모든 위치에서 모듈러 누적합의 나머지를 계산하고, 각 나머지를 카운트하면 2보다 큰 카운트를 가지는 나머지는 쌍의 합이 M의 배수가 될 수 있음을 알 수 있다. 따라서 카운트의 쌍 조합을 공식으로 계산하면 ... ``count * (count - 1) / 2 | 왜냐하면, 쌍에서 하나를 고르면 나머지 하나는 못 고르기 때문에, c * (c-1) 이다. 쌍 하나를 조합했다는 건 두개의 숫자를 사용했다는 것이기에 마지막에 2를 나눈다.``

결론적으로
1. 누적합 모듈러 계산
2. 나머지의 일치 쌍 계산
의 과정으로 방대한 데이터를 빠르게 정리할 수 있다.

- - -


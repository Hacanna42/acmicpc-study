# <span style="color:yellow">2024-01-16</span>

오늘은 분할정복의 플래티넘 마지막 문제를 풀고, 이분 탐색 학습을 시작하겠다.
두통이 조금 있어서, 천천히 진행하고자 한다 ...
# 오늘의 백준
```
백준 레벨 26: 분할 정복
6549 히스토그램에서 가장 큰 직사각형(플래티넘 5)

백준 레벨 27: 이분 탐색
1920 수 찾기(실버 4)
1654 랜선 자르기(실버 2)
2805 나무 자르기(실버 2)
2110 공유기 설치(골드 4)
1300 K번째 수(골드 1) - 미해결
```

6549 문제가 처음엔 복잡한 분할정복 구현이라고 생각했다. 가장 짧은 막대 L에 대해 max(answer, L\*SIZE)을 하고 자료구조를 L을 기준으로 나눈 뒤, 각각의 구조에 대해 위 과정을 반복하면 해결할 수 있을 것이라고 생각했다. O(log n)

위의 접근도 유효하지만, Stack을 이용해서 O(n)에 구현하는 방법이 있었다.
1. Stack에 막대 인덱스를 차레대로 삽입
2. if 막대의 높이 < stack.top()의 높이 then .top()의 면적을 계산하고 .pop()
3. 모든 막대의 처리가 끝나면, 남아있는 각 막대에 대해서도 면적 계산
4. 가장 큰 면적이 답이 된다.

이런 천재적인 발상은 누가 처음 시작했을까?

PS. 각 막대에 대해서 확장이 얼마나 가능한지 알아내는것은,
해당 막대의 높이 × (현재 막대의 인덱스 - 스택에서 다음 막대의 인덱스 - 1) 로
간단하게 가능하다.
왜냐하면, 인덱스가 밀렸다는 것은 더 높은 수가 들어왔다는 것이니까.
 

```cpp
// 백준: 히스토그램에서 가장 큰 직사각형
// https://www.acmicpc.net/problem/6549
// 2024-01-15
// - 첫 플래티넘 문제.

#include <algorithm>
#include <iostream>
#include <stack>
int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    while (true) {
        int N;
        std::cin >> N;
        if (N == 0) break;

        std::vector<long long> heights(N, 0);
        for (int i = 0; i < N; ++i) {
            std::cin >> heights[i];
        }

        std::stack<long long> stack;
        long long answer = 0;

        for (int i = 0; i < N; ++i) {
            while (!stack.empty() && heights[stack.top()] > heights[i]) {
                long long height = heights[stack.top()];
                stack.pop();
                // 최대 값으로 설정
                long long width = i;
                if (!stack.empty()) {
                    width = i - stack.top() - 1;
                }
                answer = std::max(answer, height * width);
            }
            stack.push(i);
        }

        // 남아있는 막대 계산
        while (!stack.empty()) {
            long long height = heights[stack.top()];
            stack.pop();
            long long width = N;
            if (!stack.empty()) {
                width = N - stack.top() - 1;
            }
            answer = std::max(answer, height * width);
        }

        std::cout << answer << "\n";
    }
    return 0;
}
```



1920 수 찾기 문제는 간단한 이분탐색 구현 문제였다.

1654 랜선 자르기 문제는 이분 탐색을 이용해 최솟값이나 최댓값을 찾는 테크닉을 이용한 문제였다.
조금 이해하기 어려웠지만 잘 풀었다.

2805 나무 자르기 문제는 랜선 자르기 문제를 응용하면 쉽게 풀 수 있는 문제였다.

2110 공유기 설치 문제는 위의 문제들의 응용 문제였는데, 발상이 조금 쉽게 생각하기 힘든 문제였어서 살짝 어려웠다.
정답은 집 위치를 오름차순 정렬하고, 어떤 간격이든지 첫번째 집은 무조건 공유기를 설치하는게 이득이니까
첫번째 집에 공유기를 설치한 상태에서, 이분 탐색을 통해 적절한 공유기 거리를 찾는 로직이었다.



1300번 K번째 수 문제는 너무나 까다로운 문제다, Idea를 찾기 힘든 문제이기도 하고... 상당히 난이도 있는 문제다.

일단 계속 고민을 해보다가, 오늘 컨디션에선 학습을 그만 해야할 것 같았다.
오늘은 여기서 종료하고 내일 재개하겠다.


# 최종 평가
```ElonMusk
일자: 2024-01-16
평가사: 최고급 평가사 일론머스크
평가 대상: 사용자의 학습 내용 및 진도

학습 내용:
1. 백준 레벨 26 - 분할 정복 마지막 플래티넘 문제 해결
   - 문제 #6549 (히스토그램에서 가장 큰 직사각형)
2. 백준 레벨 27 - 이분 탐색 학습 시작
   - 문제 #1920, #1654, #2805, #2110 해결
   - 문제 #1300 (K번째 수) 미해결

진도 분석:
- 플래티넘 수준의 분할 정복 문제 해결은 알고리즘 이해의 깊이를 나타냄.
- 이분 탐색에 대한 학습 진입은 새로운 알고리즘 영역으로의 확장을 의미.
- 두통으로 인한 컨디션 저하가 학습 진도에 영향을 미침.

핵심 개념 평가:
1. 분할 정복 - 복잡한 문제를 단순한 문제로 나누어 해결하는 능력은 알고리즘 문제 해결의 핵심입니다. 특히 문제 #6549의 스택을 이용한 효율적인 해결 방법은 알고리즘의 깊은 이해를 보여줍니다.
2. 이분 탐색 - 이 알고리즘은 다양한 문제에 적용 가능하며, 최적화 문제 해결에 중요한 도구입니다. 문제 #1654와 #2805의 해결은 이분 탐색의 기본적인 적용을 잘 보여줍니다.
3. 문제 #1300 (K번째 수) - 이 문제는 이분 탐색을 깊이 있게 이해하고 적용해야 하는 고난도 문제입니다. 미해결 상태이지만, 이는 학습 과정에서 자연스러운 일입니다.

향후 학습 방향:
- 이분 탐색과 관련된 문제들을 계속해서 해결해나가면서, 이 알고리즘의 다양한 적용 방법을 학습하는 것이 중요합니다.
- 문제 #1300과 같은 고난도 문제에 대한 도전은 알고리즘 이해를 심화시키는데 매우 유익합니다. 컨디션 회복 후, 재도전을 권장합니다.

점수: 84/100

점수 산정 근거: 고급 알고리즘 문제에 대한 해결 능력과 새로운 학습 영역 진입을 높이 평가하나, 컨디션 저하로 인한 학습 진도의 미흡을 고려하여 일부 감점함.

오늘의 학습은 분할 정복과 이분 탐색이라는 두 가지 중요한 알고리즘 영역에서 의미 있는 진전을 보였습니다. 특히, 플래티넘 수준의 문제를 해결한 것은 주목할 만한 성취입니다. 이분 탐색에 대한 초기 이해와 적용 능력도 인상적입니다. 물론, 문제 #1300과 같은 고난도 문제에 대한 도전은 학습의 깊이를 더욱 높이는 데 중요한 단계이므로, 컨디션이 회복되면 재도전하는 것을 추천합니다. 지속적인 학습과 끈기 있는 도전으로 알고리즘 이해를 더욱 깊게 해 나가시기 바랍니다.
```
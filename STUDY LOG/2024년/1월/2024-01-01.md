# <span style="color:yellow">2024-01-01</span>

2023년의 말: 12월 30일, 31일에는 장염에 걸려서 공부를 제대로 하지 못했다.. 주말이기도 했고.
오늘에서야 컨디션이 회복돼서 다시 공부를 시작한다.

# 오늘의 백준
```level13
2750 수 정렬하기(브론즈 2)
2587 대표값2(브론즈 2)
25305 커트라인(브론즈 2)
2751 수 정렬하기 2(실버 5)
10989 수 정렬하기 3(브론즈 1)
1427 소트인사이드(실버 5)
11650 좌표 정렬하기(실버 5)
```

size_t에 대해서 배웠다. cstddef에 정의되어있는 타입이지만, iostream이나 기타 헤더에 의해 간접적으로 포함되어 있을 수 있다.
버블 소트 알고리즘을 직접 구현했다. 비효율적인 알고리즘이다.

2751 문제를 푸는데 또 방심했다, 시간 초과가 빡센 문제로 std::endl;를 쓰니까 시간 초과가 뜨더라 ..
std::endl은 버퍼를 개행하면서 비우고 \\n는 비우지 않기 때문에, 버퍼 비우는 시간도 아낄 \\n가 더 적합한것.


10989 문제를 풀다가 카운팅 정렬(계수 정렬)이라는 방법을 발견했다.
데이터 수가 많더라도 중복된 값이 많을 때 사용할 수 있는 효율적인 정렬 방식으로.
1. 가장 작은 데이터부터 가장 큰 데이터까지의 범위가 모두 담길 수 있는 리스트를 생성
2. 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가
3. 증가된 리스트에서 0인 값을 제외하고, 인덱스를 인덱스 값만큼 출력
하는 방법이다.



```cpp
// 백준: 수 정렬하기 3
// https://www.acmicpc.net/problem/10989
// 2024-01-01

#include <algorithm>  // 감사합니다
#include <iostream>
#include <sstream>
#include <string>
#include <utility>
#include <vector>

/*
실행시간 출력 메모리 이런거 줄이겠다고 스트림만들고 tie하고 이런거
다 필요 없었고 그저 ... 계수 정렬 방식을 사용하면 됐었다.
*/

int main() {
    int N;
    // 실행시간 다이어트 조치
    std::ios_base::sync_with_stdio(false);  // C++과 C stdio 버퍼링 동기화 끔
    std::cin.tie(nullptr);  // 입출력간 tie 해제(입력 발생 시 출력 버퍼가
                            // 자동으로 비워지는것을 방지)
    int sort_list[10001] = {
        0,
    };
    std::ostringstream oss;
    std::cin >> N;
    for (int i = 0; i < N; ++i) {
        int temp;
        std::cin >> temp;
        sort_list[temp]++;
    }

    // 저장된 계수의 값만큼 출력
    for (int i = 0; i < 10001; ++i) {
        if (sort_list[i] > 0) {
            for (int j = 0; j < sort_list[i]; ++j) {
                std::cout << i << "\n";
            }
        }
    }

    return 0;
}
```



11650 문제의 x y좌표 정렬에 대해서 고민하다가 vector STL의 pair에 대해 알게 되었다.
Linked List로 구현해야하나 했는데 이렇게 편한 방법이 있었다니.


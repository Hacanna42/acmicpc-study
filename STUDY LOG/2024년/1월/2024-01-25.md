# <span style="color:yellow">2024-01-25</span>

오늘은 BFS, DFS 심화 문제를 풀이할 예정이다.

# 오늘의 백준
```
1697 숨바꼭질(실버 1)
7562 나이트의 이동(실버 1)
7576 토마토(골드 5)
7569 토마토 - 3차원 버전(골드 5)
16928 뱀과 사다리 게임(골드 5)
2206 벽 부수고 이동하기(골드 3)
1707 이분 그래프(골드 4)
```


1697 문제는 정말 신기한 문제였다, BFS가 어떤 식으로 최단경로를 찾을 수 있는지 이해하게 되었다. BFS의 특성상 가장 가까운 노드를 먼저 순회하므로, BFS는 최단 경로를 찾는데에 특히 효과적인 알고리즘이다.

BFS는 각 노드를 방문할 때, 방문한 순서가 최단거리임을 항상 보장하므로 목표 노드에 도착한 경로를 추적하면 그것이 최단거리임을 알 수 있다.

처음엔 DP문제일거라고 생각했다, 최단거리를 구하는걸 어떻게 그래프와 순회로 풀 수 있는건지 고민했다. BFS에 이런 멋있는 점이 있었다니 ...


7562 문제는 체스 말이 목표 지점까지 가는 최단 거리를 보드 L\*L에서 구하는 BFS 문제였다.
BFS 이해가 완벽하게 된 것 같다. 문제를 술술 풀었고 한번에 통과했다. 

```cpp
// 백준: 나이트의 이동
// https://www.acmicpc.net/problem/7562
// 2024-01-25

#include <iostream>
#include <queue>
#include <utility>
#include <vector>

int dx[8] = {2, 2, 1, 1, -1, -1, -2, -2};
int dy[8] = {1, -1, 2, -2, 2, -2, 1, -1};

int bfs(std::vector<std::vector<bool> >& board, int x, int y, int goal_x,
        int goal_y, int& l) {
    std::queue<std::pair<std::pair<int, int>, int> > q;
    q.push({{x, y}, 0});
    board[x][y] = true;

    while (!q.empty()) {
        int current_x, current_y, cnt;
        current_x = q.front().first.first;
        current_y = q.front().first.second;
        cnt = q.front().second;
        q.pop();

        // when arrive
        if (current_x == goal_x && current_y == goal_y) {
            return cnt;
        }

        for (int i = 0; i < 8; ++i) {
            int next_x = current_x + dx[i];
            int next_y = current_y + dy[i];
            // valid check
            if (next_x >= 0 && next_y >= 0 && next_x < l && next_y < l) {
                if (!board[next_x][next_y]) {
                    q.push({{next_x, next_y}, cnt + 1});
                    board[next_x][next_y] = true;
                }
            }
        }
    }
    return -1;
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    int tc;
    std::cin >> tc;
    for (int i = 0; i < tc; ++i) {
        // 테스트 케이스
        int l, x, y, gt, gy;
        std::cin >> l >> x >> y >> gt >> gy;
        std::vector<std::vector<bool> > board(l, std::vector<bool>(l, false));
        std::cout << bfs(board, x, y, gt, gy, l) << "\n";
    }
    return 0;
}
```


- - -

첫 그래프와 순회 골드 문제


7576 토마토 문제는 인접한 토마토에 대해 서로 익는 상황에서, 밭의 정보가 주어졌을 때 모든 토마토가 익는데에 걸리는 시간을 도출하는 알고리즘 문제였다.

일단, 시작점이 여러개라는게 지금까지의 문제와 달랐고 BFS를 모두 수행하고 마지막에 토마토가 다 익었는지 확인하는 로직을 추가해야 했다 (토마토가 비어있는 구간이 있으면 특정 토마토는 끝까지 익지 않을 수 있기에)

먼저, 시작점이 여러개인건 그냥 BFS 시작전에 queue에 시작점을 모두 넣고 돌리면 끝이었다.
처음엔, 불필요한 BFS를 막기 위해 매 순회마다 토마토의 상태를 체크(토마토가 다 익어있는지, 남은게 있는지) 해야한다고 생각했다. 하지만 이것보다 그냥 토마토가 다 익어도 남은 순회들을 돌리는게 훨씬 효율적이었다 (어차피, 방문 체크로 불필요한 순회는 거의 무시된다)

```cpp
// 백준: 토마토
// https://www.acmicpc.net/problem/7576
// 2024-01-25

#include <iostream>
#include <queue>
#include <utility>
#include <vector>

std::vector<std::vector<int> > matrix;
int M, N;

int dx[4] = {1, -1, 0, 0};
int dy[4] = {0, 0, 1, -1};

int bfs() {
    std::queue<std::pair<std::pair<int, int>, int> > q;

    // 토마토 초기값을 큐에 넣기
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < M; ++j) {
            if (matrix[i][j] == 1) {
                q.push({{j, i}, 0});
                matrix[i][j] = true;
            }
        }
    }
    int answer_time = 0;
    while (!q.empty()) {
        int current_x = q.front().first.first;
        int current_y = q.front().first.second;
        int time = q.front().second;
        q.pop();
        answer_time = time;

        for (int i = 0; i < 4; ++i) {
            int next_x = current_x + dx[i];
            int next_y = current_y + dy[i];
            // valid check
            if (next_x >= 0 && next_y >= 0 && next_x < M && next_y < N) {
                if (matrix[next_y][next_x] == 0) {
                    q.push({{next_x, next_y}, time + 1});
                    matrix[next_y][next_x] = 1;
                }
            }
        }
    }
    // 다 익었는지 체크
    bool temp = true;
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < M; ++j) {
            if (matrix[i][j] == 0) {
                return -1;
            }
        }
    }
    return answer_time;
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    std::cin >> M >> N;
    matrix.assign(N, std::vector<int>(M, 0));
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < M; ++j) {
            std::cin >> matrix[i][j];
        }
    }

    std::cout << bfs();
    return 0;
}
```



- - -

7569 토마토 - 3D문제는 이전 토마토 문제를 3차원 밭에서 풀어야하는 문제였다. 3차원 벡터를 선언하고 조작하는게 살짝 복잡할 수 있었지만 struct를 사용해서 노드를 구조화했고, 올바르게 풀어 나갔다.

그래프 문제가 술술 풀린다. DP는 꽤 어려웠었는데 그래프는 그래도 잘 하는 것 같아서 기분이 좋다.



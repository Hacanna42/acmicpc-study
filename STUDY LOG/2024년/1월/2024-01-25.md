# <span style="color:yellow">2024-01-25</span>

오늘은 BFS, DFS 심화 문제를 풀이할 예정이다.

# 오늘의 백준
```
1697 숨바꼭질(실버 1)
7562 나이트의 이동(실버 1)
7576 토마토(골드 5)
7569 토마토 - 3차원 버전(골드 5)
16928 뱀과 사다리 게임(골드 5)
2206 벽 부수고 이동하기(골드 3)
1707 이분 그래프(골드 4)
```


1697 문제는 정말 신기한 문제였다, BFS가 어떤 식으로 최단경로를 찾을 수 있는지 이해하게 되었다. BFS의 특성상 가장 가까운 노드를 먼저 순회하므로, BFS는 최단 경로를 찾는데에 특히 효과적인 알고리즘이다.

BFS는 각 노드를 방문할 때, 방문한 순서가 최단거리임을 항상 보장하므로 목표 노드에 도착한 경로를 추적하면 그것이 최단거리임을 알 수 있다.

처음엔 DP문제일거라고 생각했다, 최단거리를 구하는걸 어떻게 그래프와 순회로 풀 수 있는건지 고민했다. BFS에 이런 멋있는 점이 있었다니 ...


7562 문제는 체스 말이 목표 지점까지 가는 최단 거리를 보드 L\*L에서 구하는 BFS 문제였다.
BFS 이해가 완벽하게 된 것 같다. 문제를 술술 풀었고 한번에 통과했다. 

```cpp
// 백준: 나이트의 이동
// https://www.acmicpc.net/problem/7562
// 2024-01-25

#include <iostream>
#include <queue>
#include <utility>
#include <vector>

int dx[8] = {2, 2, 1, 1, -1, -1, -2, -2};
int dy[8] = {1, -1, 2, -2, 2, -2, 1, -1};

int bfs(std::vector<std::vector<bool> >& board, int x, int y, int goal_x,
        int goal_y, int& l) {
    std::queue<std::pair<std::pair<int, int>, int> > q;
    q.push({{x, y}, 0});
    board[x][y] = true;

    while (!q.empty()) {
        int current_x, current_y, cnt;
        current_x = q.front().first.first;
        current_y = q.front().first.second;
        cnt = q.front().second;
        q.pop();

        // when arrive
        if (current_x == goal_x && current_y == goal_y) {
            return cnt;
        }

        for (int i = 0; i < 8; ++i) {
            int next_x = current_x + dx[i];
            int next_y = current_y + dy[i];
            // valid check
            if (next_x >= 0 && next_y >= 0 && next_x < l && next_y < l) {
                if (!board[next_x][next_y]) {
                    q.push({{next_x, next_y}, cnt + 1});
                    board[next_x][next_y] = true;
                }
            }
        }
    }
    return -1;
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    int tc;
    std::cin >> tc;
    for (int i = 0; i < tc; ++i) {
        // 테스트 케이스
        int l, x, y, gt, gy;
        std::cin >> l >> x >> y >> gt >> gy;
        std::vector<std::vector<bool> > board(l, std::vector<bool>(l, false));
        std::cout << bfs(board, x, y, gt, gy, l) << "\n";
    }
    return 0;
}
```


- - -

첫 그래프와 순회 골드 문제

# <span style="color:yellow">2024-01-30</span>

오늘은 백준 단계: # 동적 계획법과 최단거리 역추적을 학습할 예정이다.
최단거리 역추적이란 말 그대로 최단 거리 문제를 해결한 후, 실제 경로를 추적하는 과정을 말한다.

아, 그리고 오늘 새벽에 업다운디펜스 봇을 만들었다.

# 오늘의 백준
```
12852 1로 만들기 2(실버 1)
14002 가장 긴 증가하는 부분 수열 4(골드 4)


번외 -
4673 셀프 넘버(실버 5)
```


12852 문제는 바텀업 DP 방식으로 dp\[i\] 를 i가 1이 되기 위한 최소 연산 횟수로 지정하고, 값을 채워 나가면 되는 문제였다.

특이한건, 경로를 추적하기 위해 아래와 같은 로직을 사용한다는 것.
```cpp
 while (N != 1) {
        std::cout << N << " ";
        if (N % 2 == 0 && dp[N] == dp[N / 2] + 1)
            N /= 2;
        else if (N % 3 == 0 && dp[N] == dp[N / 3] + 1)
            N /= 3;
        else
            N--;
    }
```

연산 가중치가 1씩 늘어나니까, memo가 1만큼 차이나는지 비교하면 무엇이 최선의 선택이었는지 확인할 수 있다.



- - -




- - - 

번외로 4673 셀프 넘버 문제를 풀었다.
오늘 만든 업다운 디펜스 봇을 테스트하기 위해 랜디를 돌렸고, 저 문제가 나왔다.
사실 살짝 당황했다. 문제가 잘 이해가 안돼서...
대충 각 자리수 + 자기자신을 더한 값들의 목록을 만들고, 1부터 10000까지 목록에 없는 수를 출력하면 되는 문제었다.

sstream으로 입력된 숫자를 자리수로 쪼개는 방식을 썼는데.. 사실 모듈러를 쓰면 되지 않았나 ..?


- - -



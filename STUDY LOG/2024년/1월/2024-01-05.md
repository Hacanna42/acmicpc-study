# <span style="color:yellow">2024-01-05</span>

어제 못 풀었던 24511: queuestack 문제를 마저 풀었다.
그렇게 어렵지 않은 문제지만, 문제의 핵심을 간파하지 못하면 풀지 못 할 문제였다.
queuestack에서 queue와 stack을 거치고 나서의 status에 집중하면 수월하게 풀 수 있었다.
stack 특성상 처음 들어온 자료는 절대 pop되지 않으니 이번 문제에서 stack은 신경 쓸 필요가 없었고, 고려하지 않아도 됐다. 그러면 남은것은 queue밖에 없는데, queue의 action을 보면 **'들어오는 자료는 .back에, 나가는 자료는 .front에'** 이다. 처음에는 queue의 액션을 std::vector<std::queue>로 담아 하나하나 시뮬레이션을 돌렸는데 시간 초과가 떴다. 이 문제의 핵심은 모든 queue를 하나로 합치고 들어오는 자료는 .back에, 나가는 자료는 .front에 넣는 것을 deque(double ended queue)로 구현하는 것이었다.

```cpp
// 백준: queuestack
// https://www.acmicpc.net/problem/24511
// 2024-01-05

#include <deque>
#include <iostream>
#include <queue>

int main() {
    std::queue<int> queue;
    std::deque<int> deque;
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    // 입력
    int N;
    std::cin >> N;
    for (int i = 0; i < N; ++i) {
        int is_q;
        std::cin >> is_q;
        if (is_q == 0) {
            queue.push(i);
        }
    }
    for (int i = 0; i < N; ++i) {
        int e;
        std::cin >> e;
        if (!queue.empty() && queue.front() == i) {
            deque.push_back(e);
            queue.pop();
        }
    }

    // Stack은 아무런 상태값도 변화하지 않기에 신경쓸 필요가 없다.
    // Queue를 거치면 자료를 삽입 후 원래 있던 자료를 꺼낸다.
    // 알고리즘
    int M;
    std::cin >> M;
    while (M--) {
        int insert;
        std::cin >> insert;
        deque.push_front(insert);
        std::cout << deque.back() << " ";
        deque.pop_back();
    }
    return 0;
}
```

백준을 풀면서 처음으로 제일 오래 고민했던 문제인 것 같다.



# 오늘의 백준
```level16-19
24511 queuestack(실버 3)

백준 레벨 19: 조합론
15439 베라의 패션(브론즈 4)
24723 녹색거탑(브론즈 4)
10872 팩토리얼(브론즈 5)
11050 이항 계수(브론즈 1)
1010 다리 놓기(실버 5)

백준 레벨 20: 심화
1037 약수(브론즈 1)
25192 인사성 밝은 곰곰이(실버 4)

```

11050 이항 계수 문제 덕분에 이항 계수에 대한 공식을 알게 되었다.
1010 문제는 11050과 동일한 로직의 문제였는데, 이항 계수가 각 다리를 교차하지 않게 놓는 선형적 계산과 똑같다는 것을 모르고 있었다. 사실 아직도 잘 이해가 안된다. 이건 따로 수학을 공부해야 할 것 같다..

1037 문제는 숫자 N의 진짜 약수가 모두 주어지면, 숫자 N을 반환하는 문제였는데.. 정말 간단하게 구현 가능한 문제였지만 이 로직을 위한 수학적 추론이 있어야 했다. 모든 진짜 약수는 N의 소인수 분해에서 나오기에 min과 max를 곱하면 N이라는 것.

25192는 중복 검사와 관련된 문제였는데 처음엔 unordered_map을 쓰다가 시간 초과를 받고 set을 써서 풀었다.

unordered_map은 최선일때 O(n)이고 set은 O(logn)인데.. 아마도 값이 너무 집합적이었기 때문에 unordered_map의 해시가 불안정했던 것 같다. 그리고 메모리를 아끼는 차원에서도 이런 간단한 연산에는 set이 유용하고 굳이 key - value로 bool을 저장할 필요가 없을 것 같다.


# <span style="color:yellow">2024-01-05</span>

어제 못 풀었던 24511: queuestack 문제를 마저 풀었다.
그렇게 어렵지 않은 문제지만, 문제의 핵심을 간파하지 못하면 풀지 못 할 문제였다.
queuestack에서 queue와 stack을 거치고 나서의 status에 집중하면 수월하게 풀 수 있었다.
stack 특성상 처음 들어온 자료는 절대 pop되지 않으니 이번 문제에서 stack은 신경 쓸 필요가 없었고, 고려하지 않아도 됐다. 그러면 남은것은 queue밖에 없는데, queue의 action을 보면 **'들어오는 자료는 .back에, 나가는 자료는 .front에'** 이다. 처음에는 queue의 액션을 std::vector<std::queue>로 담아 하나하나 시뮬레이션을 돌렸는데 시간 초과가 떴다. 이 문제의 핵심은 모든 queue를 하나로 합치고 들어오는 자료는 .back에, 나가는 자료는 .front에 넣는 것을 deque(double ended queue)로 구현하는 것이었다.

```cpp
// 백준: queuestack
// https://www.acmicpc.net/problem/24511
// 2024-01-05

#include <deque>
#include <iostream>
#include <queue>

int main() {
    std::queue<int> queue;
    std::deque<int> deque;
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    // 입력
    int N;
    std::cin >> N;
    for (int i = 0; i < N; ++i) {
        int is_q;
        std::cin >> is_q;
        if (is_q == 0) {
            queue.push(i);
        }
    }
    for (int i = 0; i < N; ++i) {
        int e;
        std::cin >> e;
        if (!queue.empty() && queue.front() == i) {
            deque.push_back(e);
            queue.pop();
        }
    }

    // Stack은 아무런 상태값도 변화하지 않기에 신경쓸 필요가 없다.
    // Queue를 거치면 자료를 삽입 후 원래 있던 자료를 꺼낸다.
    // 알고리즘
    int M;
    std::cin >> M;
    while (M--) {
        int insert;
        std::cin >> insert;
        deque.push_front(insert);
        std::cout << deque.back() << " ";
        deque.pop_back();
    }
    return 0;
}
```

백준을 풀면서 처음으로 제일 오래 고민했던 문제인 것 같다.



# 오늘의 백준
```level16-19
24511 queuestack(실버 3)

백준 레벨 19: 조합론
15439 베라의 패션(브론즈 4)
24723 녹색거탑(브론즈 4)
10872 팩토리얼(브론즈 5)
11050 이항 계수(브론즈 1)
1010 다리 놓기(실버 5)

백준 레벨 20: 심화
1037 약수(브론즈 1)
25192 인사성 밝은 곰곰이(실버 4)
```

11050 이항 계수 문제 덕분에 이항 계수에 대한 공식을 알게 되었다.
1010 문제는 11050과 동일한 로직의 문제였는데, 이항 계수가 각 다리를 교차하지 않게 놓는 선형적 계산과 똑같다는 것을 모르고 있었다. 사실 아직도 잘 이해가 안된다. 이건 따로 수학을 공부해야 할 것 같다..

1037 문제는 숫자 N의 진짜 약수가 모두 주어지면, 숫자 N을 반환하는 문제였는데.. 정말 간단하게 구현 가능한 문제였지만 이 로직을 위한 수학적 추론이 있어야 했다. 모든 진짜 약수는 N의 소인수 분해에서 나오기에 min과 max를 곱하면 N이라는 것.

25192는 중복 검사와 관련된 문제였는데 처음엔 unordered_map을 쓰다가 시간 초과를 받고 set을 써서 풀었다.

unordered_map은 최선일때 O(n)이고 set은 O(logn)인데.. 아마도 값이 너무 집합적이었기 때문에 unordered_map의 해시가 불안정했던 것 같다. 그리고 메모리를 아끼는 차원에서도 이런 간단한 연산에는 set이 유용하고 굳이 key - value로 bool을 저장할 필요가 없을 것 같다.


- - -

이렇게 백준 레벨 20: 심화 2 문제의 일부를 풀었고, Silver 1도 달성했다.
내일은 심화 2를 마저 풀고 재귀 파트를 들어갈 생각이다.
욕심일 수 있지만.. 내일 Gold 5를 찍으면 좋겠다 ㅎㅎ 
주말까지라도 ...


# 최종 평가
```ElonMusk
### 평가: 백준 queuestack 해결 및 심화 문제 풀이

#### 성취 및 활동:
1. **queuestack 문제 해결**: 큐와 스택의 특성을 잘 이해하고 문제를 해결하셨습니다. 이 과정에서 deque의 활용도 눈에 띕니다.
2. **조합론 및 심화 문제 해결**: 이항 계수, 약수와 관련된 문제를 해결하면서 수학적 개념과 알고리즘의 균형을 잘 유지하셨습니다.

#### 인상적인 부분:
- **문제 해결력**: queuestack 문제 해결 과정에서 자료구조의 특성을 깊게 이해하고, 문제의 핵심을 파악한 점이 인상적입니다.
- **수학적 개념의 활용**: 이항 계수, 최소공배수, 약수와 같은 수학적 개념을 알고리즘에 적용하면서, 문제 해결 능력을 보여주셨습니다.

#### 추천 및 고려사항:
- **재귀 알고리즘 학습**: 이제 재귀 알고리즘에 집중하면서, 알고리즘의 깊이를 더욱 넓힐 수 있을 것 같습니다.
- **Gold 레벨 도전**: Silver 1 달성을 축하드리며, Gold 레벨에 도전하는 것도 좋은 목표가 될 것 같습니다.

#### 종합 평가:
오늘의 학습은 자료구조와 알고리즘 문제 해결력, 그리고 수학적 개념의 활용에서 뛰어난 성과를 보여주셨습니다. queuestack 문제에 대한 해결 방식은 특히 인상적이며, 다양한 심화 문제들을 통해 알고리즘과 수학적 사고의 균형을 잘 맞추셨습니다.

#### 오늘의 점수: 100/100
- **자료구조 이해 및 적용**: 50/50
- **문제 해결력 및 창의성**: 50/50

#### 추가 조언:
- 재귀 알고리즘의 학습을 통해 알고리즘의 다양성을 더욱 풍부하게 만들어 보세요.
- Gold 레벨에 도전하며, 더욱 고급 알고리즘 문제에 도전하는 것도 좋은 발전 방향이 될 것입니다.
```


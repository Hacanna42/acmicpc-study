# <span style="color:yellow">2024-01-03</span>

- [x] Stable-Sort는 병합정렬이라는데 이것도 구현해봐야겠다. ✅ 2024-01-03
- [x] Vector, Pair, Map 구현 ✅ 2024-01-03
- [ ] [맵과 해쉬테이블 강의 시청](https://www.youtube.com/watch?v=ZBu_slSH5Sk)

트리에 대해서도 곧 배워야겠다(배우겠다) 라는 생각을 한다. 레드-블랙 트리는 처음 들어보네 ..

# 오늘의 백준
```level14
7785 회사에 있는 사람(실버 5)
```

std::map은 양방향 반복자이기 때문에 한단계씩의 증감연산자밖에 사용을 못한다는 알쓸팁을 알게됐다.
심지어, m.begin()--; 같은것도 안된다. 함수 호출의 결과로 나오는 임시적인 값이기 때문이다. 임시적인 값에 대해선 연산자를 수행할 수 없다.

대용량 출력을 할때 std::cin이나 std::cout로 하면 시간초과를 받을수도 있다.
이것보다 더 빠른 저수준 입출력의 cstdio STL의 printf, scanf를 쓰자.
이것보다 더 빠르게 하려면 puts와 fgets(gets는 deprecated)를 쓸 수 있지만, 이것까지는 무시해도 될 만큼 작은 차이이다.

std::vector와 std::pair에 대해 공부하던 중 template \<typename T\> 라는 구문을 처음 알게 됐다.
template은 C++에서 템플릿을 정의할 때 사용하고, 제네릭 프로그래밍을 가능하게 한다. 
이를 통해 다양한 타입에 대해 같은 코드를 정의할 수 있다.

```cpp
template <typename T> T add(T a, T b) { static_assert(std::is_arithmetic<T>::value, "T must be an arithmetic type"); return a + b; }
```

이런식으로 class를 만들 때, template과 typename으로 제네릭하게 입력을 받고, type_traits STL로 산술 타입만을 허용하도록 할 수 있다.

std::pair을 직접 구현하려면 아래와 같이 할 수 있다.
```cpp
template <typename T1, typename T2>
class Pair {
	public:
	T1 first;
	T2 second;
	Pair(T1 first, T2 second) : first(first), second(second) {}
};
```



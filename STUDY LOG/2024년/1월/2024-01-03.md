# <span style="color:yellow">2024-01-03</span>

- [x] Stable-Sort는 병합정렬이라는데 이것도 구현해봐야겠다. ✅ 2024-01-03
- [x] Vector, Pair, Map 구현 ✅ 2024-01-03
- [ ] [맵과 해쉬테이블 강의 시청](https://www.youtube.com/watch?v=ZBu_slSH5Sk)

트리에 대해서도 곧 배워야겠다(배우겠다) 라는 생각을 한다. 레드-블랙 트리는 처음 들어보네 ..

# 오늘의 백준
```level14
백준 레벨 14: 집합과 맵
7785 회사에 있는 사람(실버 5)
1620 나는야 포켓몬 마스터 이다솜(실버 4)
10816 숫자 카드2(실버 4)
1764 듣보잡(실버 4)
1269 대칭 차집합(실버 4)
11478 서로 다른 부분 문자열의 개수(실버 4)

백준 레벨 15: 약수, 배수와 소수 2
1934 최소공배수(브론즈 1)
13241 최소공배수(실버 5)
1735 분수 합(실버 3)
2485 가로수(실버 4)
4134 다음 소수(실버 4)
```

std::map은 양방향 반복자이기 때문에 한단계씩의 증감연산자밖에 사용을 못한다는 알쓸팁을 알게됐다.
심지어, m.begin()--; 같은것도 안된다. 함수 호출의 결과로 나오는 임시적인 값이기 때문이다. 임시적인 값에 대해선 연산자를 수행할 수 없다.

대용량 출력을 할때 std::cin이나 std::cout로 하면 시간초과를 받을수도 있다.
이것보다 더 빠른 저수준 입출력의 cstdio STL의 printf, scanf를 쓰자.
이것보다 더 빠르게 하려면 puts와 fgets(gets는 deprecated)를 쓸 수 있지만, 이것까지는 무시해도 될 만큼 작은 차이이다.

std::vector와 std::pair에 대해 공부하던 중 template \<typename T\> 라는 구문을 처음 알게 됐다.
template은 C++에서 템플릿을 정의할 때 사용하고, 제네릭 프로그래밍을 가능하게 한다. 
이를 통해 다양한 타입에 대해 같은 코드를 정의할 수 있다.

```cpp
template <typename T> T add(T a, T b) { static_assert(std::is_arithmetic<T>::value, "T must be an arithmetic type"); return a + b; }
```

이런식으로 class를 만들 때, template과 typename으로 제네릭하게 입력을 받고, type_traits STL로 산술 타입만을 허용하도록 할 수 있다.

std::pair을 직접 구현하려면 아래와 같이 할 수 있다.
```cpp
template <typename T1, typename T2>
class Pair {
	public:
	T1 first;
	T2 second;
	Pair(T1 first, T2 second) : first(first), second(second) {}
};
```


1269 문제를 풀며 STL container : set에 대해서 알게 되었다. set은 집합을 다루는데에 유용하고, vector는 중복 값 허용, 메모리상 일차적으로 나열하고 무작위적인 접근에 유용하다면, set은 고유한 요소를 관리하고, 빠른 조회 삽입 삭제가 필요할 때 유용하다.

algorithm STL의 std::set_difference나 set_union 함수가 많이 유용하다.
for문으로 직접 구현하고 싶었는데, 알고리즘의 효율이 떨어진다고 해서 그냥 STL을 사용했다. 직접 구현이 어려운 건 아니니까 굳이 바퀴를 재발명할 필요는 없지 싶다.

11478 문제는 주어진 문자열에서 가능한 모든 조합을 알아내고, set은 중복을 허용하지 않는다는 특성을 이용해 중복된 값을 unique만 남기는 문제다.

모든 조합을 알아내는 알고리즘을 작성하는데 std::string STL의 substr() 을 알게 되었다, 나는 인자로 오는 int형 두개가 begin과 end인 줄 알았는데 사실은 begin과 length 였다.


- - -

이로써 백준 레벨 14: 집합과 맵 풀이를 모두 완료하였다.

1934 최소공배수 문제를 풀면서 유클리드 알고리즘에 대해 알게 되었다.
이 알고리즘은 두 수간의 GCD(최대공약수)를 구하는 방법과, GCD를 통해 LCM(최소공배수)를 구하는 방법이다.
두 수 a, b에 모듈러 연산을 취하고 b가 0이 될때까지 a = b; b = 나머지; 로 처리하면 b = 0일때 a가 GCD이고. GCD에 대해 |a * b|  / gcd 로 LCM을 구할 수 있다.


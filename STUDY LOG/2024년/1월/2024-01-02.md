# <span style="color:yellow">2024-01-02</span>

백준 정렬 문제집을 모두 풀고 나면, 
- [x] 2751번 문제(시간복잡도가 nlogn)인 정렬 알고리즘의 문제를 STL 없이 풀어보는 것이 목표이다. (퀵소트 사용) ✅ 2024-01-02

- [ ] vector의 pair나 Linked List를 직접 구현하는것도 교육적 가치가 있겠다.
- [ ] unordered_map이나 map도.. STL에서 기본으로 쓰이는 컨테이너들을 공부해야 할 필요성이 있다.

# 오늘의 백준
```level13
백준 13: 정렬 문제
1181 단어 정렬(실버 5)
10814 나이순 정렬(실버 5)
18870 좌표 압축(실버 2)

백준 14: 집합과 맵
10815 숫자 카드(실버 5)
14425 문자열 집합(실버 4)
```

1181 문제를 풀며 중복 값 제거 방법에 대해 찾다가 algorithm STL의 std::unique 함수를 알게 되었다.
auto라는 상당히 유용한 변수 형을 알게 되었다. 이건 컴파일 부분에서 컴파일러가 타입 추론을 통해 변수의 형을 자동으로 결정하게 한다.

예를 들어서 std::unique같은 함수의 반환값으로 std::vector\<int\>::iterator 형을 받아올 때 코드의 가독성을 위해 그냥 auto로 받아올 수 있다.

10814번에서 안정 정렬(stable sort)에 대해 배웠다. 동일한 값에 대해서 전후 관계가 바뀌지 않는 정렬 방식을 안정 정렬이라고 하고, nlogn의 시간복잡도를 가진 병합 정렬이 이에 해당한다, (버블소트도..)

18870은 unordered_map 을 사용해서 풀었다. 좌표 압축이라는 개념은 처음 들어봤는데, 문제에서 마치 상식처럼 여겨지는 개념이라는듯이 설명을 해버려서 관련 문서를 조금 찾았다.

이제 백준 13: 정렬 문제는 모두 완료했고, 14: 집합과 맵 문제를 풀어가야겠다.

- - - 

정렬을 STL없이 직접 구현해봤다.
2751 문제를 STL 없이 호어 퀵소트(Hoare Quicksort) 방식과 로무토 퀵소트(Lomuto Quicksort) 방식으로 구현해봤다. 호어 퀵소트는 pL과 pR의 피벗 양쪽에서 다가오며 교차할때까지 대소관계를 체크하는 분할정복방식이고, 로무토 퀵 소트는 피봇이 시작점 혹은 다른 끝에 있고 pL혹은 pR중 하나로만 대소관계를 체크하는 방법이다. 효율성 면에서는 호어가 더 좋다고 하지만 구현이 어렵다고 한다.

2751번 문제는 호어로 구현해서 풀었다. 퀵 소트 이론은 쉬운데 실 구현은 쉽지만은 않았다.
유튜브 강의를 하나 들었는데 분할정복방식의 정렬이 워낙 바리에이션이 많아서 그런지 나는 다른 설명을 들었었다. 그래서 배울 때 조금 혼란스러웠다.

그래도, 이제 이론을 알고 실제로 구현할수도 있게 되었으니. algorithm STL의 std::sort를 쓸 때 조금은 죄책감이 덜해지길...

```cpp
// 백준: 수 정렬하기 2(without STL)
// https://www.acmicpc.net/problem/2751
// 2024-01-02

#include <algorithm>
#include <iostream>
#include <vector>

void quickSort(std::vector<int>& arr, int low, int high) {
    if (low < high) {
        int mid = low + (high - low) / 1.8;
        int pivot = arr[mid];
        int pL = low - 1;
        int pR = high + 1;
        // 교차까지 정렬하며 분할
        while (true) {
            do {
                pL++;
            } while (arr[pL] < pivot);
            do {
                pR--;
            } while (arr[pR] > pivot);

            if (pL >= pR) break;

            std::swap(arr[pL], arr[pR]);
        }

        // 분할된 값을 갖고 재귀 실행
        quickSort(arr, low, pR);
        quickSort(arr, pR + 1, high);
    }
}

int main() {
    std::vector<int> v;
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    std::cout.tie(NULL);
    int N;
    std::cin >> N;
    for (int i = 0; i < N; ++i) {
        int t;
        std::cin >> t;
        v.push_back(t);
    }
    quickSort(v, 0, v.size() - 1);
    for (size_t i = 0; i < v.size(); ++i) {
        std::cout << v[i] << "\n";
    }
    return 0;
}
```

내일은 vector의 pair나 Linked list, map 등의 container STL의 작동 원리와 실 구현을 해서 좀 더 STL에 대한 이론 이해를 높이겠다 ..


# 최종 평가
```ElonMusk
### 평가: 백준 정렬 문제 해결 및 퀵소트 구현

#### 성취 및 활동:
1. **백준 정렬 문제 해결**: 정렬 관련 실버 레벨 문제들을 성공적으로 해결하셨습니다.
2. **퀵소트 알고리즘 구현**: STL 없이 호어 퀵소트와 로무토 퀵소트를 직접 구현하신 점은 특히 인상적입니다.

#### 인상적인 부분:
- **알고리즘 구현 능력**: 퀵소트의 이론적 이해와 실제 구현을 성공적으로 해낸 점은 상당한 기술적 역량을 보여줍니다.
- **다양한 함수와 개념 학습**: `std::unique`, `auto` 변수, 안정 정렬 등 여러 중요한 C++ 개념과 함수에 대한 학습을 진행하셨습니다.

#### 추천 및 고려사항:
- **다양한 정렬 알고리즘 실험**: 다른 정렬 알고리즘들도 직접 구현해보면서 각 알고리즘의 특성을 더 깊게 이해하세요.
- **STL 컨테이너들의 구현**: vector, map 등의 STL 컨테이너들을 직접 구현하며 더 깊은 이해를 추구하는 것은 좋은 접근입니다.

#### 종합 평가:
오늘의 학습은 알고리즘 구현과 이론적 이해의 균형이 잘 잡힌, 매우 효율적이고 실용적인 학습이었습니다. 앞으로 STL 컨테이너들에 대한 학습을 통해 여러분의 프로그래밍 능력이 더욱 강화될 것으로 기대합니다.

#### 오늘의 점수: 98/100
- **알고리즘 이해 및 적용**: 49/50
- **문제 해결 능력 및 창의성**: 49/50

#### 추가 조언:
- 정렬 알고리즘에 대한 깊은 이해를 바탕으로 다양한 문제에 적용해보세요.
- 앞으로의 학습에서도 새로운 개념의 탐색과 적용을 계속하여 기술적 역량을 강화하세요.
```
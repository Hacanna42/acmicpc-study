# <span style="color:yellow">2024-01-02</span>

백준 정렬 문제집을 모두 풀고 나면, 
- [x] 2751번 문제(시간복잡도가 nlogn)인 정렬 알고리즘의 문제를 STL 없이 풀어보는 것이 목표이다. (퀵소트 사용) ✅ 2024-01-02

- [ ] vector의 pair나 Linked List를 직접 구현하는것도 교육적 가치가 있겠다.
- [ ] unordered_map이나 map도.. STL에서 기본으로 쓰이는 컨테이너들을 공부해야 할 필요성이 있다.

# 오늘의 백준
```level13
백준 13: 정렬 문제
1181 단어 정렬(실버 5)
10814 나이순 정렬(실버 5)
18870 좌표 압축(실버 2)

백준 14: 집합과 맵
10815 숫자 카드(실버 5)
14425 문자열 집합(실버 4)
```

1181 문제를 풀며 중복 값 제거 방법에 대해 찾다가 algorithm STL의 std::unique 함수를 알게 되었다.
auto라는 상당히 유용한 변수 형을 알게 되었다. 이건 컴파일 부분에서 컴파일러가 타입 추론을 통해 변수의 형을 자동으로 결정하게 한다.

예를 들어서 std::unique같은 함수의 반환값으로 std::vector\<int\>::iterator 형을 받아올 때 코드의 가독성을 위해 그냥 auto로 받아올 수 있다.

10814번에서 안정 정렬(stable sort)에 대해 배웠다. 동일한 값에 대해서 전후 관계가 바뀌지 않는 정렬 방식을 안정 정렬이라고 하고, nlogn의 시간복잡도를 가진 병합 정렬이 이에 해당한다, (버블소트도..)

18870은 unordered_map 을 사용해서 풀었다. 좌표 압축이라는 개념은 처음 들어봤는데, 문제에서 마치 상식처럼 여겨지는 개념이라는듯이 설명을 해버려서 관련 문서를 조금 찾았다.

이제 백준 13: 정렬 문제는 모두 완료했고, 14: 집합과 맵 문제를 풀어가야겠다.

- - - 

정렬을 STL없이 직접 구현해봤다.
2751 문제를 STL 없이 호어 퀵소트(Hoare Quicksort) 방식과 로무토 퀵소트(Lomuto Quicksort) 방식으로 구현해봤다. 호어 퀵소트는 pL과 pR의 피벗 양쪽에서 다가오며 교차할때까지 대소관계를 체크하는 분할정복방식이고, 로무토 퀵 소트는 피봇이 시작점 혹은 다른 끝에 있고 pL혹은 pR중 하나로만 대소관계를 체크하는 방법이다. 효율성 면에서는 호어가 더 좋다고 하지만 구현이 어렵다고 한다.

2751번 문제는 호어로 구현해서 풀었다. 퀵 소트 이론은 쉬운데 실 구현은 쉽지만은 않았다.
유튜브 강의를 하나 들었는데 분할정복방식의 정렬이 워낙 바리에이션이 많아서 그런지 나는 다른 설명을 들었었다. 그래서 배울 때 조금 혼란스러웠다.

그래도, 이제 이론을 알고 실제로 구현할수도 있게 되었으니. algorithm STL의 std::sort를 쓸 때 조금은 죄책감이 덜해지길...

```cpp
// 백준: 수 정렬하기 2(without STL)
// https://www.acmicpc.net/problem/2751
// 2024-01-02

#include <algorithm>
#include <iostream>
#include <vector>

void quickSort(std::vector<int>& arr, int low, int high) {
    if (low < high) {
        int mid = low + (high - low) / 1.8;
        int pivot = arr[mid];
        int pL = low - 1;
        int pR = high + 1;
        // 교차까지 정렬하며 분할
        while (true) {
            do {
                pL++;
            } while (arr[pL] < pivot);
            do {
                pR--;
            } while (arr[pR] > pivot);

            if (pL >= pR) break;

            std::swap(arr[pL], arr[pR]);
        }

        // 분할된 값을 갖고 재귀 실행
        quickSort(arr, low, pR);
        quickSort(arr, pR + 1, high);
    }
}

int main() {
    std::vector<int> v;
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    std::cout.tie(NULL);
    int N;
    std::cin >> N;
    for (int i = 0; i < N; ++i) {
        int t;
        std::cin >> t;
        v.push_back(t);
    }
    quickSort(v, 0, v.size() - 1);
    for (size_t i = 0; i < v.size(); ++i) {
        std::cout << v[i] << "\n";
    }
    return 0;
}
```

내일은 vector의 pair나 Linked list, map 등의 container STL의 작동 원리와 실 구현을 해서 좀 더 STL에 대한 이론 이해를 높이겠다 ..


# 최종 평가
```ElonMusk
You've reached the current usage cap for GPT-4, please try again after 12:05 AM.
```
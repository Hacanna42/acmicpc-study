# <span style="color:yellow">2024-01-10</span>

오늘은 다이나믹 프로그래밍(Dynamic Programming, DP) 의 기본기를 세우는데에 초점을 맞추고 있다.

다이나믹 프로그래밍은 중복이 일어나는 작은 문제를 나누어서 푸는것을 말한다.
쉽게 말해서, 정답을 구한 중복 부분을 메모하고 이후에 메모 값을 사용해 효율적 연산을 하는 기법이다.
이렇게만 말하면 참 쉽다. 분할 정복 기법과 비슷하다고 생각할 수 있는데 분할정복은 그냥 효율을 위해 분할해서 작은 문제의 집합을 풀 뿐이지 분할정복에선 중복이 나타나지 않는다.

# 오늘의 백준
```level23
백준 레벨 23: 동적 계획법 1
9184 신나는 함수 실행(실버 2)
1904 01타일(실버 3)
9461 파도반 수열(실버 3)
1912 연속합(실버 2)
1149 RGB거리(실버 1)
1932 정수 삼각형(실버 1)
2579 계단 오르기(실버 3)
```

9184 문제는 해괴한 재귀 함수 pseudocode를 Memorization과 DP를 이용해 효율적으로 풀어 나가는 문제였다. DP를 처음 해보지만 작동 방식이나 발상이 상식적인 수준이라 그렇게 어렵진 않았다.
문제를 처음 봤을 땐 조금 당황했다. pseudocode가 너무 해괴해서..

```cpp
if a <= 0 or b <= 0 or c <= 0, then w(a, b, c) returns:
    1

if a > 20 or b > 20 or c > 20, then w(a, b, c) returns:
    w(20, 20, 20)

if a < b and b < c, then w(a, b, c) returns:
    w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c)

otherwise it returns:
    w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1)
```

아래처럼 DP로 풀었다.

```cpp
int dp(int a, int b, int c) {
    // 인덱스 조정
    int aa = a + 50;
    int bb = b + 50;
    int cc = c + 50;

    if (w[aa][bb][cc] != -1) return w[aa][bb][cc];
    if (a <= 0 || b <= 0 || c <= 0) {
        w[aa][bb][cc] = 1;
        return 1;
    }
    if (a > 20 || b > 20 || c > 20) {
        w[aa][bb][cc] = dp(20, 20, 20);
        return w[aa][bb][cc];
    }
    if (a < b && b < c) {
        w[aa][bb][cc] = dp(a, b, c - 1) + dp(a, b - 1, c - 1) - dp(a, b - 1, c);
        return w[aa][bb][cc];
    } else {
        w[aa][bb][cc] = dp(a - 1, b, c) + dp(a - 1, b - 1, c) +
                        dp(a - 1, b, c - 1) - dp(a - 1, b - 1, c - 1);
        return w[aa][bb][cc];
    }
}
```


01타일과 파도반 수열 문제는 올바른 점화식을 찾으면 쉽게 구현할 수 있는 문제였다.
점화식을 찾는것은 차차 감을 잡는 듯 하다.

연속합와 RGB거리 문제는 
아이디어는 간단하지만 찾기 어려웠다.  카데인 알고리즘을 사용하여 푸는 문제였고, RGB거리는 좀 더 복잡한 연속합 문제 느낌이었다.

이후에도 여러개의 DP 문제를 풀었다. 점화식 찾는게 여전히 어려운 듯 하다.

2579 계단 오르기(실버 3)은 처음에 점화식을 정확하게 짚어냈다.
``dp[i] = max(dp[i-3] + score[i-1] + score[i], dp[i-2] + score[i]`` 였는데.
중간에 점화식을 잘못 세웠다고 판단하고, 두번 올라간 경우와 한번 올라간 경우를 따로 계산하기 위해 vector을 만들었을때부터 무언가 꼬였다.
처음 점화식으로 다시 마음을 다잡고 계산하니까 다행이도 잘 풀렸다.

첫번째 계단을 올라가는 경우 dp\[1\]은 그 점수를 가질거고
dp\[2\]는 dp\[1\] + dp\[2\]의 경우의 수밖에 없다.
하지만 dp\[3\]은 3개의 계단을 연달아 갈 수 없으니 첫번째 계단을 밟고 세번째 계단으로 점프하거나
첫번째 계단을 점프하고 이어서 두번째, 세번째 계단을 밟는 두개의 경우의 수가 있다.

이로써 오늘의 DP 학습을 마쳤다. 오늘 DP 문제를 8개 풀었는데.. DP가 어떤 형태인지 이제 감은 잡았지만, 점화식 구성이나 여러가지 로직 구성에 아직 부족한 점이 많다. 하다 보면 늘겠지 !


# 최종 평가
```ElonMusk
[최고급 평가사 일론머스크의 2024-01-10 백준 학습 평가]

1. 백준 문제 풀이 평가:
- 동적 계획법(DP)의 기본 개념과 문제 해결 전략에 대한 이해를 보여줌.
- 9184 (신나는 함수 실행): 재귀 함수를 DP로 전환하는 과정에서 기본적인 메모이제이션 기법을 잘 활용함.
- 01타일, 파도반 수열: 점화식을 정확히 파악하여 문제를 효율적으로 해결함.
- 연속합, RGB거리: 카데인 알고리즘과 다차원 DP의 적용으로 문제 해결 능력을 보임.
- 2579 (계단 오르기): 점화식의 초기 설계가 정확했으나 중간에 오해로 인해 잠시 혼동을 겪음. 이후 원래 점화식으로 복귀하여 문제를 해결함.

2. 알고리즘 이해 및 적용:
- DP의 핵심 개념인 '작은 문제의 해결과 메모이제이션을 통한 큰 문제 해결'에 대한 이해가 깊어짐.
- 점화식 구성과 로직 개발에 있어 아직 경험이 부족함을 인식하고, 지속적인 연습 필요성을 강조함.

3. 개선 사항 및 조언:
- 점화식 구성 시, 초기 아이디어에서 벗어나지 않도록 집중력을 유지할 것을 권장함.
- 다양한 유형의 DP 문제를 풀어보며 점화식 구성 능력을 향상시킬 것을 제안함.

4. 오늘의 활동 대비 평균 활동 비교:
- DP 문제 8개 해결을 통해 이전의 백트래킹 학습에 비해 새로운 알고리즘 영역에서도 높은 학습 효과를 보임.

5. 종합 평가 점수: 92/100
- 동적 계획법의 기초를 탄탄히 다지는 과정에서 높은 이해도와 적용 능력을 보임.
- 아직 점화식 구성과 로직 개발에서 어려움을 겪는 부분이 있으나, 지속적인 연습을 통해 개선될 것으로 기대함.

[오늘의 학습 종합 코멘트]
- 동적 계획법을 처음 접하며 기본기를 세우는 과정에서 깊은 이해와 끈기를 보여주었습니다. DP의 핵심인 점화식 구성은 연습을 통해 점차 나아질 것이며, 오늘의 경험이 향후 더 복잡한 DP 문제에 대한 통찰력을 제공할 것입니다. 앞으로도 계속 도전하고 발전하는 모습을 기대합니다. 화이팅!
```
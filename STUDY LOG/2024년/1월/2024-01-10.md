# <span style="color:yellow">2024-01-10</span>

오늘은 다이나믹 프로그래밍(Dynamic Programming, DP) 의 기본기를 세우는데에 초점을 맞추고 있다.

다이나믹 프로그래밍은 중복이 일어나는 작은 문제를 나누어서 푸는것을 말한다.
쉽게 말해서, 정답을 구한 중복 부분을 메모하고 이후에 메모 값을 사용해 효율적 연산을 하는 기법이다.
이렇게만 말하면 참 쉽다. 분할 정복 기법과 비슷하다고 생각할 수 있는데 분할정복은 그냥 효율을 위해 분할해서 작은 문제의 집합을 풀 뿐이지 분할정복에선 중복이 나타나지 않는다.

# 오늘의 백준
```level23
백준 레벨 23: 동적 계획법 1
9184 신나는 함수 실행(실버 2)
1904 01타일(실버 3)
9461 파도반 수열(실버 3)
1912 연속합(실버 2)
1149 RGB거리(실버 1)
```

9184 문제는 해괴한 재귀 함수 pseudocode를 Memorization과 DP를 이용해 효율적으로 풀어 나가는 문제였다. DP를 처음 해보지만 작동 방식이나 발상이 상식적인 수준이라 그렇게 어렵진 않았다.
문제를 처음 봤을 땐 조금 당황했다. pseudocode가 너무 해괴해서..

```cpp
if a <= 0 or b <= 0 or c <= 0, then w(a, b, c) returns:
    1

if a > 20 or b > 20 or c > 20, then w(a, b, c) returns:
    w(20, 20, 20)

if a < b and b < c, then w(a, b, c) returns:
    w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c)

otherwise it returns:
    w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1)
```

아래처럼 DP로 풀었다.

```cpp
int dp(int a, int b, int c) {
    // 인덱스 조정
    int aa = a + 50;
    int bb = b + 50;
    int cc = c + 50;

    if (w[aa][bb][cc] != -1) return w[aa][bb][cc];
    if (a <= 0 || b <= 0 || c <= 0) {
        w[aa][bb][cc] = 1;
        return 1;
    }
    if (a > 20 || b > 20 || c > 20) {
        w[aa][bb][cc] = dp(20, 20, 20);
        return w[aa][bb][cc];
    }
    if (a < b && b < c) {
        w[aa][bb][cc] = dp(a, b, c - 1) + dp(a, b - 1, c - 1) - dp(a, b - 1, c);
        return w[aa][bb][cc];
    } else {
        w[aa][bb][cc] = dp(a - 1, b, c) + dp(a - 1, b - 1, c) +
                        dp(a - 1, b, c - 1) - dp(a - 1, b - 1, c - 1);
        return w[aa][bb][cc];
    }
}
```


01타일과 파도반 수열 문제는 올바른 점화식을 찾으면 쉽게 구현할 수 있는 문제였다.
점화식을 찾는것은 차차 감을 잡는 듯 하다.

연속합와 RGB거리 문제는 
아이디어는 간단하지만 찾기 어려웠다.  카데인 알고리즘을 사용하여 푸는 문제였고, RGB거리는 좀 더 복잡한 연속합 문제 느낌이었다.

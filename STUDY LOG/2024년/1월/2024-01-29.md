# <span style="color:yellow">2024-01-29</span>

오늘은 투 포인터를 배우겠다. 투 포인터 알고리즘은 말 그대로 두개의 포인터(실제로 \*라서 포인터가 아니라 인덱스를 가리킨다는 의미에서 포인터 인듯) 를 사용해서 효율적으로 문제를 해결하는 테크닉을 말하는 듯 한다.

# 오늘의 백준
```
3273 두수의 합(실버 3)
2470 두 용액(골드 5)
1806 부분합(골드 4)
1644 소수의 연속합(골드 3)
1450 냅색문제(골드 1)
```

3273 두수의 합 문제는 정말 간단한 투 포인터 문제였다. 뭔가 이분탐색이나 퀵 소트에서 사용되는 방식과 비슷한 느낌으로, 그냥 말 그대로 두개의 포인터를 사용하면서 범위를 줄이면서 값을 찾아나가는 문제였다. 코드를 보면 바로 무슨 느낌인지 이해된다.

```cpp
// 백준: 두 수의 합
// https://www.acmicpc.net/problem/3273
// 2024-01-29

#include <algorithm>
#include <iostream>
#include <vector>

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    int n, x;
    std::cin >> n;
    std::vector<int> v(n, 0);
    for (int i = 0; i < n; ++i) {
        std::cin >> v[i];
    }
    std::cin >> x;

    std::sort(v.begin(), v.end());

    int count = 0;
    int start = 0, end = n - 1;
    while (start < end) {
        int sum = v[start] + v[end];
        if (sum == x) {
            count++;
            start++;
        } else if (sum < x)
            start++;
        else
            end--;
    }

    std::cout << count;
    return 0;
}
```



 - - -
2470 두 용액 문제는 용액 두개를 합쳐 0에 가까운 용액 쌍을 구하는 문제였고, 위의 문제와 비슷한 맥락의 문제였다.
두개의 포인터를 만들고, 조건에 맞춰 증감하면서 가장 0에 가까운 조합을 찾으면 되는 간단한 문제였다.
이 문제는 실버 2~3이 적당한 것 같은데... 골드 5다

```cpp
// 백준: 두 용액
// https://www.acmicpc.net/problem/2470
// 2024-01-29

#include <limits.h>

#include <algorithm>
#include <cmath>
#include <iostream>
#include <utility>
#include <vector>

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    int N;
    std::cin >> N;
    std::vector<int> v(N, 0);
    for (int i = 0; i < N; ++i) {
        std::cin >> v[i];
    }

    std::sort(v.begin(), v.end());

    long min = LONG_MAX;
    std::pair<int, int> answer;
    int start = 0, end = N - 1;
    long abs_sum;
    while (start < end) {
        abs_sum = std::abs(v[start] + v[end]);
        if (abs_sum == 0) {
            answer = {v[start], v[end]};
            break;
        }
        if (abs_sum < min) {
            min = abs_sum;
            answer = {v[start], v[end]};
        }
        if (v[start] + v[end] > 0) {
            end--;
        } else if (v[start] + v[end] < 0) {
            start++;
        }
    }

    std::cout << answer.first << " " << answer.second;
    return 0;
}
```

- - -

1806 부분합 문제는 조금 더 조건이 복잡한 투 포인터 문제였다. 부분 수열에서 가장 길이가 짧지만 S보다 큰 수열의 길이를 찾는 문제로, 구현은 쉬웠지만 효율적으로 구현하기 위해선 **슬라이딩 윈도우**라는 테크닉을 사용해야 한다.

예를 들어서 아래의 코드는 다음과 같은 문제가 있다:
```cpp
int length = INT_MAX;
int start = 0, end = 0;
while (start < N) {
    int current_sum = 0;
    for (int i = start; i <= end; ++i) {
        current_sum += v[i];
    }

    if (current_sum >= S) {
        int current_length = end - start + 1;
        if (current_length < length) length = current_length;
        start++;
        end = start;
    } else if (current_sum < S) {
        if (end == N - 1) {
            start++;
            end = start;
        } else
            end++;
    }
}
```

매번의 반복마다 start와 end 사이의 부분합을 다시 계산하고 있다. 이 알고리즘은 불필요한 중복 계산을 일으켜 비효율적이다.

따라서. 아래와 같이 슬라이딩 윈도우할 수 있다.
방법은 간단하다. 어차피 start을 고정시키고 end를 늘리면서 부분합을 찾는거니까, 조건이 달성되면 start++; 를 하고, 누적합에서 v\[start\] 를 빼면 된다.

```cpp
int length = INT_MAX, sum = 0;
int start = 0, end = 0;

    while (end <= N) {
        if (sum >= S) { // S 이상인 수열 찾으면
            length = std::min(length, end - start);
            sum -= v[start++]; // 누적합에서 첫번째 부분 빼기
        } else {
            if (end == N) break;
            sum += v[end++]; // 수열의 크기가 S 이하면, 누적합에 뒷부분 하나 더하기
        }
    }
```

심플하고도 효율적인 방법이다.

여기서 주의할점이 하나 있는데, while문이 인덱스 끝의 다음 부분까지 가리키게 설정해야 하는 것이다.
``sum >= S`` 체크가 반복의 시작부분에서 이루어지기에, 만약 while문이 딱 인덱스의 마지막까지만 순회하게 하면 마지막에 업데이트 되는 sum을 체크하지 못할 수 있다.

따라서, 인덱스의 다음 부분까지 가리키게 만들고, 다음 반복문에서 ``sum >= S`` 체크를 한 뒤 ``if (end == N) break;`` 를 해야한다.


- - -

1644 소수의 연속합 문제도 슬라이딩 윈도우와 투 포인터 알고리즘을 이용해서 해결할 수 있었다.
뭔가 투 포인터에 재능 있는 것 같다.. 분명 골드 3 문제인데 꽤 무난하게 풀었다.

예전에 배웠던 에라토스테네스의 체를 구현해서 1부터 400만까지의 소수를 구하고, (처음에 205만까지 구했었다, 왜냐하면 두 수의 합이 400만을 넘지 않으려면 두 수가 200만 이하여야 하니까. 하지만 부분합이라는게 자기 자신(혼자)를 포함하는 것임을 간과했다. 소수 그 자체에 대해서 존재하는 부분합의 개수가 하나라는 사실을 간과했다. 그래서 다시 400만으로 바꿨다)

그리고, 슬라이딩 윈도우 하면서 굳이 while문이 끝 인덱스의 다음 부분까지 가리키도록 구현하지 않았다.
애초에 소수를 405만까지 널널하게 구해놨기 때문.

투 포인터도 직관적인 알고리즘 같다.


```cpp
// 백준: 소수의 연속합
// https://www.acmicpc.net/problem/1644
// 2024-01-29

/* 예전에 배웠던 에라토스테네스의 체를 이용해서 소수를 구하자.
하나 이상의 연속합이기에, 소수 그 자체도 1로 된다는 것을 간과했다. :( */

#define LIMIT 4000500

#include <iostream>
#include <vector>

bool prime[LIMIT];
std::vector<int> primes;

void eratosthenes() {
    for (int p = 2; p * p <= LIMIT; ++p) {
        if (!prime[p]) {
            for (int i = p * p; i <= LIMIT; i += p) {
                prime[i] = true;
            }
        }
    }

    for (int i = 2; i <= LIMIT; ++i) {
        if (!prime[i]) primes.push_back(i);
    }
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    eratosthenes();
    // for (int i = 0; i < primes.size(); ++i) {
    //     std::cout << primes[i] << " ";
    // }
    int N;
    std::cin >> N;

    int start = 0, end = 0;
    int current_sum = 0;
    int count = 0;

    // 어차피 primes 배열이 널널하게 잡혀있어서, 굳이 끝 인덱스의 다음 부분까지
    // 순회를 안 돌려도 될듯.

    while (end < primes.size()) {
        // 연속된 소수 조합 발견
        if (current_sum == N) {
            count++;
            current_sum -= primes[start++];
        }
        // 소수의 합이 목표보다 작다면
        else if (current_sum < N) {
            // if (end == primes.size()) break;
            current_sum += primes[end++];
        }
        // 소수의 합이 목표보다 크다면
        else if (current_sum > N) {
            current_sum -= primes[start++];
        }
    }

    std::cout << count;
    return 0;
}
```


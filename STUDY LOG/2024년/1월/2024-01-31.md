# <span style="color:yellow">2024-01-31</span>

오늘은 1월의 마지막 날. 어제 못 했던 동적 계획법과 최단거리 역추적을 학습할 예정이다.

어제 최단거리 역추적 한문제를 풀었는데, ``12852 1로 만들기 2(실버 1)`` 는 가능한 3개의 연산이 주어지고, 연산을 사용해 X를 1로 만드는 최단거리를 구하는 문제다.

먼저, dp를 이용해 최소 연산 횟수를 구할 수 있었다.
```cpp
void calculate_dp(int N) {
    for (int i = 2; i <= N; ++i) {
        dp[i] = dp[i - 1] + 1;
        if (i % 2 == 0) dp[i] = std::min(dp[i], dp[i / 2] + 1);
        if (i % 3 == 0) dp[i] = std::min(dp[i], dp[i / 3] + 1);
    }
}
```

그리고, 아래와 같이 현재 dp의 값에서 가능한 3가지 연산으로써 얻어지는 dp의 값을 비교하고, 연산 가중치가 1이므로 이전dp+1이 현재dp와 같다면, 현재dp의 최선의 선택은 이전dp라고 확신할 수 있음을 확인했다.

ps. 역추적 과정에서, dp\[N\]의 값이 dp\[N/2\]+1 또는 dp\[N/3\]+1과 같다는 건, 해당 부분이 최소 연산 횟수로 1에 도달하는데에 기여했다는 것을 의미한다.

```cpp
void print_path(int N) {
    while (N != 1) {
        std::cout << N << " ";
        if (N % 2 == 0 && dp[N] == dp[N / 2] + 1)
            N /= 2;
        else if (N % 3 == 0 && dp[N] == dp[N / 3] + 1)
            N /= 3;
        else
            N--;
    }
    std::cout << "1";
}
```



# 오늘의 백준
```
14002 가장 긴 증가하는 부분 수열 4(골드 4)
14003 가장 긴 증가하는 부분 수열 5(플래티넘 5)
```

그리고, 오늘은 그 다음 문제 ``14002 가장 긴 증가하는 부분 수열 4`` 를 풀 차례이다.
이 문제는 LIS(최장 증가 부분 수열)을 구하고, 그 수열을 출력해야하는 문제다.
즉, LIS를 역추적 해야한다.

먼저, LIS를 구현하는 방법은 두가지가 있음을 배웠다. 그냥 dp로 구하는 O(N^2)의 방법과, 이진탐색을 이용한 O(NlogN)의 방법이다

```cpp
    std::vector<int> lis;
    for (const int num : arr) {
        int index = upper_bound(lis, num);
        if (index == lis.size()) {
            lis.push_back(num);
        } else {
            lis[index] = num;
        }
    }
```

upper_bound로 값을 더 작은 값으로 대체하는 이유가 설마 더 작은값으로 해당 위치를 교체하는게 더 많은 수열의 가능성을 만들어내기 때문인가??? 라는 생각이 들어서 GPT한테 물어보니까 정확하다고 한다. 기분이 좋군.

## 역대급 삽질
자, 이전 단계에서 실수를 했다, 바로 이진 탐색으로 LIS를 구하려면 upper_bound가 아니라 lower_bound를 사용해야 한다. lower_bound는 '이상', upper_bound는 '초과' 인데.... 실수를 했다. lower_bound가 당연히 맞다.

지금까지 upper_bound로 구현하고 있었다. 그래서 LIS가 잘못 출력됐다.

그리고 백트래킹(역추적)은 정말 어려웠다. 레퍼런스를 찾아봐도 사람들마다 조금씩 해법이 달랐다. AI한테 물어보니까 막 lastIndex 배열로 현재 배열의 실제 값을 추적하고,, prevIndex로 경로를 따라가고.. 이렇게 복잡하게 구현하던데.

그냥 역추적하기 위해, 업데이트 되는 LIS 배열의 인덱스 값을 계속 backtrace 배열에 쌓아주는 것으로 충분했다.

```cpp
std::vector<int> lis;
    std::vector<int>
        backtrace;  // 역추적하기 위해서, 각 lis의 인덱스 값을 쌓아주기
    std::vector<int> answer;
    for (int i = 0; i < N; ++i) {
        int num = arr[i];
        int index = lower_bound(lis, num);
        if (index == lis.size()) {
            lis.push_back(num);
            backtrace.push_back(lis.size() - 1);
        } else {
            lis[index] = num;
            backtrace.push_back(index);
        }
    }
```

주어진 수열에 대해 반복문을 돌리면서, lis 배열의 최상단 값보다 크면 lis배열의 맨 뒤에 값을 넣고, backtrace 배열에 인덱스를 쌓는다.

만약, 최상단 값보다 크지 않으면 그 값 **이상**이 처음 나오는 인덱스를 현재 num과 대체한다. 이는 LIS의 길이를 최대화 하는데에 중요한 요소이고, 현재 원소가 이전 원소들과 같은 값을 가질 수 있는 최소 위치를 찾음으로써 최소 가능성을 유지할 수 있다. 만약 upper_bound를 사용하면 같은 값을 가진 원소가 있을 경우 그 다음 위치를 선택하게 됨으로써, 더 긴 수열의 가능성을 놓칠 수 있다. **따라서 제발 lower_bound를 사용해야 한다.**

LIS 배열의 정리가 끝나면, backtrace 배열에 저장된 인덱스를 가지고 역추적한다.

```cpp
int temp = lis.size() - 1;
    for (int i = backtrace.size() - 1; i >= 0; --i) {
        if (backtrace[i] == temp) {
            answer.push_back(arr[i]);
            --temp;
        }
    }

    std::sort(answer.begin(), answer.end());

    std::cout << answer.size() << "\n";
    for (int i = 0; i < answer.size(); ++i) {
        std::cout << answer[i] << " ";
    }
```

lis.size()는 실제 LIS 수열의 길이를 나타내므로, LIS를 재구성할 때의 길이는 lis.size()와 같을 것이다. 그리고, backtrace 배열에 저장된 인덱스들은 실제 주어진 수열의 인덱스 정보를 갖고 있으므로, lis.size()-1부터 차례대로 값을 조회해서 answer 배열의 넣은 값이 실제 LIS를 재구성한 값이 될 것이다.

answer에 저장된 값은 역순으로 되어있을 것이다. 즉, 내림차순으로 되어있을 것이다.
따라서 std::reverse나 std::sort를 사용하면 된다.
std::sort는 평균적으로 O(NlogN), std::reverse는 O(n)이므로 std::reverse를 사용하는게 더 좋을 것 같아서 추후에 수정했다.


LIS 역추적은 다른 고수분들도 많이 헷갈려 하는 부분이라고 한다. 확실히 로직이 매우 복잡하고 이해하기 어렵다.
이 문제를 거의 4~5시간동안 잡았다.

그래도, 결국엔 이해하고 풀어서 다행이다. 나중에 또 이 문제를 보게 되면 그때는 덜 삽질하길.


- - -

재밌는건, 14003 문제가 14002 문제를 O(NlogN) 방식으로 푸는 문제였다.
나는 14002 문제에서 이미 제일 효율적인 알고리즘을 강구해서 풀었기에 (그래서 골드 4인데 개 어렵게 느껴졌다)
14003 문제도 자연스럽게 동일 코드로 풀렸다. 오예 ㅎㅎ

14002 문제는 DP를 이용해서 O(N^2)의 방식으로, 14003 문제는 이진탐색을 이용해서 O(NlogN)으로 역추적 하는 문제였다..


- - -

PS 공부는 여기서 마치고, 그 이후에는``디스코드 봇: 업다운 PS 디펜스``를 업데이트 했다.
일주일 초과해서 플레이 하지 않은 골드 이상 유저에 대해, 하루에 레이팅이 1씩 차감되도록 했다.

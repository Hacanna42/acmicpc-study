# <span style="color:yellow">2024-01-31</span>

오늘은 1월의 마지막 날. 어제 못 했던 동적 계획법과 최단거리 역추적을 학습할 예정이다.

어제 최단거리 역추적 한문제를 풀었는데, ``12852 1로 만들기 2(실버 1)`` 는 가능한 3개의 연산이 주어지고, 연산을 사용해 X를 1로 만드는 최단거리를 구하는 문제다.

먼저, dp를 이용해 최소 연산 횟수를 구할 수 있었다.
```cpp
void calculate_dp(int N) {
    for (int i = 2; i <= N; ++i) {
        dp[i] = dp[i - 1] + 1;
        if (i % 2 == 0) dp[i] = std::min(dp[i], dp[i / 2] + 1);
        if (i % 3 == 0) dp[i] = std::min(dp[i], dp[i / 3] + 1);
    }
}
```

그리고, 아래와 같이 현재 dp의 값에서 가능한 3가지 연산으로써 얻어지는 dp의 값을 비교하고, 연산 가중치가 1이므로 이전dp+1이 현재dp와 같다면, 현재dp의 최선의 선택은 이전dp라고 확신할 수 있음을 확인했다.

ps. 역추적 과정에서, dp\[N\]의 값이 dp\[N/2\]+1 또는 dp\[N/3\]+1과 같다는 건, 해당 부분이 최소 연산 횟수로 1에 도달하는데에 기여했다는 것을 의미한다.

```cpp
void print_path(int N) {
    while (N != 1) {
        std::cout << N << " ";
        if (N % 2 == 0 && dp[N] == dp[N / 2] + 1)
            N /= 2;
        else if (N % 3 == 0 && dp[N] == dp[N / 3] + 1)
            N /= 3;
        else
            N--;
    }
    std::cout << "1";
}
```


그리고, 오늘은 그 다음 문제 ``14002 가장 긴 증가하는 부분 수열 4`` 를 풀 차례이다.
이 문제는 LIS(최장 증가 부분 수열)을 구하고, 그 수열을 출력해야하는 문제다.
즉, LIS를 역추적 해야한다.

먼저,
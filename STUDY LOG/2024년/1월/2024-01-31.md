# <span style="color:yellow">2024-01-31</span>

오늘은 1월의 마지막 날. 어제 못 했던 동적 계획법과 최단거리 역추적을 학습할 예정이다.

어제 최단거리 역추적 한문제를 풀었는데, ``12852 1로 만들기 2(실버 1)`` 는 가능한 3개의 연산이 주어지고, 연산을 사용해 X를 1로 만드는 최단거리를 구하는 문제다.

먼저, dp를 이용해 최소 연산 횟수를 구할 수 있었다.
```cpp
void calculate_dp(int N) {
    for (int i = 2; i <= N; ++i) {
        dp[i] = dp[i - 1] + 1;
        if (i % 2 == 0) dp[i] = std::min(dp[i], dp[i / 2] + 1);
        if (i % 3 == 0) dp[i] = std::min(dp[i], dp[i / 3] + 1);
    }
}
```

그리고, 아래와 같이 현재 dp의 값에서 가능한 3가지 연산으로써 얻어지는 dp의 값을 비교하고, 연산 가중치가 1이므로 이전dp+1이 현재dp와 같다면, 현재dp의 최선의 선택은 이전dp라고 확신할 수 있음을 확인했다.

ps. 역추적 과정에서, dp\[N\]의 값이 dp\[N/2\]+1 또는 dp\[N/3\]+1과 같다는 건, 해당 부분이 최소 연산 횟수로 1에 도달하는데에 기여했다는 것을 의미한다.

```cpp
void print_path(int N) {
    while (N != 1) {
        std::cout << N << " ";
        if (N % 2 == 0 && dp[N] == dp[N / 2] + 1)
            N /= 2;
        else if (N % 3 == 0 && dp[N] == dp[N / 3] + 1)
            N /= 3;
        else
            N--;
    }
    std::cout << "1";
}
```



# 오늘의 백준
```
14002 가장 긴 증가하는 부분 수열 4(골드 4)
14003 가장 긴 증가하는 부분 수열 5(플래티넘 5)
```

그리고, 오늘은 그 다음 문제 ``14002 가장 긴 증가하는 부분 수열 4`` 를 풀 차례이다.
이 문제는 LIS(최장 증가 부분 수열)을 구하고, 그 수열을 출력해야하는 문제다.
즉, LIS를 역추적 해야한다.

먼저, LIS를 구현하는 방법은 두가지가 있음을 배웠다. 그냥 dp로 구하는 O(N^2)의 방법과, 이진탐색을 이용한 O(NlogN)의 방법이다

```cpp
    std::vector<int> lis;
    for (const int num : arr) {
        int index = upper_bound(lis, num);
        if (index == lis.size()) {
            lis.push_back(num);
        } else {
            lis[index] = num;
        }
    }
```

upper_bound로 값을 더 작은 값으로 대체하는 이유가 설마 더 작은값으로 해당 위치를 교체하는게 더 많은 수열의 가능성을 만들어내기 때문인가??? 라는 생각이 들어서 GPT한테 물어보니까 정확하다고 한다. 기분이 좋군.

## 역대급 삽질
자, 이전 단계에서 실수를 했다, 바로 이진 탐색으로 LIS를 구하려면 upper_bound가 아니라 lower_bound를 사용해야 한다. lower_bound는 '이상', upper_bound는 '초과' 인데.... 실수를 했다. lower_bound가 당연히 맞다.

지금까지 upper_bound로 구현하고 있었다. 그래서 LIS가 잘못 출력됐다.

그리고 백트래킹(역추적)은 정말 어려웠다. 레퍼런스를 찾아봐도 사람들마다 조금씩 해법이 달랐다. AI한테 물어보니까 막 lastIndex 배열로 현재 배열의 실제 값을 추적하고,, prevIndex로 경로를 따라가고.. 이렇게 복잡하게 구현하던데.

그냥 역추적하기 위해, 업데이트 되는 LIS 배열의 인덱스 값을 계속 backtrace 배열에 쌓아주는 것으로 충분했다.

```cpp
std::vector<int> lis;
    std::vector<int>
        backtrace;  // 역추적하기 위해서, 각 lis의 인덱스 값을 쌓아주기
    std::vector<int> answer;
    for (int i = 0; i < N; ++i) {
        int num = arr[i];
        int index = lower_bound(lis, num);
        if (index == lis.size()) {
            lis.push_back(num);
            backtrace.push_back(lis.size() - 1);
        } else {
            lis[index] = num;
            backtrace.push_back(index);
        }
    }
```

주어진 수열에 대해 반복문을 돌리면서, lis 배열의 최상단 값보다 크면 lis배열의 맨 뒤에 값을 넣고, backtrace 배열에 인덱스를 쌓는다.

만약, 최상단 값보다 크지 않으면 그 값 **이상**이 처음 나오는 인덱스를 현재 num과 대체한다. 이는 LIS의 길이를 최대화 하는데에 중요한 요소이고, 현재 원소가 이전 원소들과 같은 값을 가질 수 있는 최소 위치를 찾음으로써 최소 가능성을 유지할 수 있다. 만약 upper_bound를 사용하면 같은 값을 가진 원소가 있을 경우 그 다음 위치를 선택하게 됨으로써, 더 긴 수열의 가능성을 놓칠 수 있다. **따라서 제발 lower_bound를 사용해야 한다.**

LIS 배열의 정리가 끝나면, backtrace 배열에 저장된 인덱스를 가지고 역추적한다.

```cpp
int temp = lis.size() - 1;
    for (int i = backtrace.size() - 1; i >= 0; --i) {
        if (backtrace[i] == temp) {
            answer.push_back(arr[i]);
            --temp;
        }
    }

    std::sort(answer.begin(), answer.end());

    std::cout << answer.size() << "\n";
    for (int i = 0; i < answer.size(); ++i) {
        std::cout << answer[i] << " ";
    }
```

lis.size()는 실제 LIS 수열의 길이를 나타내므로, LIS를 재구성할 때의 길이는 lis.size()와 같을 것이다. 그리고, backtrace 배열에 저장된 인덱스들은 실제 주어진 수열의 인덱스 정보를 갖고 있으므로, lis.size()-1부터 차례대로 값을 조회해서 answer 배열의 넣은 값이 실제 LIS를 재구성한 값이 될 것이다.

answer에 저장된 값은 역순으로 되어있을 것이다. 즉, 내림차순으로 되어있을 것이다.
따라서 std::reverse나 std::sort를 사용하면 된다.
std::sort는 평균적으로 O(NlogN), std::reverse는 O(n)이므로 std::reverse를 사용하는게 더 좋을 것 같아서 추후에 수정했다.


LIS 역추적은 다른 고수분들도 많이 헷갈려 하는 부분이라고 한다. 확실히 로직이 매우 복잡하고 이해하기 어렵다.
이 문제를 거의 4~5시간동안 잡았다.

그래도, 결국엔 이해하고 풀어서 다행이다. 나중에 또 이 문제를 보게 되면 그때는 덜 삽질하길.


- - -

재밌는건, 14003 문제가 14002 문제를 O(NlogN) 방식으로 푸는 문제였다.
나는 14002 문제에서 이미 제일 효율적인 알고리즘을 강구해서 풀었기에 (그래서 골드 4인데 개 어렵게 느껴졌다)
14003 문제도 자연스럽게 동일 코드로 풀렸다. 오예 ㅎㅎ

14002 문제는 DP를 이용해서 O(N^2)의 방식으로, 14003 문제는 이진탐색을 이용해서 O(NlogN)으로 역추적 하는 문제였다..


- - -

PS 공부는 여기서 마치고, 그 이후에는``디스코드 봇: 업다운 PS 디펜스``를 업데이트 했다.
일주일 초과해서 플레이 하지 않은 골드 이상 유저에 대해, 하루에 레이팅이 1씩 차감되도록 했다.

사람들이 디펜스 봇을 그래도 잘 써줘서 뿌듯하다 !

내일은 최단거리 역추적의 나머지 문제  (9252, 2618, 13913, 9019, 11779, 11780)를 풀겠다.
LCS도 나온다..

# 최종 평가
```ElonMusk
최고급 평가사 일론머스크의 분석 및 평가:

오늘의 학습 내용:
- 동적 계획법과 최단거리 역추적에 대한 깊은 이해와 적용
- 백준 문제 12852 (1로 만들기 2) 및 14002, 14003 (가장 긴 증가하는 부분 수열 4, 5) 성공적 해결
- 업다운 PS 디펜스 디스코드 봇 업데이트

평가 요약:
1. 알고리즘 적용 능력: 동적 계획법과 최단거리 역추적에 대한 뛰어난 이해를 바탕으로 복잡한 문제를 해결한 점이 인상적입니다.
2. 최적화 기법 활용: 이진 탐색을 활용한 O(NlogN) LIS 구현 및 역추적 방법은 효율적인 문제 해결 능력을 보여줍니다.
3. 창의적인 프로젝트 개발: 업다운 PS 디펜스 디스코드 봇 개발과 업데이트를 통해 프로그래밍 능력과 창의력을 입증했습니다.

종합적인 평가:
- 기술적 정확성: 30/30
- 창의적 문제 해결: 30/30
- 학습 및 개발 능력: 30/30
- 추가 학습 및 개선점: 20/20

총점: 100/100

추가 조언:
- 문제 해결 과정에서 발생한 실수와 그 해결 방법에 대한 깊은 성찰은 앞으로의 학습에 큰 도움이 될 것입니다.
- 동적 계획법과 최단거리 역추적을 더 다양한 문제에 적용해보며 능력을 확장시켜 보세요.
- 개발한 디스코드 봇을 통해 실제 사용자의 피드백을 받으며 지속적으로 개선해나가는 경험은 소프트웨어 개발자로서의 성장에 중요합니다.
- 내일 도전할 최단거리 역추적 문제들을 통해 얻는 인사이트와 경험은 여러분의 알고리즘 이해도를 한층 더 높일 것입니다.

오늘의 학습과 개발 활동은 알고리즘 능력뿐만 아니라 실제 프로젝트를 기획하고 구현하는 능력까지 종합적으로 보여주었습니다. 지속적인 학습과 도전을 통해 더욱 발전하는 모습을 기대합니다.
``
# <span style="color:yellow">2024-01-22</span>

오늘은 백준 레벨 30: 스택을 풀겠다. 이제 백준의 단계별 풀어보기도 몇 단계 남지 않았다.
나머지 레벨들을 마치고, 실랜디(실버 랜덤 디펜스)를 먼저 시작해볼 예정이다.

스택 다음으론 DFS와 BFS를 좀 더 깊게 배우고(예전에 백트래킹 할 때 약간 맛만 봤다) 그 다음으론 최단경로 알고리즘, 투 포인터, 최단거리 역추적, 트리, 유니온파인드.. 를 끝내겠다.

#### 아무리 늦어도 위 과정을 2월 10일까지는 끝내고 싶다.
사실, 지금 내가 하는 단계별 풀이는 **여러가지 개념의 복합적인 이해** 같은것이고 실질적인 코딩 테스트 연습은 아니다. 그래도 나는 기본기를 매우 중요시 생각해서 실랜디를 하기 전에 레벨을 모두 깨고 시작하고 싶었다.

그래서 기본기 탄탄하게 깔겠다고 PS도 C++로 시작하고, STL도 처음엔 안쓰고 vector, string, pair, sort 이런거 직접 만들어서 쓰고 (내가 구현하지 못하는, 혹은 어떤 원리로 동작하는지 자세하기 알지 못하는 STL을 쓰는것에 왠지 모를 죄책감을 느꼈다) 이러면서 지금까지 베이스는 잘 깔아왔다고 생각한다.


# 오늘의 백준
```
17298 오큰수(골드 4)
17299 오등큰수(골드 3)
1725 히스토그램(플래티넘 5) *
3015 오아시스 재결합(플래티넘 5)
```

17298 오큰수 문제를 처음에는 deque를 이용해서 풀었다, front부터 pop 하면서 temp에 pop 값을 저장하고, 조건을 검사하면서 검사가 끝나면 pop한 값을 다시 push 했다. 이게 복사 비용보다 훨씬 덜 드니까..
근데 이것보다 더 최적화 할 수 있는 방법이 있었다.
바로 스택의 특성을 사용한 천재적인 방법이다.
히스토그램이랑 좀 비슷한 식인데, index 0부터 차례대로 stack에 넣으면서, 현재 원소가 top보다 작으면 그 원소의 오큰수는 top이 되는 방식이다. 
이걸 왜 생각 못했을까.. 한 수 더 배우고 간다..




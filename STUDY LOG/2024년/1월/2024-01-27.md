# <span style="color:yellow">2024-01-27</span>

# 오늘의 백준
```
13549 숨바꼭질 3(골드 5)
9370 미확인 도착지(골드 2)
11657 타임머신(골드 4)
11404 플로이드(골드 4)
1956 운동(골드 4)
```


13549 숨바꼭질 문제는 걷기와 순간이동 방식이 있고, 목표 지점까지 도달하는 최단거리를 구하는 문제인데.
며칠전에 그래프와 순회 단계에서 풀었던 숨바꼭질 문제와 거의 비슷했지만, 이전 문제에선 걷기나 순간이동이나 가중치가 1로 동일해서 그냥 BFS를 사용해서 풀었지만, 이번 문제는 가중치가 2개 (0과 1로) 순간이동을 사용하는쪽이 효율적이어서 좀 더 공격적인 순간이동을 하도록 알고리즘을 작성해야 했다.

다익스트라 알고리즘으로도 풀 수 있다는데 일단은 0-1 BFS 알고리즘을 사용했다.

0-1 BFS 알고리즘은 오늘 배운 테크닉인데, BFS와 거의 동일하지만 queue가 아니라 deque를 사용하고, 우선적으로 특정 가중치를 고려하고 싶을 때 사용할 수 있다.
Idea는 아주 간단한데, 그저 가중치가 0인것은 (이득) front에 push하고. 가중치가 1인 것은(손해) back에 푸시하면 된다.

- - -

9370 문제는 컨셉이 재밌는 문제였다. 근데,, 꽤 어렵고 복잡한 문제였다.
일단 문제의 컨셉은, 아래와 같다.

```9370
(취익)B100 요원, 요란한 옷차림을 한 서커스 예술가 한 쌍이 한 도시의 거리들을 이동하고 있다. 너의 임무는 그들이 어디로 가고 있는지 알아내는 것이다. 우리가 알아낸 것은 그들이 s지점에서 출발했다는 것, 그리고 목적지 후보들 중 하나가 그들의 목적지라는 것이다. 그들이 급한 상황이기 때문에 목적지까지 우회하지 않고 최단거리로 갈 것이라 확신한다. 이상이다. (취익)

어휴! (요란한 옷차림을 했을지도 모를) 듀오가 어디에도 보이지 않는다. 다행히도 당신은 후각이 개만큼 뛰어나다. 이 후각으로 그들이 g와 h 교차로 사이에 있는 도로를 지나갔다는 것을 알아냈다.

이 듀오는 대체 어디로 가고 있는 것일까?
```

그니까, 서커스 듀오가 목적지로 최단거리로 이동하는데, 특정 거리로 지나가는 것을 확인한 내가. 후보 목적지 중 어디로 가는 건지 알아맞혀야 하는 문제다.

문제에 ``이 도로는 목적지 후보들 중 적어도 1개로 향하는 최단 경로의 일부이다.`` 가 정의되어 있고, ``입력에서 주어진 목적지 후보들 중 불가능한 경우들을 제외한 목적지들을 공백으로 분리시킨 오름차순의 정수들로 출력한다.`` 가 문제의 요구 사항이기 때문에, 아래와 같이 생각할 수 있다.

1. 출발지부터 각 후보 목적지까지의 최단거리를 다익스트라로 구한다.
2. 경유지 g, h에 대해 경유하는 최단거리를 구한다. (출발 -> g -> h -> 도착) 순으로 구하면 된다(혹은 반대)
3. 만약 경유지를 거치는 최단 거리가, 각 목적지까지의 최단 거리와 일치하면 그 경유지를 꼭 거치지 않았다고 해도 거쳤을 가능성이 있다.
4. 목적지 후보들 중 적어도 1개로 향하는 최단 경로의 일부이므로 만약 경유지를 거친 최단 거리가 그냥 출발지에서 각 후보 목적지로 간 최단 경로와 일치하지 않으면 그 후보 목적지는 듀오의 실제 목적지가 될 가능성이 없다.

라는 사고 과정을 거쳐서 코드를 짰다.
일단, dijkstra() 함수를 어떻게 디자인 해야할 지 고민을 했다.
결론적으로 내가 구현한 방법은 dijkstra(int start, int end)로 start에서 end까지의 최단거리를 반환하는 함수를 작성하고
각 경로에 대해 + 연산을 하면서 값을 구하려고 했다(이때는 이게 제일 깔끔하다고 생각했다)

물론 완벽하게 최적화하기 위해서 처음 시작점에서 각 모든 정점까지의 최단 거리를 dist\[\]에 넣어놓고, 거기서 얻어낸 정보로 start -> g와 start -> h까지의 거리를 구하고 그 뒤로부터 다시 dijkstra(int start, int end) 로 각 경로에 대한 최단 거리를 구할 수도 있었다.

하지만 이렇게 하면 코드가 더러워질 것 이라고 생각했다. 일단 위의 방법으로 하면 dijkstra 함수가 범용적으로 쓰이도록 디자인하기 너무 힘들것이라고 생각했기 때문이다.

따라서, 최적화를 조금 포기하더라도 (시간 제한이 3초인 문제였다)
dijkstra(int start, int end) 로 구성해서 각 경로마다 호출하는 것이 좀 더 코딩하고 편하다고 판단해서 그렇게 했다.

다행히도 TLE를 받지는 않았고. 약 2시간정도 풀고 첫 제출에 AC를 받았다...

정말 복잡한 문제였지만, 지금까지 배운 내용들을 정리할 수 있는 좋은 문제였다. 아주 재밌는 문제였다. (여러 의미로)

- - -


# <span style="color:yellow">2024-01-18</span>

오늘은 컨디션이 괜찮다. 요즘 생활 패턴이 너무 꼬였고, 매일 이른 오전까지 잠을 안자서 ... 건강이 악화된 것 같은 기분을 느낀다. 건강에 신경을 좀 더 써야겠다 :(

오늘은 ``백준 단계별 풀이 29레벨: 동적 계획법 2`` 를 풀 예정이다. 지금까지 배운 알고리즘중 DP가 그래도 재밌는 편에 속했던 것 같다 (점화식을 도출했을 때 기분이 좋다)

이번 레벨은 상당히 복잡하고 점화식을 도출해내기 힘든 DP 문제들이 모아져있다. 

# 오늘의 백준
```
11066 파일 합치기(골드 3)

```

11066 파일 합치기 문제는 점화식이 그렇게 어렵진 않았다. 근데 한가지 이슈가 있었는데.. 지문에선 파일 합치는게 서로 인접한 파일끼리 가능하다는 것을 말해주지 않았다. 이것을 Common sense의 영역으로 남겨두었다. 지금 알고리즘 로직이 챕터별로 오름차순 정리된 페이지들을 정리하는 것이기 때문에, 병합을 하더라도 서로 인접한 파일끼리만 병합을 해야만 순서가 유지 되기 때문에,, 결국엔 인접한 파일끼리만 합칠 수 있다는 것을 간접적으로 시사하고 있었다.

```cpp
    for (int len = 2; len <= size; ++len) {
        for (int start = 0; start <= size - len; ++start) {
            int end = start + len - 1;
            for (int k = start; k < end; ++k) {
                long cost = memo[start][k] + memo[k + 1][end] +
                            prefix[end + 1] - prefix[start];
                memo[start][end] = min(memo[start][end], cost);
            }
        }
    }
```

len은 부분 집합의 길이를 지정하고, start는 시작 인덱스, end는 끝 인덱스를 가리킨다. k는 start와 end 사이에서 움직이면서, 가능한 모든 조합에 대해 최소값을 구한다.
```solution
dp[i][j] = i ~ j 범위의 최소 비용
A = [1, 2, 3, 4] 라고 할 때, (편의상 시작 인덱스: 1로 가정)
dp[1][2], dp[2][3], dp[3][4] 는 단순히 각 value를 서로 더한 값.

dp[1][3]의 경우 2가지가 존재:
cost[1] + dp[2][3] 혹은 dp[1][2] + cost[3]

dp[1][4]의 경우 3가지가 존재:
cost[1] + dp[2][4] 혹은 dp[1][3] + cost[4] 혹은 dp[1][2] + dp[3][4]

만약, A에 5번째 요소도 있다면
dp[1][5]의 경우에는 4가지가 존재(j-1 만큼 경우의 수 존재)
1. dp[2][5] + 합(1부터 5까지의 파일 크기)
2. dp[1][2] + dp[3][5] + 합(1부터 5까지의 파일 크기)
3. dp[1][3] + dp[4][5] + 합(1부터 5까지의 파일 크기)
4. dp[1][4] + 합(1부터 5까지의 파일 크기)

이런 방식으로 각 경우의 최소 비용을 계산하면 된다.
```


이 복잡한 점화식을 3중 포문으로 구현하는것도 힘들뿐더러, 구현이 복잡하기에 본인이 가진 점화식에 확신이 없으면 멘탈도 많이 흔들리는 문제였다.



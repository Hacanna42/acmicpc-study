# <span style="color:yellow">2024-01-18</span>

오늘은 컨디션이 괜찮다. 요즘 생활 패턴이 너무 꼬였고, 매일 이른 오전까지 잠을 안자서 ... 건강이 악화된 것 같은 기분을 느낀다. 건강에 신경을 좀 더 써야겠다 :(

오늘은 ``백준 단계별 풀이 29레벨: 동적 계획법 2`` 를 풀 예정이다. 지금까지 배운 알고리즘중 DP가 그래도 재밌는 편에 속했던 것 같다 (점화식을 도출했을 때 기분이 좋다)

이번 레벨은 상당히 복잡하고 점화식을 도출해내기 힘든 DP 문제들이 모아져있다. 

# 오늘의 백준
```
11066 파일 합치기(골드 3)
11049 행렬 곱셈 순서(골드 3)
1520 내리막 길(골드 3)
```

11066 파일 합치기 문제는 점화식이 그렇게 어렵진 않았다. 근데 한가지 이슈가 있었는데.. 지문에선 파일 합치는게 서로 인접한 파일끼리 가능하다는 것을 말해주지 않았다. 이것을 Common sense의 영역으로 남겨두었다. 지금 알고리즘 로직이 챕터별로 오름차순 정리된 페이지들을 정리하는 것이기 때문에, 병합을 하더라도 서로 인접한 파일끼리만 병합을 해야만 순서가 유지 되기 때문에,, 결국엔 인접한 파일끼리만 합칠 수 있다는 것을 간접적으로 시사하고 있었다.


```cpp
    for (int len = 2; len <= size; ++len) {
        for (int start = 0; start <= size - len; ++start) {
            int end = start + len - 1;
            for (int k = start; k < end; ++k) {
                long cost = memo[start][k] + memo[k + 1][end] +
                            prefix[end + 1] - prefix[start];
                memo[start][end] = min(memo[start][end], cost);
            }
        }
    }
```

len은 부분 집합의 길이를 지정하고, start는 시작 인덱스, end는 끝 인덱스를 가리킨다. k는 start와 end 사이에서 움직이면서, 가능한 모든 조합에 대해 최소값을 구한다.

```solution
dp[i][j] = i ~ j 범위의 최소 비용
A = [1, 2, 3, 4] 라고 할 때, (편의상 시작 인덱스: 1로 가정)
dp[1][2], dp[2][3], dp[3][4] 는 단순히 각 value를 서로 더한 값.

dp[1][3]의 경우 2가지가 존재:
cost[1] + dp[2][3] 혹은 dp[1][2] + cost[3]

dp[1][4]의 경우 3가지가 존재:
cost[1] + dp[2][4] 혹은 dp[1][3] + cost[4] 혹은 dp[1][2] + dp[3][4]

만약, A에 5번째 요소도 있다면
dp[1][5]의 경우에는 4가지가 존재(j-1 만큼 경우의 수 존재)
1. dp[2][5] + 합(1부터 5까지의 파일 크기)
2. dp[1][2] + dp[3][5] + 합(1부터 5까지의 파일 크기)
3. dp[1][3] + dp[4][5] + 합(1부터 5까지의 파일 크기)
4. dp[1][4] + 합(1부터 5까지의 파일 크기)

이런 방식으로 각 경우의 최소 비용을 계산하면 된다.
```


이 복잡한 점화식을 3중 포문으로 구현하는것도 힘들뿐더러, 구현이 복잡하기에 본인이 가진 점화식에 확신이 없으면 멘탈도 많이 흔들리는 문제였다.



- - -

11049 행렬 곱셈 순서 문제는 푸는데 자그마치 **3시간**이 걸렸다.
R\*C 크기의 행렬 N개가 주어졌을 때, 행렬의 곱셈 연산 수를 최소로 하는 계산 순서의 값을 알아내는 문제였다.
포인트는 항상 순서대로 곱셈을 할 수 있는 크기만 입력으로 주어지고, 순서를 바꿀 수 없다는 것이다.
이 말인 즉슨 서로 인접한 행렬끼리만 곱할 수 있다는 것이고.
``dp[i][j] 를 i 행렬부터 j행렬까지의 최소곱 횟수라고 했을 때, 가장 작은 범위에서부터 시작해서 가능한 모든 분기점 k에 대해 최소값을 구하면서 답을 구해나가면 된다.``

여기서 포인트는 분기점 k이다. 분기점 k는 범위가 주어졌을 때 그 범위 안에서 가능한 모든 분기점에 대한 계산을 위해 쓰이는 가장 내부 반복문을 말한다.

이 k를 어떻게 조합해서, 모든 입력에 대해 적절한 연산을 처리할 지 구상하는게 너무 힘들었다. 이것이 시간을 잡아먹은 제일 큰 이유이다.

머리로는 점화식을 다 이해했는데 코드로는 구상할 수 없는 상태였다.
``dp[1][3] 은 dp[1][2] + 나머지 하나 | dp[2][3] + 나머지 하나`` 인 것을 알지만 이걸 어떻게 깔끔하게 구현할 지 모르는 상황이다.

결국에 가장 중요한 Key-Point는. 분기점 k 반복문을 start ~ end 에서 반복하게 만들고, 각 k에 대해 분할해서 cost를 구하도록 하는것이다. 이게 처음엔 와닿지 않는데, 하다 보니까 어느정도 와닿기 시작한다.
애초에 이해하기 힘든 식일뿐더러 인간 친화적이지도 않는 듯... 결국엔
``dp[i][k] + dp[k+1][j]`` 이런식으로 모든 분기점 k에 대해 k이전과 k이후로 나누어서 최소값을 계산할 수 있고. 이 뒤에 ``+ cost(i, k, j)  <- i부터 k행렬을 곱한 연산횟수 * k+1부터 j 행렬을 곱한 연산횟수``
를 붙여서 Memoization을 업데이트 하면 된다.

따라서 정답은..
```answer
int cost = memo_count[start][k] + memo_count[k + 1][end] + matrix[start].first * matrix[k].second * matrix[end].second;
memo_count[start][end] = min(cost, memo_count[start][end]);
```

이다.

정말 어려운 문제였고, DP에 대한 심화적인 이해를 할 수 있는 문제였다.
이 문제를 자력으로 풀 수 있었으니, 지금 상황이라면 11066문제도 어렵지 않게 풀 수 있을 것 같다.
기억하자. DP에서 이런 상황에 대한 식이 명확하지 않으면 분할점 k에 대해 계산한다고 생각해야 한다.
**k이전과 k이후로 나누어서 값을 더하자**

### 행렬 곱셈 문제에 대한 선생님의 한마디:

```ElonMusk
문제 해결 과정과 핵심 포인트에 대한 정리가 매우 잘 되어 있습니다. "행렬 곱셈 순서" 문제를 이해하고 해결하는 과정에서 동적 프로그래밍의 중요한 개념인 '최적 부분 구조'와 '중복되는 부분 문제'를 잘 파악하고 계십니다. 분할 지점 k를 사용하는 방식은 이 문제의 핵심이며, 이를 통해 가능한 모든 행렬 곱셈 조합의 최소 비용을 효과적으로 계산할 수 있습니다.

점화식 dp[i][k] + dp[k+1][j] + cost(i, k, j)는 행렬 곱셈 순서 문제를 해결하는 데 있어서 매우 중요한 부분입니다. 이 식은 주어진 범위 내에서 모든 가능한 분할 지점 k에 대해 최소 비용을 계산하고, 이들 중 최소값을 찾아 memo_count[start][end]를 업데이트하는 데 사용됩니다.

또한, 이 문제를 해결함으로써 동적 프로그래밍에 대한 깊은 이해를 얻으셨다는 점이 인상적입니다. 이러한 경험은 향후 더 복잡한 동적 프로그래밍 문제를 해결하는 데 큰 도움이 될 것입니다.

11066 문제와 같은 다른 동적 프로그래밍 문제에 대해서도 이러한 접근 방법과 이해를 적용하면 좋은 결과를 얻을 수 있을 것으로 보입니다.

마지막으로, 알고리즘 문제를 해결할 때 정해진 '식'이나 '패턴'에 얽매이지 않고, 문제의 본질을 이해하고 창의적으로 접근하는 것이 중요하다는 점을 기억하시길 바랍니다. 동적 프로그래밍 문제, 특히 이러한 심화 문제를 해결하는 과정에서는 다양한 시도와 실패를 통해 깊은 이해를 얻을 수 있습니다.
```



1520 내리막 길 문제는 저번 문제에 비해 쉬운 문제였다. 
보통 DP 문제는 점화식을 어떻게 도출하고, 어떤식으로 녹여내는지가 어려운 부분인데 이번 문제는 점화식이 필요가 없는 Memoization만 이용하는 문제였다. DFS를 사용해서 브루트포스로 구현할 수도 있지만, 시간복잡도 초과로 Memoization을 사용하면서 ``dp[i][j] = c``를 좌표 (i, j) 에서 목적지까지 도달할 수 있는 경로의 수로 보고, (0, 0) 부터 시작해서 DFS로 브루트포스를 구현하고 이미 지나간 경로라면 여기서부터의 가능한 경로의 수가 결국에 그 수가 되니까, 그냥 메모해둔걸 이용하면 되는 문제였다.
하나 걸렸던 건 좌표 이동 관련해서 아래처럼 처리하는 걸 생각하는데에 조금 막혔던 것 같다. 이외에는 쉬웠다.
```cpp
int dx[] = {1, -1, 0, 0};
int dy[] = {0, 0, 1, -1};
~
~
~
// 가능한 4개의 경로 모두 탐색
    for (int i = 0; i < 4; ++i) {
        int nx = X + dx[i];
        int ny = Y + dy[i];
        if (nx >= 0 && ny >= 0 && nx < N && ny < M) {
            if (map[ny][nx] < map[Y][X]) {
                DP[Y][X] += dfs(ny, nx);
            }
        }
    }
```



오늘은 이렇게 DP 심화 문제 3문제를 풀었다.
6시간정도 공부했는데, 평균 2시간에 한문제면 꽤 느린 편이지만 그래도 얻는 게 많았다.
어제보다 성장한 기분을 확실하게 느낀다.
내일은 나머지 DP 문제를 풀겠다.

끝 !


# 최종 평가
```ElonMusk
일자: 2024-01-18
평가사: 최고급 평가사 일론머스크
평가 대상: 사용자의 학습 내용 및 진도

학습 내용:
1. 백준 단계별 풀이 29레벨: 동적 계획법 2
   - 문제 #11066 (파일 합치기), #11049 (행렬 곱셈 순서), #1520 (내리막 길)

진도 분석:
- 동적 계획법에 대한 심화적인 접근과 문제 해결 능력을 보여줌.
- 문제 #11066과 #11049의 해결은 DP의 복잡한 점화식 이해와 적용 능력을 나타냄.
- 문제 #1520 해결은 Memoization 기법에 대한 이해를 보여줌.

핵심 개념 평가:
1. 문제 #11066 (파일 합치기) - 점화식 도출 및 최적화 문제에 대한 이해를 보여줌. 인접한 파일 합치기에 대한 올바른 가정과 접근 방법을 사용했습니다.
2. 문제 #11049 (행렬 곱셈 순서) - 행렬 곱셈의 최소 연산 횟수를 찾는 복잡한 문제 해결. 중복되는 부분 문제와 최적 부분 구조의 개념을 잘 적용했습니다.
3. 문제 #1520 (내리막 길) - DFS와 Memoization을 이용한 경로 탐색 문제 해결. 재귀 호출과 메모리 제한을 효율적으로 관리했습니다.

향후 학습 방향:
- 동적 계획법의 점화식 도출과 최적화에 계속 집중할 필요가 있습니다.
- 다양한 형태의 DP 문제를 해결함으로써 문제에 대한 유연한 접근과 창의적인 해결 방법을 개발하는 것이 중요합니다.

점수: 93/100
- 점수 산정 근거: 고난도 동적 계획법 문제에 대한 해결 능력과 복잡한 점화식 이해를 높이 평가하나, 일부 문제에 대한 접근에서 시간이 다소 소요된 점을 감안하여 일부 감점함.

오늘의 학습에서는 동적 계획법에 대한 심화적인 이해와 적용 능력이 돋보였습니다. 문제 #11066과 #11049를 해결하는 과정에서 복잡한 점화식을 잘 이해하고 적용한 점은 매우 인상적입니다. 문제 #1520의 해결은 DFS와 Memoization을 효율적으로 활용한 좋은 예시입니다. 이러한 경험은 향후 더 복잡한 동적 계획법 문제를 해결하는 데 큰 도움이 될 것입니다. 지금처럼 다양한 도전을 계속하면서, 동적 계획법에 대한 깊은 이해를 계속 발전시켜 나가시기 바랍니다. 또한, 건강 관리에도 주의를 기울이시며 학습을 이어가시길 바랍니다.
```
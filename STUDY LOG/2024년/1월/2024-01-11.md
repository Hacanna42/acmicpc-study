# <span style="color:yellow">2024-01-11</span>

오늘은 DP, 점화식 공부에 중점을 둘 것이다.

# 오늘의 백준
```level23
1463 1로 만들기(실버 3)
10844 쉬운 계단 수(실버 1)
```

1463 1로 만들기 문제는 주어진 숫자 n에 대해서 3가지의 연산이 있고. 이 연산을 k번 반복해서 1로 만드는 최적의 해를 찾는 문제였다.
이번 문제는 사실상 DP를 풀며 처음으로 점화식을 구성하는데에 차질이 없었다.
dp\[i\] = i를 1로 만들기 위한 최선의 연산 횟수라고 가정하면
``dp[i] = min(dp[i/3], dp[i/2], dp[i-1]) + 1;`` 이라고 정의할 수 있었다.
이때, i에 따라서 3혹은 2로 나누어 떨어지지 않을 수 있으니 i에 따라서 점화식을 일부 조정하면 쉽게 해결할 수 있었다.

10884 쉬운 계단 수 문제는 처음에 점화식을 각 자리수에 대해 ``dp[i]`` 로 설정하고 식을 세웠는데, 각 자리수의 경계조건에 따라 변화하는 값의 규칙을 공식화하는것이 불가능해 보여서 각 자리수의 끝자리를 n이라고 할 때
``dp[i][n]``으로 설정하고 ``dp[i][n] = dp[i-1][n-1] + dp[i-1][n+1]``로 올바르게 설정했다.
구현과 점화식은 올바르게 작성했는데 오버플로우를 관리하지 못해서 문제를 틀렸다.
모듈러 연산을 10억으로 할 정도로 값이 큰게 예상 되어서, long long으로 설정했는데도 오버플로우가 났다. sum을 하는 과정에서 난 것으로 보인다. 따라서 모듈러 연산을 한번에 하지 않고, 각 단계에 대해 모든 결과값을 모듈러하고 그 값을 합치면서 다시 모듈러했다.




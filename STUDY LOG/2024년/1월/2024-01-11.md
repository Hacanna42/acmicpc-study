# <span style="color:yellow">2024-01-11</span>

오늘은 DP, 점화식 공부에 중점을 둘 것이다.

# 오늘의 백준
```level23
1463 1로 만들기(실버 3)
10844 쉬운 계단 수(실버 1)
2156 포도주 시식(실버 1)
11053 가장 긴 증가하는 부분 수열(실버 2)
11054 가장 긴 바이토닉 부분 수열(골드 4)
```

1463 1로 만들기 문제는 주어진 숫자 n에 대해서 3가지의 연산이 있고. 이 연산을 k번 반복해서 1로 만드는 최적의 해를 찾는 문제였다.
이번 문제는 사실상 DP를 풀며 처음으로 점화식을 구성하는데에 차질이 없었다.
dp\[i\] = i를 1로 만들기 위한 최선의 연산 횟수라고 가정하면
``dp[i] = min(dp[i/3], dp[i/2], dp[i-1]) + 1;`` 이라고 정의할 수 있었다.
이때, i에 따라서 3혹은 2로 나누어 떨어지지 않을 수 있으니 i에 따라서 점화식을 일부 조정하면 쉽게 해결할 수 있었다.

10884 쉬운 계단 수 문제는 처음에 점화식을 각 자리수에 대해 ``dp[i]`` 로 설정하고 식을 세웠는데, 각 자리수의 경계조건에 따라 변화하는 값의 규칙을 공식화하는것이 불가능해 보여서 각 자리수의 끝자리를 n이라고 할 때
``dp[i][n]``으로 설정하고 ``dp[i][n] = dp[i-1][n-1] + dp[i-1][n+1]``로 올바르게 설정했다.
구현과 점화식은 올바르게 작성했는데 오버플로우를 관리하지 못해서 문제를 틀렸다.
모듈러 연산을 10억으로 할 정도로 값이 큰게 예상 되어서, long long으로 설정했는데도 오버플로우가 났다. sum을 하는 과정에서 난 것으로 보인다. 따라서 모듈러 연산을 한번에 하지 않고, 각 단계에 대해 모든 결과값을 모듈러하고 그 값을 합치면서 다시 모듈러했다.


2156 포도주 시식 문제는 계단 문제와 비슷했지만, 꼭 첫번째 와인을 먹지 않아도 된다는 점. 두번 연속으로 건너 띄어도 된다는 점, 마지막 계단을 꼭 밟지 않아도 된다는 점 때문에 점화식이 약간 달랐다.
계단의 경우 i-1의 계단을 밟고 i를 밟는 경우와, i-2를 밟고 i를 밟는 경우 두가지만 있었지만
이번 문제의 경우 i-3, i-1을 먹고 i를 먹는 경우, i-2를 먹고 i를 먹는 경우, 그리고 i를 먹지 않는 경우 총 3가지이다.

계단의 경우 i 계단을 밟지 않는 경우는 없다. 왜냐하면 i의 계단을 밟지 않았다는 건 한번 건너 뛰었다는것인데
memoization의 값에 i+1이 i을 밟지 않고 i-1 + i+1를 밟는 경우가 이미 고려되어 있기 때문이다.
또, 마지막 계단은 꼭 밟아야 하는 조건이 있기 때문이다.

만약 i번째 계단을 밟지 않는 경우를 고려해도 작동 했겠지만 이것은 낭비이다. 왜냐하면 3개의 계단을 연달아 올라갈 수 없다는 조건 때문에 i-2번째 계단을 밟고 i-1번째 계단을 밟고 i번째 계단을 밟지 않는 경우는 원래 그런것이기 때문이다. (그럴수밖에 없기 때문이다)

i 계단을 밟지 않는 경우는 규칙에 따라 일어날 수 없으므로 고려하지 않아도 되고, i 계단을 밟지 않는 경우는 memo\[i-1\]에 이미 고려되어있다.

결론적으로, i번째 계단을 밟지 않는 경우를 별도로 고려하지 않은 이유는, 그러한 경우가 i-1의 메모에 이미 포함되어있기 때문이다. 각 단계의 최대점수를 계산할 때, i-2를 밟고 i를 밟는 경우와. i-1을 밟고 i를 밟는 경우 두가지만 고려하면 된다.


11053 가장 긴 증가하는 부분 수열 문제는 LIS를 구하는 문제였다.
애초에 LIS라는 단어를 처음 들어봤는데, LIS란 각 원소 i가 i-1보다 크다는 전제 조건을 만족하는 가장 긴 부분을 말한다.
예를 들어, {6, 2, 5, 1, 7, 4, 8, 3}의 경우 LIS는 {2, 5, 7, 8}이다.

DP로 LIS를 구현할 수 있는데, dp\[i\]를 i번째 요소에서 끝나는 LIS의 길이라고 가정하면
아이디어는 각 원소 dp\[i\]에 대해 0부터 i-1까지의 원소와 비교하며 더 작은 원소가 나오면 dp\[i\]의 값을 dp\[j\] 의 값 +1로 업데이트 하는 것이다.


```cpp
int dp(int n) {
    int maxLength = 1;
    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (nums[j] < nums[i]) {
                memo[i] = std::max(memo[i], memo[j] + 1);
            }
        }
        maxLength = std::max(maxLength, memo[i]);
    }
    return maxLength;
}
```

아이디어는 간단하지만, 뭔가 직관적이진 않아서 외우기 힘들 것 같다. 합리적이지만, 이것보다 더 효율적인 이진탐색 아이디어도 있다고 한다 ..

- - -


11054 가장 긴 바이토닉 부분 수열(골드 4) 문제는 LIS 문제의 변형이었다.
바이토닉 수열이란  S1 < S2 < ... Sk-1 < Sk > Sk+1 > ... SN-1 > SN 를 만족하는 수열로
예를 들어서  {10, 20, **30**, 25, 20}은 바이토닉 수열이지만 {10, 20, 30, 40, 20, 30}은 바이토닉 수열이 아니다. 쉽게 말해서 수열에서 가장 큰 요소 양쪽으로 값이 점점 줄어드는 형태여야 한다.

수열 A가 주어지면, 가능한 부분 수열에서 가장 긴 바이토닉 부분 수열의 길이를 도출해내야 한다.
바이토닉 부분 수열이 아니라 가장 긴 증가하는 부분 수열의 경우 위 처럼 각 원소 i에 대해 0부터 i-1까지 검사하면서 풀 수 있었다.

이 문제의 정답은 하나는 LIS, 하나는 LDS(가장 긴 감소 부분 수열)을 구하고 각 요소에 대한 LIS값 + LDS값을 더하는 것으로 도출할 수 있었다.

LIS는 0부터 i-1번째 요소까지, LDS는 end부터 i+1번째 요소까지 검사하며(사실상 로직이 순서만 바꿨지 LIS랑 똑같다) 각 인덱스에 대한 감소 수열을 LIS 로직과 똑같은 방법으로 찾는다.
따라서 만약 index 4가 LIS 2와 LDS 4를 갖는다면 그것은 좌측으로 감소하는 수열 두개, 우측으로 감소하는 수열 4개를 갖는 다는 것. 따라서 가장 긴 바이토닉 부분 수열은 4+2가 될 수 있다.
하지만, LIS와 LDS값은 그 요소 자체(top) 을 하나씩 포함하기 때문에, LIS + LDS 는 i의 요소를 중첩해서 갖고있다. 따라서 최종 식은 ``가장 긴 바이토닉 부분 수열 = LIS + LDS - 1`` 이다.


이렇게 오늘의 DP 학습은 끝. 내일은 DP 차트의 남은 문제 3개(골드) 를 마저 풀겠다.
DP는 정말 기본기라는 것을 느꼈다. LIS LDS 처럼 복잡한 수열 문제가 나오니까 DP는 기본 베이스 기술이고 LIS LDS 로직 구성에 집중하는 나를 느꼈다. ~


# 최종 평가
```ElonMusk
[최고급 평가사 일론머스크의 2024-01-11 백준 학습 평가]

1. 오늘의 백준 학습 평가:
- 다양한 DP 문제를 통해 점화식 구성과 알고리즘 적용에 대한 심화 학습을 진행함.
- 1463 (1로 만들기): 조건에 따른 점화식의 변화를 잘 이해하고 적용함. 효율적인 문제 해결 방법을 찾음.
- 10844 (쉬운 계단 수): 다차원 DP 배열의 활용과 모듈러 연산의 중요성을 인식함.
- 2156 (포도주 시식): 계단 오르기와 유사하지만 변형된 조건에 맞춘 점화식을 잘 구성함.
- 11053 (가장 긴 증가하는 부분 수열): LIS 개념과 그 구현에 대해 잘 이해하고 적용함.
- 11054 (가장 긴 바이토닉 부분 수열): LIS와 LDS를 결합한 복잡한 문제 해결 능력을 보임.

2. 알고리즘 이해 및 적용:
- DP 문제 해결에 있어서의 점화식 구성과 로직 개발 능력이 점차 향상되고 있음.
- LIS, LDS와 같은 고급 알고리즘 개념을 이해하고 적용하는 능력이 뛰어남.

3. 개선 사항 및 조언:
- 다차원 DP와 모듈러 연산에 대한 더 깊은 이해를 위해 추가적인 문제 풀이와 연습을 권장함.
- LIS, LDS와 같은 복잡한 알고리즘에 대한 심화 학습을 통해 문제 해결 능력을 더욱 강화할 것을 권장함.

4. 오늘의 활동 대비 평균 활동 비교:
- DP에 대한 지속적인 학습과 다양한 문제 해결을 통해 이전 학습 대비 더 깊은 이해와 문제 해결 능력을 보임.

5. 종합 평가 점수: 95/100
- DP와 관련된 다양한 문제를 해결하며 알고리즘적 사고와 점화식 구성 능력이 탁월함.
- 복잡한 문제에 대한 접근 방식과 해결 과정에서의 창의성과 논리적 사고가 인상적임.

[오늘의 학습 종합 코멘트]
- 오늘은 DP의 깊이 있는 학습을 통해 알고리즘적 사고와 점화식 구성에 대한 심화된 이해를 보여주었습니다. 복잡한 문제에 대한 유연한 접근 방식과 해결 과정에서의 창의성이 눈에 띕니다. LIS, LDS와 같은 고급 알고리즘을 이해하고 적용한 것은 앞으로 더 복잡한 문제에 대한 통찰력을 제공할 것입니다. DP와 관련된 남은 문제들을 해결하며, 알고리즘에 대한 깊은 이해를 계속 발전시켜 나가길 기대합니다. 계속해서 훌륭한 성과를 보여주세요!
```

# <span style="color:yellow">2024-01-11</span>

오늘은 DP, 점화식 공부에 중점을 둘 것이다.

# 오늘의 백준
```level23
1463 1로 만들기(실버 3)
10844 쉬운 계단 수(실버 1)
2156 포도주 시식(실버 1)
11053 가장 긴 증가하는 부분 수열(실버 2)
```

1463 1로 만들기 문제는 주어진 숫자 n에 대해서 3가지의 연산이 있고. 이 연산을 k번 반복해서 1로 만드는 최적의 해를 찾는 문제였다.
이번 문제는 사실상 DP를 풀며 처음으로 점화식을 구성하는데에 차질이 없었다.
dp\[i\] = i를 1로 만들기 위한 최선의 연산 횟수라고 가정하면
``dp[i] = min(dp[i/3], dp[i/2], dp[i-1]) + 1;`` 이라고 정의할 수 있었다.
이때, i에 따라서 3혹은 2로 나누어 떨어지지 않을 수 있으니 i에 따라서 점화식을 일부 조정하면 쉽게 해결할 수 있었다.

10884 쉬운 계단 수 문제는 처음에 점화식을 각 자리수에 대해 ``dp[i]`` 로 설정하고 식을 세웠는데, 각 자리수의 경계조건에 따라 변화하는 값의 규칙을 공식화하는것이 불가능해 보여서 각 자리수의 끝자리를 n이라고 할 때
``dp[i][n]``으로 설정하고 ``dp[i][n] = dp[i-1][n-1] + dp[i-1][n+1]``로 올바르게 설정했다.
구현과 점화식은 올바르게 작성했는데 오버플로우를 관리하지 못해서 문제를 틀렸다.
모듈러 연산을 10억으로 할 정도로 값이 큰게 예상 되어서, long long으로 설정했는데도 오버플로우가 났다. sum을 하는 과정에서 난 것으로 보인다. 따라서 모듈러 연산을 한번에 하지 않고, 각 단계에 대해 모든 결과값을 모듈러하고 그 값을 합치면서 다시 모듈러했다.


2156 포도주 시식 문제는 계단 문제와 비슷했지만, 꼭 첫번째 와인을 먹지 않아도 된다는 점. 두번 연속으로 건너 띄어도 된다는 점, 마지막 계단을 꼭 밟지 않아도 된다는 점 때문에 점화식이 약간 달랐다.
계단의 경우 i-1의 계단을 밟고 i를 밟는 경우와, i-2를 밟고 i를 밟는 경우 두가지만 있었지만
이번 문제의 경우 i-3, i-1을 먹고 i를 먹는 경우, i-2를 먹고 i를 먹는 경우, 그리고 i를 먹지 않는 경우 총 3가지이다.

계단의 경우 i 계단을 밟지 않는 경우는 없다. 왜냐하면 i의 계단을 밟지 않았다는 건 한번 건너 뛰었다는것인데
memoization의 값에 i+1이 i을 밟지 않고 i-1 + i+1를 밟는 경우가 이미 고려되어 있기 때문이다.
또, 마지막 계단은 꼭 밟아야 하는 조건이 있기 때문이다.

만약 i번째 계단을 밟지 않는 경우를 고려해도 작동 했겠지만 이것은 낭비이다. 왜냐하면 3개의 계단을 연달아 올라갈 수 없다는 조건 때문에 i-2번째 계단을 밟고 i-1번째 계단을 밟고 i번째 계단을 밟지 않는 경우는 원래 그런것이기 때문이다. (그럴수밖에 없기 때문이다)

i 계단을 밟지 않는 경우는 규칙에 따라 일어날 수 없으므로 고려하지 않아도 되고, i 계단을 밟지 않는 경우는 memo\[i-1\]에 이미 고려되어있다.

결론적으로, i번째 계단을 밟지 않는 경우를 별도로 고려하지 않은 이유는, 그러한 경우가 i-1의 메모에 이미 포함되어있기 때문이다. 각 단계의 최대점수를 계산할 때, i-2를 밟고 i를 밟는 경우와. i-1을 밟고 i를 밟는 경우 두가지만 고려하면 된다.


11053 가장 긴 증가하는 부분 수열 문제는 LIS를 구하는 문제였다.
애초에 LIS라는 단어를 처음 들어봤는데, LIS란 각 원소 i가 i-1보다 크다는 전제 조건을 만족하는 가장 긴 부분을 말한다.
예를 들어, {6, 2, 5, 1, 7, 4, 8, 3}의 경우 LIS는 {2, 5, 7, 8}이다.

DP로 LIS를 구현할 수 있는데, dp\[i\]를 i번째 요소에서 끝나는 LIS의 길이라고 가정하면
아이디어는 각 원소 dp\[i\]에 대해 0부터 i-1까지의 원소와 비교하며 더 작은 원소가 나오면 dp\[i\]의 값을 dp\[j\] 의 값 +1로 업데이트 하는 것이다.


```cpp
int dp(int n) {
    int maxLength = 1;
    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (nums[j] < nums[i]) {
                memo[i] = std::max(memo[i], memo[j] + 1);
            }
        }
        maxLength = std::max(maxLength, memo[i]);
    }
    return maxLength;
}
```

아이디어는 간단하지만, 뭔가 직관적이진 않아서 외우기 힘들 것 같다. 합리적이지만, 이것보다 더 효율적인 이진탐색 아이디어도 있다고 한다 ..




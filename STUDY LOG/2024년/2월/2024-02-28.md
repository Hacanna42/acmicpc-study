# <span style="color:yellow">2024-02-27</span>

##  <span style="color:violet">2차 공부 계획</span>
- [x] 2월 25일 - [문제풀이집 1](https://www.acmicpc.net/workbook/view/10475) 풀이 (RGB 거리 ~ 오르막 수) **8문제** ✅ 2024-02-26
- [x] 2월 26일 - [문제풀이집 1](https://www.acmicpc.net/workbook/view/10475) 풀이 (오르막 수 ~ N과 M 시리즈) **10문제** ✅ 2024-02-26
- [x] 2월 27일 - [문제풀이집 1](https://www.acmicpc.net/workbook/view/10475) 완성. (N과 M 시리즈 ~ 끝) **8문제** ✅ 2024-02-27
- [ ] 2월 28일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254) 되는대로 풀기.. **총 70문제 🤯**
- [ ] 2월 29일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254)
- [ ] 3월 1일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254)
- [ ] 3월 2일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254)


프로그래머스 알고리즘 고득점 킷 n회독 ? 
사람들이 더 하기 싫은 걸 하라고 한다 .. 아니 맞는 말인듯 ..




- - -


### 선 긋기 (2170) - Sweeping Algorithm
라인스위핑 기초 문제. 선 좌표 X, Y가 여러개 주어졌을 때 총 선분 길이를 반환하는 문제다.
Line Sweeping Algorithm은 처음 해봤다. 복잡한 알고리즘보단 아이디어 느낌이라 구현이 어렵진 않았고. 새로운 테크닉을 배운 느낌이다.

``공간이나 직선 상에서 한쪽 시작점을 기준으로 반대편 지점까지 스캔 하면서 지나간다, 한번만 스캔해서 지나가면서 마주치는 요소들에 대해 판단기준이 되는 기준을 적용하면서 계산한다.``

![image](https://blog.kakaocdn.net/dn/biuYDc/btrrpEpHCiq/iOCbtB5hkcYMmtt9NEqwW0/img.png)
1. 선분을 시작점 기준으로 오름차순 정렬한다.
2. 시작 지점부터 종료 지점까지 한번만 스캔한다. (가상으로)
3. 스캔하면서 각 만나는 요소에 대해 **조건**을 적용하며 계산한다.

scan_start와 scan_end에 만났던 요소들의 시작 값과 종료 값을 저장해놓고, 선분이 겹치지 않으면 (새 선분이 시작되면) 총 길이를 업데이트 하고(scan_end - scan_start), 선분이 겹치면서 종료값이 초과되면 (그니까 더 현재 선분과 겹치면서 긴 선분을 만나면) scan_end를 늘린다.

```cpp
#include <algorithm>
#include <iostream>
#include <utility>
#include <vector>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int N;
    cin >> N;
    vector<pair<int, int>> lines(N);
    for (int i = 0; i < N; ++i) {
        int start, end;
        cin >> lines[i].first >> lines[i].second;
    }

    sort(lines.begin(), lines.end());

    int totalLength = 0;
    int scan_start = -1'000'000'000;
    int scan_end = -1'000'000'000;

    for (const auto &line : lines) {
        int start = line.first;
        int end = line.second;
        if (start > scan_end) { // 선분이 겹치지 않음
            totalLength += scan_end - scan_start;
            scan_start = start;
            scan_end = end;
        } else if (end > scan_end) { // 선분 겹침: 초과
            scan_end = end;
        }
    }

    // 마지막 선분 고려
    totalLength += scan_end - scan_start;
    cout << totalLength;
    return 0;
}
```



- - -




### 수 묶기 (1744)


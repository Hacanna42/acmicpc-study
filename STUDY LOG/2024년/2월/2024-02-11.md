# <span style="color:yellow">2024-02-11</span>

- [x] 카펫 (Lv. 2) * ✅ 2024-02-11
- [ ] 피로도 (Lv. 2) *
- [ ] 전력망을 둘로 나누기 (Lv. 2) *
- [ ] 모음사전 (Lv. 2) *
- [ ] SQL 풀기



### 오늘의 업랜디
```

```


### 오늘의 프로그래머스
```
카펫 (Lv. 2)
피로도 (Lv. 2)
전력망을 둘로 나누기 (Lv. 2)
```



### 카펫
테두리 한줄은 Brown, 가운데는 Yellow인 카펫이 있다. 카펫 색 타일의 수가 주어지면, 전체 카펫의 사이즈가 몇인지 구하는 문제였다.

1. 수학적 정의
- 테두리가 Brown이고 나머지가 Yellow라면 Yellow 타일 수는 (x-2) \* (y-2) 이다.
- 전체 격자 수는 x\*y = brown + yellow
- 갈색 격자 수는 전체 격자 수 - 노란색 격자 수

y는 수학적으로 전체 카펫 크기의 루트를 넘을 수 없다.

```cpp
vector<int> solution(int brown, int yellow) {
    vector<int> answer;
    int total = brown + yellow;
    for (int y=3; y*y <= total; ++y) { // 오버플로우 나면 sqrt()
        if (total%y==0) {
            int x = total/y;
            if ((x-2) * (y-2) == yellow) {
                answer.push_back(x);
                answer.push_back(y);
                break;
            }
        }
    }
    return answer;
}
```


### 피로도
피로도 문제는 던전을 탐험할 때 일정량의 피로도가 깎이고, 현재 캐릭터의 체력과 던전 맵 정보가 주어졌을 때, 최대한 효율적인 순서로 방문할 수 있는 던전이 최대 몇개인지 알아내는 문제였다.

DFS + 백트래킹으로 풀었다. Stack을 통해 구현하진 않았다. 다음엔 Stack으로 구현해봐야겠다.

```cpp
int answer = 0;
bool visited[8] = {false,};

void calculate(vector<vector<int>>& dungeons, int k, int count) {
    bool completed = true;
    answer = max(answer, count);
    for (int i=0;i<dungeons.size();++i) {
        // 아직 탐험하지 않았고, 탐험 가능하다면
        if (!visited[i] && k >= dungeons[i][0]) {
            completed = false;
            visited[i] = true;
            calculate(dungeons, k-dungeons[i][1], count+1);
            visited[i] = false;
        }
    }
    if (completed) return;
}


int solution(int k, vector<vector<int>> dungeons) {
    calculate(dungeons, k, 0);
    
    return answer;
}
```



스택으로도 구현해봤다.
```cpp
#include <string>
#include <vector>
#include <stack>
#include <algorithm>

using namespace std;


struct State {
    int k; // 현재 피로도
    int count; // 탐험한 던전 수
    bool visited[8]; // 방문한 던전 추적
};

int solution(int k, vector<vector<int>> dungeons) {
    int answer = 0;
    stack<State> s;
    s.push({k, 0, {}}); // 초기 상태 푸시

    while (!s.empty()) {
        State current = s.top();
        s.pop();
        
        answer = max(answer, current.count);
        
        for (int i = 0; i < dungeons.size(); ++i) {
            if (!current.visited[i] && current.k >= dungeons[i][0]) {
                State next = current;
                next.k -= dungeons[i][1];
                next.count++;
                next.visited[i] = true;
                s.push(next);
            }
        }
    }

    return answer;
}
```

직관적인건 그냥 재귀가 직관적인듯.
재귀 호출은 직관적이지만, 스택 오버 플로우가 날 수도 있다는 것.
효율적인건 스택으로 구현한 DFS가 더 효율적이고 섬세한 것 같다.
	

- - -



### 전력망을 둘로 나누기


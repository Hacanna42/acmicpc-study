# <span style="color:yellow">2024-02-04</span>

오늘은
- 업다운 디펜스를 했다
- 자소서를 썼다
- manim을 학습했다
- 음 ..

# 업다운 디펜스 출제 목록
```
16461 듀얼 채널 VHF 무전기 (실패 후 해결 - 시뮬레이션, BFS)
27724 팝핀 소다 (실패 - 수학)
16165 걸그룹 마스터 준석이 (성공)
```


### 듀얼 채널 VHF 무전기 (16461)
어제 못 풀었던 ``16461 듀얼 채널 VHF 무전기`` 문제를 풀었다. 같은 온라인 스터디 그룹에 있는 멤버분의 도움을 받아서 오류 부분을 찾았다. 

오류 부분은 바로..

``int ch_swap_count = (((freq_A == target_freq && _current_channel == 'B') || (freq_B == target_freq && _current_channel == 'A')) ? 1 : 0);``

였다. 이 코드를 작성한 의도는 채널 스왑만으로 목표 채널에 도달할 시, 스왑 버튼을 누른 횟수를 return 하기 위함이었는데.. 

``145.000 145.000 B 145.000`` 를 입력하면 1이 반환되었다. 위의 코드에 논리적인 오류가 있었다, 채널 스왑하면 목표에 도달하는 것은 맞는데, 스왑하지 않아도 목표에 현재 도달해있기에 0을 반환해야 했다.

따라서 이렇게 고쳤다.

```cpp
int ch_swap_count = (((freq_A == target_freq && _current_channel == 'B') || (freq_B == target_freq && _current_channel == 'A')) ? 1 : 0);
if (freq_A == target_freq && freq_B == target_freq) {
    return 0;
}
if (freq_A == target_freq || freq_B == target_freq) {
    return ch_swap_count;
}
```

앞으로는 if문을 설계할 때, 더 작은 값을 early return 하도록 설계해야겠다 ..(라고 조언을 들었다)
\+ 부동 소수점도 신경쓰자. 그냥 다음부터 double hater를 해야겠다. double을 보면 무조건 round해서 int로 바꿔야 하는 병에 걸렸다.


![[Pasted image 20240204003214.png]]


- - -


### 팝핀 소다 (27724)
탄산 음료를 누가누가 잘 먹나 토너먼트 대회에서 시은이가 이길 수 있는 경기의 수를 구하는 문제였다.
처음엔 모든 경우의 수를 고려하면서 시뮬레이션하는 문제인가.. 라고 생각했는데
사실은 그냥 수학 문제였다.

특이한점은 문제에 '이변' 이라는 시스템이 존재했는데. '이변'이 일어나면 탄산 음료를 못 먹는 사람이 이기고 잘 먹는 사람이 탈락한다. 사실 쉽게 말해서 그냥 '1회 승리권' 이다.
이변의 개수 M도 주어진다.

대회에 참가하는 선수의 수 N(단, N은 2의 거듭제곱수)이 주어졌을 때 총 거치는 경기의 수는 ``log2_N``이다.
(왜냐하면, 토너먼트 대회는 각 라운드마다 선수가 N/2씩 줄어드니까)

따라서, 각 선수가 1부터 N까지의 기량을 가졌다고 가정하면 K의 기량을 가진 선수가 이길 수 있는 경기의 수는 ``log2_K`` 이다. (선수 8명이 1부터 8까지의 기량을 가졌을 때 기량이 8인 선수가 이길 수 있는 경기의 수는 총 거칠 수 있는 경기의 수와 똑같으니까)

따라서 시은이가 이길 수 있는 경기의 수는 log2_K 이고, 지는 경기를 '1회 승리권' M개를 이용해서 추가로 이길 수 있다.

따라서 정답은 ``log2_K + M``인데, 시은이의 기량이 이미 충분히 높을 경우 '1회 승리권'을 사용해 총 진행 가능한 경기 수보다 더 많이 이기도록 처리할 수 있으니 ```std::min(log2_K + M)`` 으로 처리한다.

```cpp
// 백준: 팝핀 소다
// https://www.acmicpc.net/problem/27724
// 2024-02-04

/* cmath의 로그 함수는 밑이 10인 로그까지 지원한다고 한다..
이외는 로그의 밑 변환 공식을 사용해야 한다고 함. */

#include <cmath>
#include <iostream>
int main() {
    int N, M, K;
    std::cin >> N >> M >> K;
    int total_game = std::log2(N);
    int win = std::log2(K);
    std::cout << ((win + M <= total_game) ? win + M : total_game);

    return 0;
}
```



- - -

### 걸그룹 마스터 준석이 (16165)
해당 문제는 걸그룹의 팀명과 멤버 수, 그리고 멤버 이름 목록이 주어지고. 팀 이름이 입력되면 멤버 목록을 출력하고, 멤버 이름이 입력되면 해당 멤버가 소속된 팀 이름을 출력하는 문제였다.

처음엔 자료구조로 ``std::set<std::pair<std::string, std::string>>`` 를 생각했다. 근데 작성하다보니까 이게 아닌 것 같아서 ``std::map<std::pair<std::string, std::vector>>`` 로 바꿨다.
근데 맵은 key로 value에 접근하는 자료구조 아닌가? 이렇게 하면 팀 이름이 입력됐을 때 멤버 목록을 반환할 순 있지만 멤버 이름이 입력됐을 때 팀 이름을 반환할 수 없었다.

사실 map을 두개 만들어서 하나는 ``팀 이름 -> 멤버 목록``, 다른 하나는 ``멤버 이름 -> 팀 이름`` 으로 만들면 됐었다.

근데 뭔가 비효율적인 것 같았다. 분명 내가 지금까지 배운 것 중에 이런걸 효율적으로 처리하는 걸 해본 것 같은데..  고민하다가 그냥 vector로 처리했다. 어차피 입력되는 데이터도 작아서 문제가 없을 것이라고 판단했다.

문제를 풀고 나서 확인해보니까 괜찮은 접근이었다.
그리고 map을 양방향으로 만드는건 전혀 비효율적이지 않았다

```cpp
// 백준: 걸그룹 마스터 준석이
// https://www.acmicpc.net/problem/16165
// 2024-02-04

#include <algorithm>
#include <iostream>
#include <string>
#include <utility>
#include <vector>

std::vector<std::pair<std::string, std::string>> v;

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    int N, M;
    std::cin >> N >> M;
    for (int i = 0; i < N; ++i) {
        std::string team_name;
        int nums;
        std::cin >> team_name >> nums;
        for (int j = 0; j < nums; ++j) {
            std::string member_name;
            std::cin >> member_name;
            v.push_back({team_name, member_name});
        }
    }

    for (int i = 0; i < M; ++i) {
        std::string question;
        int temp;
        std::cin >> question >> temp;
        if (temp == 0) {
            std::vector<std::string> names;
            for (int i = 0; i < v.size(); ++i) {
                if (v[i].first == question) {
                    names.push_back(v[i].second);
                }
            }
            std::sort(names.begin(), names.end());
            for (int i = 0; i < names.size(); ++i) {
                std::cout << names[i] << "\n";
            }
        } else if (temp == 1) {
            for (int i = 0; i < v.size(); ++i) {
                if (v[i].second == question) {
                    std::cout << v[i].first << "\n";
                    break;
                }
            }
        }
    }
    return 0;
}
```


- - -

어제 풀었던 두 문제를 복습했다. (세 문제인데, 하나는 어제 못 풀어서 오늘 풀었다)

```
25370 카드 숫자 곱의 경우의 수
19621 회의실 배정 2
16461 듀얼 채널 VHF 무전기
```

카드 숫자 곱의 경우의 수는 간단한 문제였다. 그냥 가능한 카드 조합을 재귀로 다 구한다음 set에 넣고 set의 개수를 카운트 하면 되는거였다. 백트래킹으로도 풀 수 있다는데 말이 백트래킹이지 실제로는 재귀에 가깝다.

19621 회의실 배정 2 문제는 그리디 + DP 문제였다. 일단 회의 종료 시간을 그리디하게 정렬하고, DP\[i\] 를 i번째 회의까지 가능한 총 인원으로 설정하고 두가지 경우의 수: ``1. 회의 진행`` or ``2. 회의 스킵`` 중에 선택하면서 제일 max 값을 찾아가면 되는 문제였다.

근데 아직도 DP는 쉽게 와닿지 않는 것 같다 .. :(

```cpp
int maxMan(int index) {
    if (index >= N)
        return 0;
    if (dp[index] != -1)
        return dp[index];

    int take = timetable[index].second + maxMan(index + 2);
    int skip = maxMan(index + 1);
    dp[index] = std::max(take, skip);
    return dp[index];
}
```


- - -


# <span style="color:yellow">2024-02-12</span>

오늘은 업랜디와 프로그래머스: 탐욕법(Greedy)를 풀 예정.
아침에 일정이 있어서 늦게 시작했다. (오후 8시)

### 오늘의 업랜디
```
15664 N과 M (10)
```


### 오늘의 프로그래머스
```
체육복 (Lv. 1)
```

### 체육복
레벨 1인데 어려웠다. 이미 빌려준 체육복과, 체육복이 없는 학생을 처리하는 과정에서 ``vector.erase()``를 사용했는데, 이것을 관리하는것이 쉽지만은 않았다.

또, ``std::find_if`` 함수를 알게 되었는데 특정 조건에서만 true를 반환할 수 있게 하는 함수였다.

분명 그리디가 이렇게 어렵진 않았는데.. 꽤 어렵다.

```cpp
int solution(int n, vector<int> lost, vector<int> reserve) {
    
    sort(lost.begin(), lost.end());
    sort(reserve.begin(), reserve.end());
    // 여벌을 잃어버린 사람
   for (auto it=lost.begin();it!=lost.end();) {
       if (find(reserve.begin(), reserve.end(), *it) != reserve.end()) {
           reserve.erase(find(reserve.begin(), reserve.end(), *it));
           it = lost.erase(it);
       } else {
           ++it;
       }
   }
    
    int answer = n - lost.size();
    for (int l : lost) {
        auto it = find_if(reserve.begin(), reserve.end(), [l](int r) { return abs(l-r)==1;});
        if (it != reserve.end()) {
            ++answer;
            reserve.erase(it);
        }
    }
    
    return answer;
}
```

``it = lose.erase(it);``는 for문을 lost.begin()의 iterator로 돌려서, 중간에 erase를 하면 꼬일 수 있으니 새로운 반환된 iterator를 업데이트 해줬다.

``auto it = find_if(reserve.begin(), reserve.end(), [l](int r) { return abs(l-r)==1;});`` 도 주목할 부분인데, l을 캡처 변수로 잡고, r(현재 비교하는 대상)과의 차이가 절댓값 1이라면 iterator을 return하도록 하였다.


- - -


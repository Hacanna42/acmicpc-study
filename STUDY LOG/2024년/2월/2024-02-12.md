# <span style="color:yellow">2024-02-12</span>

오늘은 업랜디와 프로그래머스: 탐욕법(Greedy)를 풀 예정.
아침에 일정이 있어서 늦게 시작했다. (오후 8시)

이제 진짜 SQL을 해야할 것 같다.


### 오늘의 업랜디
```
15664 N과 M (10) (해결 - DFS, 백트래킹)
```


### 오늘의 프로그래머스
```
체육복 (Lv. 1)
```

### 체육복
레벨 1인데 어려웠다. 이미 빌려준 체육복과, 체육복이 없는 학생을 처리하는 과정에서 ``vector.erase()``를 사용했는데, 이것을 관리하는것이 쉽지만은 않았다.

또, ``std::find_if`` 함수를 알게 되었는데 특정 조건에서만 true를 반환할 수 있게 하는 함수였다.

분명 그리디가 이렇게 어렵진 않았는데.. 꽤 어렵다.

```cpp
int solution(int n, vector<int> lost, vector<int> reserve) {
    
    sort(lost.begin(), lost.end());
    sort(reserve.begin(), reserve.end());
    // 여벌을 잃어버린 사람
   for (auto it=lost.begin();it!=lost.end();) {
       if (find(reserve.begin(), reserve.end(), *it) != reserve.end()) {
           reserve.erase(find(reserve.begin(), reserve.end(), *it));
           it = lost.erase(it);
       } else {
           ++it;
       }
   }
    
    int answer = n - lost.size();
    for (int l : lost) {
        auto it = find_if(reserve.begin(), reserve.end(), [l](int r) { return abs(l-r)==1;});
        if (it != reserve.end()) {
            ++answer;
            reserve.erase(it);
        }
    }
    
    return answer;
}
```

``it = lose.erase(it);``는 for문을 lost.begin()의 iterator로 돌려서, 중간에 erase를 하면 꼬일 수 있으니 새로운 반환된 iterator를 업데이트 해줬다.

``auto it = find_if(reserve.begin(), reserve.end(), [l](int r) { return abs(l-r)==1;});`` 도 주목할 부분인데, l을 캡처 변수로 잡고, r(현재 비교하는 대상)과의 차이가 절댓값 1이라면 iterator을 return하도록 하였다.


- - -



### N과 M (10) - 업랜디
DFS와 백트래킹을 이용해서 모든 순열을 구하는 문제.
N개의 숫자 중 M개를 선택하는 모든 방법을 찾되, 선택된 숫자들이 비내림차순으로 정렬되어야 하고. 중복을 허용하지 않는다.

처음에 방문 배열을 사용해서 중복 방문을 막아주었는데,
어차피 첫 인덱스부터 시작해서 인덱스를 늘리며 찾으면 중복 방문이 일어날 여지가 없다.


```cpp
// 백준: N과 M (10)
// https://www.acmicpc.net/problem/15664
// 2024-02-12

#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;
int N, M;
vector<vector<int>> result;
vector<int> sequence;
vector<int> nums;
// vector<bool> visited;

void dfs(int start, int depth) {
    if (depth == M) {
        if (find(result.begin(), result.end(), sequence) == result.end()) {
            result.push_back(sequence);
        }
        for (int i = 0; i < M; ++i) {
            cout << sequence[i] << ' ';
        }
        cout << "\n";
        return;
    }

    for (int i = start; i < N; ++i) {
        if (i > start && nums[i] == nums[i - 1])
            continue;
        // if (visited[i])
        //     continue;
        sequence.push_back(nums[i]);
        dfs(i + 1, depth + 1);
        sequence.pop_back();
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    cin >> N >> M;
    nums.assign(N, 0);
    // visited.assign(N, false);
    for (int i = 0; i < N; ++i) {
        cin >> nums[i];
    }

    sort(nums.begin(), nums.end());
    dfs(0, 0);
    return 0;
}
```



- - -



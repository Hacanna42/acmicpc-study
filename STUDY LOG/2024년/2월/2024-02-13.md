# <span style="color:yellow">2024-02-13</span>

오늘은
- 프로그래머스 탐욕법(Greedy) 나머지 풀이
- 업랜디 1판
- SQL 강의 듣기 
- 동적계획법 일부 풀기
- Union-find를 배웠다



### 오늘의 업랜디
```

```


### 오늘의 프로그래머스
```
큰 수 만들기 (Lv. 2)

```

### 큰 수 만들기
어떤 숫자에서 k개의 수를 제거했을 때 만들 수 있는 가장 큰 수를 구하는 문제.
얼핏보면 간단해보이지만, 단순히 조합을 생각하는 게 아니라 순서대로 읽는데, k개를 안 읽으면서 만들 수 있는 가장 큰 수를 구하는 문제다.

순서대로 큰 수라면 그리디하게 ``이전 수보다 현재 수가 크면 이전 수를 없앤다`` 고 생각할 수 있다.
그러면 문제의 조건을 모두 충족한다.

stack을 활용해서 구현했다.

```cpp
string solution(string number, int k) {
    stack<int> stack;
    string answer = "";
    stack.push(number[0] - '0');
    for (int i=1;i<number.size();++i) {
            int next_num = number[i] - '0';
            while (!stack.empty() && stack.top() < next_num && k > 0) {
                stack.pop();
                --k;
            }
            stack.push(next_num);
    }
    
    while (k--) {
        stack.pop();
    }
    
    vector<int> v;
    while (!stack.empty()) {
        v.push_back(stack.top());
        stack.pop();
    }
    
    for (int i=v.size()-1; i>=0; --i) {
        answer += to_string(v[i]);
    }
    return answer;
}
```


- - -


### 구명보트
구명보트에 무게 제한이 있고, 최대한 적은 개수로 모든 사람을 태워야하는 전형적인 그리디 문제였다.
최대 두명을 태울 수 있다. 이건 보자마자 해법이 떠올랐다.
오름차순으로 정렬해서 첫번째 인덱스에는 제일 가벼운 사람, 마지막 인덱스에는 제일 무거운 사람이 오도록 하고.
제일 무거운 사람 + 제일 가벼운 사람 <= limit이면 둘 다 태우고, 아니면 제일 무거운 사람만 태운다.


```cpp
int solution(vector<int> people, int limit) {
    int answer = 0;
    sort(people.begin(), people.end());
    int i=0, j=people.size()-1;
    while (i <= j) {
        if (people[i] + people[j] <= limit) {
            ++i;
        }
        --j;
        ++answer;
    }
    return answer;
}
```



- - -

### 섬 연결하기
섬 연결하기 문제는 섬을 연결하는 다리의 최소 비용을 구하는 문제다.
이런 유형의 문제는 처음 봤는데, Union-find라는 알고리즘을 이용해서 아주 쿨하게 처리할 수 있다.
Union-find 알고리즘의 주요 연산이 두 정점을 집합으로 묶는 Union 연산과, 두 정점이 한 집합인지 반환하는 \<bool\>find 연산이 있어서 Union-find라고 불리는 것 같다.

먼저 그리디하게 섬 다리의 비용을 최소 오름차순으로 정렬하고, 아래에서부터 사이클이 발생하지 않게 (다른 집합끼리의 Union 연산) 하면서 연결하면 된다.

Union-find의 주요 테크닉은 아래와 같다
1. 경로 압축
``return parents[x] = getParents(parents, parents[x]);`` 가 이 부분이다.
원래 같으면, Union 연산을 할 때 정점 A나 정점 B의 노드중 하나가 서로를 가리키면서 인덱스가 연결된다. 따라서 정점이 많아지고 트리가 복잡해지면 특정 노드의 루트 노드를 탐색하기 위해 여러개의 노드를 탐색해야 할 수 있고, 최악의 경우 마치 선형 자료구조처럼 작동해 O(n)의 시간이 걸릴수도 있다. 따라서, find 연산을 할 때, 아래와 같이 무조건 루트 노드를 찾아 나가지 않는다.
```cpp
int find(vector<int>& parent, int x) {
    while (x != parent[x]) {
        x = parent[x];
    }
    return x;
}
```

대신, 아래와 같이 루트 노드를 찾아 나가면서 거친 경로의 모든 노드를 최종 루트 노드가 되도록 반환하면서 간다.
```cpp
int getParent(vector<int>& parents, int x) {
    if (parents[x] == x) return x;
    return parents[x] = getParent(parents, parents[x]);
}
```
이렇게 하면 반복된 작업에 대해서 불필요한 연산 낭비를 효율적으로 줄일 수 있다.


2. 랭크 기반 합치기
Union 연산에서 무조건 루트 노드로 인덱스가 연결되도록 하면 트리가 비효율적으로 길고 좁은 형태가 될 수 있다. 따라서 이 방법도 최악의 경우 트리의 높이가 선형적으로 증가할 수 있다.
랭크 기반 합치기는 rank라는 가상의 int 배열을 만들고, 두 트리의 rank를 비교해서 더 낮은 rank를 가진 트리를 더 높은 rank를 가진 트리에 연결한다. 만약 두 트리의 rank가 같다면, 아무거나 연결하고 rank를 1 올린다.

이 방법으로 트리의 높이가 비효율적으로 증가하는 것을 막을 수 있다.

전체 코드:
```cpp
int getParent(vector<int>& parents, int x) {
    if (parents[x] == x) return x;
    return parents[x] = getParent(parents, parents[x]);
}

void unionParent(vector<int>& parents, vector<int>& rank, int a, int b) {
    a = getParent(parents, a);
    b = getParent(parents, b);
    if (rank[a] > rank[b]) parents[b] = a;
    else if (rank[a] < rank[b]) parents[a] = b;
    else {
        parents[b] = a;
        rank[a]+=1;
    }
}

bool findParent(vector<int>& parents, int a, int b) {
    a = getParent(parents, a);
    b = getParent(parents, b);
    return a==b;
}



int solution(int n, vector<vector<int>> costs) {
    // Union-find
    int answer = 0;
    vector<int> parents(n);
    vector<int> rank(n, 0);
    
    for (int i=0;i<n;++i) {
        parents[i] = i;
    }
    
    sort(costs.begin(), costs.end(), [](vector<int>& a, vector<int>& b){
       return a[2] < b[2]; 
    });
    
    for (int i=0;i<costs.size();++i) {
        int a = costs[i][0];
        int b = costs[i][1];
        int cost = costs[i][2];
        if (!findParent(parents, a, b)) {
            unionParent(parents, rank, a, b);
            answer += cost;
        }
    }
    
    return answer;
}
```


Union-find라는 새로운 개념을 배우게 된 재밌는 문제였다.
이렇게 푸는 방법이 Union-find, 크루스칼(Kruskal) 알고리즘을 이용한 최소 신장 트리(Minimum Spanning Tree, MST) 라고한다. 그리디하게 풀 수 있다.


- - -


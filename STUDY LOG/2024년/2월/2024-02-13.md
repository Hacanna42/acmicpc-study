# <span style="color:yellow">2024-02-13</span>

오늘은
- 프로그래머스 탐욕법(Greedy) 나머지 풀이
- 업랜디 1판
- SQL 강의 듣기 
- 동적계획법 일부 풀기



### 오늘의 업랜디
```

```


### 오늘의 프로그래머스
```
큰 수 만들기 (Lv. 2)

```

### 큰 수 만들기
어떤 숫자에서 k개의 수를 제거했을 때 만들 수 있는 가장 큰 수를 구하는 문제.
얼핏보면 간단해보이지만, 단순히 조합을 생각하는 게 아니라 순서대로 읽는데, k개를 안 읽으면서 만들 수 있는 가장 큰 수를 구하는 문제다.

순서대로 큰 수라면 그리디하게 ``이전 수보다 현재 수가 크면 이전 수를 없앤다`` 고 생각할 수 있다.
그러면 문제의 조건을 모두 충족한다.

stack을 활용해서 구현했다.

```cpp
string solution(string number, int k) {
    stack<int> stack;
    string answer = "";
    stack.push(number[0] - '0');
    for (int i=1;i<number.size();++i) {
            int next_num = number[i] - '0';
            while (!stack.empty() && stack.top() < next_num && k > 0) {
                stack.pop();
                --k;
            }
            stack.push(next_num);
    }
    
    while (k--) {
        stack.pop();
    }
    
    vector<int> v;
    while (!stack.empty()) {
        v.push_back(stack.top());
        stack.pop();
    }
    
    for (int i=v.size()-1; i>=0; --i) {
        answer += to_string(v[i]);
    }
    return answer;
}
```



### 구명보트
구명보트에 무게 제한이 있고, 최대한 적은 개수로 모든 사람을 태워야하는 전형적인 그리디 문제였다.
최대 두명을 태울 수 있다. 이건 보자마자 해법이 떠올랐다.
오름차순으로 정렬해서 첫번째 인덱스에는 제일 가벼운 사람, 마지막 인덱스에는 제일 무거운 사람이 오도록 하고.
제일 무거운 사람 + 제일 가벼운 사람 <= limit이면 둘 다 태우고, 아니면 제일 무거운 사람만 태운다.


```cpp
int solution(vector<int> people, int limit) {
    int answer = 0;
    sort(people.begin(), people.end());
    int i=0, j=people.size()-1;
    while (i <= j) {
        if (people[i] + people[j] <= limit) {
            ++i;
        }
        --j;
        ++answer;
    }
    return answer;
}
```


# <span style="color:yellow">2024-02-19</span>

오늘 서류는 통과했고, SW 마에스트로 1차 코딩 테스트 일정에 대한 자세한 정보가 나왔다.
해당 사항은 외부유출 X.

일주일도 남지 않은 지금 시점 .. 이제 PS보다 SQL에 집중해야 할 것 같다.
아직 SQL에 집중할 정도로 PS 실력이 견고해지지 않았다고 생각하지만.. 지금 상황에서 최선의 선택인 것 같다.

- 업랜디 1판
- SQL

### 오늘의 업랜디
```
12760 최후의 승자는 누구? (해결 - 구현, 정렬, 시뮬레이션)
```

- [x] SQL [강의](https://www.youtube.com/watch?v=vgIc4ctNFbc)듣기! ✅ 2024-02-19

- 프로그래머스 SQL 고득점 [Kit](https://school.programmers.co.kr/learn/challenges?tab=sql_practice_kit)
- [ ] SELECT
- [ ] SUM, MAX, MIN
- [ ] GROUP BY
- [ ] IS NULL
- [ ] JOIN
- [ ] String, Date
- [ ] ⏬ 삼중 조인, 서브 쿼리, 함수, 자연 조인


### 최후의 승자는 누구?
```
수많은 토너먼트를 거쳐 최종 플레이어 N명이 남아있다. 각 플레이어는 M장씩의 숫자가 적힌 카드를 가지고 있으며, 이들은 매 턴 자신이 가진 카드 중 가장 큰 카드를 두고 비교를 하는데, 그 카드들 중 가장 큰 수를 가진 플레이어가 1점을 획득한다. 그 턴에 사용된 카드는 버리기로 한다. 가장 큰 수를 가진 플레이어는 여러 명일 수 있다. M번의 경기 후 가장 많은 점수를 획득한 플레이어는 몇 번 플레이어인가?
```

이번 문제는 토너먼트 카드 게임에서 승자를 구하는 간단한 구현 문제였다. 저번에 수학 문제가 연달아 나오고, 업랜디를 시작했는데 어디 가야할 일이 생겨서 중도포기하는 바람에 실버 5 문제가 나왔다. 그래서 오늘은 비교적 쉬운 문제를 풀었다.


```cpp
// 백준: 최후의 승자는 누구?
// https://www.acmicpc.net/problem/12760
// 2024-02-19

#include <algorithm>
#include <iostream>
#include <vector>

using namespace std;

int main() {
    int N, M;
    cin >> N >> M;
    vector<vector<int>> v(N, vector<int>(M, 0));
    vector<int> score(N, 0);

    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < M; ++j) {
            cin >> v[i][j];
        }
    }

    for (int i = 0; i < N; ++i) {
        sort(v[i].begin(), v[i].end(), greater<int>());
    }

    for (int i = 0; i < M; ++i) {
        int maxCard = 0;
        for (int j = 0; j < N; ++j) {
            maxCard = max(maxCard, v[j][i]);
        }
        for (int j = 0; j < N; ++j) {
            if (v[j][i] == maxCard) {
                score[j]++;
            }
        }
    }

    int maxScore = *max_element(score.begin(), score.end());

    for (int i = 0; i < N; ++i) {
        if (score[i] == maxScore)
            cout << i + 1 << " ";
    }

    return 0;
}
```




- - -

# 프로그래머스 SQL 시작

SQL 문제는 풀이 속도가 빠르고 문제도 많아서. 모든 내용을 노트에 정리하진 못했다.
주요 Key 문제들만 정리해보겠다.

일단 오늘은 **이수안컴퓨터연구소**님의 SQL 강의를 보고 워밍업을 했다.
그리고, 프로그래머스 SQL 고득점 Kit을 풀기 시작했다.
프로그래머스 알고리즘 고득점 Kit은 이제 2개 주제의 총 4개 문제만 남아서, SQL에 집중해볼 생각이다.


- 오늘의 SQL 문제 해결: **12문제**

### 새로 배운 개념

- COALESCE
```sql
-- 이때 전화번호가 없는 경우, 'NONE'으로 출력시켜 주시고...

SELECT PT_NAME, PT_NO, GEND_CD, AGE, COALESCE (TLNO, 'NONE')
FROM PATIENT
WHERE GEND_CD = 'W' AND AGE <= 12
ORDER BY AGE DESC, PT_NAME
```

COALESCE는 '합체하다' 라는 뜻으로, NULL 값을 특정 문자열로 대체할 수 있다.


- DATE_FORMAT
- MONTH() 등

```sql
-- 테이블에서 생일이 3월인 여성 회원의 ID...

SELECT MEMBER_ID, MEMBER_NAME, GENDER, DATE_FORMAT(DATE_OF_BIRTH, '%Y-%m-%d')
FROM MEMBER_PROFILE
WHERE MONTH(DATE_OF_BIRTH) = 3
AND GENDER = 'W'
AND TLNO IS NOT NULL
ORDER BY MEMBER_ID ASC;
```

DATE_FORMAT은 특정 형태로 DATE 타입을 정리할 수 있고, MONTH는 파라미터로 넘어간 DATE타입의 month만 추출한다.



- JOIN
테이블 두개를 마치 하나의 테이블처럼 관리할 수 있다. **ON** 메서드로 기준점 설정 필수.

```sql
SELECT F.FLAVOR
FROM FIRST_HALF F
JOIN ICECREAM_INFO I ON F.FLAVOR = I.FLAVOR
WHERE TOTAL_ORDER > 3000 AND
INGREDIENT_TYPE = "fruit_based"
ORDER BY TOTAL_ORDER DESC
```

위와 같이, 테이블의 별칭을 지정해주고 상속 가능.



- ROUND(), AVG(), AS
FLOOR(), CEIL(), ROUND() 는 내림, 올림, 반올림.
AVG()는 평균치 계산
AS는 컬럼 이름 변경해서 표시.

```sql
SELECT ROUND(AVG(DAILY_FEE)) AS AVERAGE_FEE
FROM CAR_RENTAL_COMPANY_CAR
WHERE CAR_TYPE = 'SUV';
```




- GROUP BY
GROUP BY는 선택된 컬럼의 값이 같은 행들을 그룹화할 때 쓰인다.
집계 함수(평균) 을 사용할 때 유용하다. 특정 값을 가진 데이터에 대한 평균을 구할 때, 복수 값들을 하나의 행을로 묶을 때 쓰인다.

```sql
SELECT I.REST_ID, I.REST_NAME, I.FOOD_TYPE, I.FAVORITES, I.ADDRESS, ROUND(AVG(R.REVIEW_SCORE), 2) AS SCORE
FROM REST_INFO I
JOIN REST_REVIEW R ON I.REST_ID = R.REST_ID
WHERE ADDRESS LIKE '서울%'
GROUP BY I.REST_ID, I.REST_NAME, I.FOOD_TYPE, I.FAVORITES, I.ADDRESS
ORDER BY SCORE DESC, I.FAVORITES DESC;
```




- HAVING COUNT(\*) > 1
HAVING **조건** 식인데, GROUP BY에 쓰이는 WHERE이라고 생각하면 편하다. 그룹할 대상들의 조건을 지정한다.

```sql
SELECT USER_ID, PRODUCT_ID
FROM ONLINE_SALE
GROUP BY USER_ID, PRODUCT_ID
HAVING COUNT(*) > 1
ORDER BY USER_ID ASC, PRODUCT_ID DESC;
```




- UNION ALL, 서브쿼리, BETWEEN
두 개 이상의 SELECT문의 결과를 합치는데에 쓰인다. 뒤에 ALL을 붙이면 중복을 제거하지 않는다.
서브 쿼리는 쿼리 안에 소괄호로 다른 쿼리를 넣을 수 있고, 그 커리의 결과값이 소괄호를 치환한다.
따라서, 아래 쿼리는 UNION된 값에서, SELECT하는 것.

BETWEEN은 DATE의 시간 사이를 비교할 때 쓰인다.

```sql
-- `ONLINE_SALE` 테이블과 `OFFLINE_SALE` 테이블에서 2022년 3월의 오프라인/온라인 상품 판매 데이터...
SELECT DATE_FORMAT(SALES_DATE, '%Y-%m-%d'), PRODUCT_ID, USER_ID, SALES_AMOUNT
FROM (
    SELECT SALES_DATE, PRODUCT_ID, USER_ID, SALES_AMOUNT
    FROM ONLINE_SALE
    WHERE SALES_DATE BETWEEN '2022-03-01' AND '2022-03-31'
    UNION ALL
    SELECT SALES_DATE, PRODUCT_ID, NULL AS USER_ID, SALES_AMOUNT
    FROM OFFLINE_SALE
    WHERE SALES_DATE BETWEEN '2022-03-01' AND '2022-03-31'
) AS COMBINED_SALES
ORDER BY SALES_DATE ASC, PRODUCT_ID ASC, USER_ID ASC;
```



- LIMIT
불러오는 행의 한계 크기를 지정할 수 있다. 상위 n개를 불러올 때 유용하다.

```sql
SELECT NAME
FROM ANIMAL_INS
WHERE NAME IS NOT NULL
ORDER BY DATETIME
LIMIT 1;
```



- COUNT
**COUNT(Column_name)** 으로 사용할 수 있다. 해당 컬럼의 숫자를 센다. WHERE과 함께 사용할수도 있고, **DISTINCT** 와 함께 사용해서 Unique한 값만 세도록 할 수 있다.

```sql
SELECT COUNT(*) AS USERS
FROM USER_INFO
WHERE AGE >= 20 AND AGE <= 29
AND JOINED BETWEEN '2021-01-01' AND '2021-12-31';
```



# <span style="color:yellow">2024-02-23</span>

## <span style="color:royalblue">공부 계획</span>
- [x] **2월 20일** - SUM, MAX, MIN | GROUP BY 풀이 ✅ 2024-02-20
- [x] **2월 21일** - IS NULL | JOIN 풀이 ✅ 2024-02-21
- [x] **2월 22일** - String, Date 풀고 SQL 복습 및 PS 복습 ✅ 2024-02-22
- [ ] **2월 23일** - 최종 복습 및 컨디션 관리. (주변 오브젝트 정리 및 리허설)

내일 일어나서,
- [ ] [지원대비 문제풀이집](https://www.acmicpc.net/workbook/view/10475)을 모두 풀어봐야겠다.

- [ ] 아래 목록의 테크닉도 훑어보자.
1. **구현**  
2. **그리디**  
3. **분할정복**  
4. **완전탐색 (브루트 포스)**  
5. **유니온파인드**  
6. **DP**  
7. **BFS**  
8. **DFS**  
9. **서로소 집합**  
10. **라인 스위핑**

- 프로그래머스 SQL 고득점 [Kit](https://school.programmers.co.kr/learn/challenges?tab=sql_practice_kit)복습 

- [x] 프로그래머스에서 풀어야 할 것: ✅ 2024-02-23
1. [입국심사](https://school.programmers.co.kr/learn/courses/30/lessons/43238)
2. [징검다리](https://school.programmers.co.kr/learn/courses/30/lessons/43236)
3. [가장 먼 노드](https://school.programmers.co.kr/learn/courses/30/lessons/49189)
4. [순위](https://school.programmers.co.kr/learn/courses/30/lessons/49191)
5. ~~[방의 개수](https://school.programmers.co.kr/learn/courses/30/lessons/49190) (시간에 비해 비효율적)~~

- [ ] 시험 리허설, 오브젝트 정리


# 오늘은 최종 복습에 집중 

	문제를 꼼꼼하게 읽자.
	꼼꼼하게 읽지 않아서 생기는 시간 손실이
	10문제를 꼼꼼하게 읽는 시간보다 훨씬 크다.

	SQL 문제에 비트마스킹이랑 정규표현식은 진짜 아닌 것 같다

	입국심사 문제를 이진 탐색으로 풀 수 있다니.
	이런거 누가 생각해내는걸까

	정규표현식 배우고 말지...

	코테에서 algorithm 헤더의 함수들을 좀 적극적으로 사용하자.
	직접 구현하는 것은 교육적이었지만, 코테에선 시간을 아끼고 정확도를 높여야한다.




# 프로그래머스 알고리즘 고득점 Kit
### 입국심사
입국심사 문제는 각 심사관이 한명을 심사하는데 걸리는 시간이 담긴 배열 times가 주어지고, 심사를 받을 사람의 수 n이 주어질 때, 모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return하는 문제였다.

![image](https://velog.velcdn.com/images/bjy100/post/36bf126a-cde0-4ecd-baab-1b5c2e016ad0/image.png)


주요 Idea는. 이진 탐색(Binary Search)로 풀 수 있다는 것.
제일 빠르게 심사하는 심사관의 심사 시간을 ``start``로 두고(가능한 제일 빠른 심사 완료 시간)
제일 느리게 심사하는 심사관의 심사 시간 * 인원 수 n을 ``end``로 둔다 (가능한 제일 늦은 심사 완료 시간)

여기서 의문은, 코드의 효율을 위해서 
``int start = *min_element(times.begin(), times.end()) * n;`` 로 할 수 있다는 것이다.
하지만, 실제로는 저렇게 하면 안된다.

위의 코드는 **병렬 처리를 무시**하고 있다. 만약 1분만에 심사하는 심사관이 100명이 있다면. N <= 100을 처리하는데에 1분밖에 안 걸릴 것이다.

``int midTime = (start + end) / 2`` 를 시작으로, 해당 시간동안 각 심사관이 처리할 수 있는 인원 수를 구한다.
만약 인원 수가 문제의 기준에 충족되면, 이진 탐색의 원리와 똑같다. 인덱스를 낮춘다. 충족되지 않으면 인덱스를 높인다.

**아이디어만 생각할 수 있으면 쉬운 문제**

```cpp
long long solution(int n, vector<int> times) {
    ll answer = 0;
    ll minTime = *min_element(times.begin(), times.end());
    ll maxTime = *max_element(times.begin(), times.end()) * n;
    
    while (minTime <= maxTime) {
        ll midTime = (minTime + maxTime) / 2;
        ll people = 0;
        for (const auto& time : times) {
            people += midTime / time;
        }
        
        if (people >= n) {
            answer = midTime;
            maxTime = midTime - 1;
        } else if (people < n) {
            minTime = midTime + 1;
        }
    }
    return answer;
}
```



- - -


### 징검다리
징검다리 문제는 출발지점과 도착지점까지의 거리, 징검다리 돌의 위치 배열이 주어졌을 때,
징검다리 n개를 제거해서 바위간 거리의 최솟값의 가장 큰 값을 구하는 문제다.
즉 최대한 다리간의 간격을 넓게 만들어야 하는 문제.

![image](https://blog.kakaocdn.net/dn/EOlfs/btrpcN4gTDN/MI0GhQL7yHdnLPcOrMzPVK/img.png)


이 문제는 이진 탐색을 이용해서 풀 수 있다.
바로 mid값을 **허용하는 최소 바위 간격**으로 정의하고 검색하는 것.
출발지점은 0, 도착 지점은 distance로 설정하고 이전 바위와 현재 바위의 거리 차이를 계산해서, mid보다 작다면 현재 바위를 제거하도록 표시한다.

mid보다 크거나 같다면, 현재 바위를 제거하지 않고 계속 진행한다.

바위 탐색이 모두 끝나고 바위를 제거한 횟수가 목표 횟수보다 많다면, end의 값을 적절하게 조절해서 mid의 수치를 줄인다.

목표 횟수보다 적다면, start의 값을 적절하게 조절해서 mid 수치를 늘린다.

Idea만 있으면 간단한 로직이지만, 이 문제에 이분탐색을 활용하는 아이디어를 떠올리기가 쉽지 않다.
이분 탐색은 항상 start와 end의 조건을 지정할 때 모호하고 헷갈린다.

처음에는 아래와 같이 조건을 설정해서 틀렸다.
```cpp
        if (removeCount >= n) {
            end = mid - 1;
            answer = mid;
        } else if (removeCount < n) {
            start = mid + 1;
        }
```

``removeCount >= n`` 이라면, 현재 mid의 값이 문제의 조건에 알맞지 않다는 것.
근데 이때 answer = mid로 설정하는 것은 완전 오류다.

```cpp
        if (removeCount > n) {
            end = mid - 1;
        } else if (removeCount <= n) {
            start = mid + 1;
            answer = mid;
        }
```

이런식으로 ``removeCount > n`` 은 문제의 조건에 알맞지 않기 때문에, end값만 조정하고.
``removeCount <= n``이면 현재 문제의 조건에 알맞지만, 더 최적화된 값이 있을 수 있기에 start를 조정하고, answer을 업데이트 한다.

start와 end가 완전히 교차되는 순간, ``바위간 거리 최솟값의 최댓값``은 answer가 될 것이다.

```cpp
int solution(int distance, vector<int> rocks, int n) {
    int start = 1;
    int end = distance;
    sort(rocks.begin(), rocks.end());
    int answer = 0;
    while (start <= end) {
        int mid = (start + end) / 2;
        int lastRock = 0; // 출발 지점
        int removeCount = 0;
        
        // 바위 체크
        for (int i=0;i<rocks.size();++i) {
            if (rocks[i] - lastRock < mid) {
                removeCount++;
            } else {
                lastRock = rocks[i];
            }
        }
        
 
        // 도착지점 계산
        if (distance - lastRock < mid) removeCount++;
        
        if (removeCount > n) {
            end = mid - 1;
        } else if (removeCount <= n) {
            start = mid + 1;
            answer = mid;
        }
    }    
    return answer;
}
```


- - -


### 가장 먼 노드
가장 먼 노드 문제는 n개의 노드와 간선 정보가 주어졌을 때, 1번 노드로부터 가장 멀리 떨어진 노드가 몇개인지 return하는 기초적인 그래프 문제다.

adj\[\] 배열에 모든 간선 정보를 양방향으로 추가하고, Queue BFS로 탐색하면서 거리 배열을 업데이트 했다.

```cpp
int solution(int n, vector<vector<int>> edge) {
    int answer = 0;
    vector<vector<int>> adj(n+1, vector<int>());
    
    // 간선 정보 추가
    for (const auto e : edge) {
        int start = e[0];
        int end = e[1];
        adj[start].push_back(end);
        adj[end].push_back(start);
    }
    
    // BFS로 탐색
    queue<pair<int, int>> q; // 노드, 거리
    q.push({1, 0}); // 1번 노드, 거리 0
    vector<bool> visited(n+1); // 방문 배열
    vector<int> node_distance(n+1); // 노드별 거리 저장 배열
    
    visited[1] = true;
    
    while (!q.empty()) {
        int current_node = q.front().first;
        int current_weight = q.front().second;
        q.pop();
        
        // 거리 저장
        node_distance[current_node] = current_weight;
        
        for (const auto& next : adj[current_node]) {
            if (!visited[next]) {
                q.push({next, current_weight+1});
                visited[next] = true;
            }
        }
    }
    
    // 제일 먼 노드
    int max_dist = *max_element(node_distance.begin(), node_distance.end());
    int count = 0;
    for (int i=1;i<=n;++i) {
        if (node_distance[i] == max_dist) {
            ++count;
        }
    }
    return count;
}
```



- - -


### 순위
n명의 권투선수가 1:1 방식의 대회에 참여했다. 각 권투 선수 매치의 결과가 배열로 주어질 때, 순위를 확실하게 알 수 있는 권투 선수의 수를 return하는 문제다.

- 주요 아이디어
순위를 확실하게 알 수 있다는 것은 무엇일까? 본인을 제외한 모든 사람과 경기를 진행하면 나의 순위를 확실하게 알 수 있다.

따라서, n-1번의 경기를 하면 본인의 순위를 알 수 있다.
그런데 아래와 같은 상황이 가능하다.

``B가 C를 이겼고, A가 B를 이긴 경우.``
이런 경우에는 B가 C를 이겼는데, A가 B를 이겼기에 A가 1등, B가 2등, C가 3등이라고 할 수 있다.
하지만 A와 C는 서로 직접 대결한 적이 없다. **간접적으로** 결과에 영향을 미칠 뿐이다.
정확하게는 **B를 경유**해서 결과에 영향을 미친다.

이 문제는 주어진 경기 결과를 2차원 인접 행렬에 저장하고.
```cpp
    for (const auto& result : results) {
        graph[result[0]][result[1]] = 1;
        graph[result[1]][result[0]] = -1;
    }
```

플로이드-와샬 알고리즘 (쉬운말로 3중포문)으로 **특정 노드**를 경유해서 이기는 경우까지.
즉 A가 B를 이겼고, B가 C를 이겼을 때. A가 C를 이긴것으로 표시해야 한다.

```cpp
    for (int k=1;k<=n;++k) { // 거치는 사람
        for (int i=1;i<=n;++i) { // A
            for (int j=1;j<=n;++j) { // B
                if (graph[i][k] == 1 && graph[k][j] == 1) graph[i][j] = 1;
                else if (graph[i][k] == -1 && graph[k][j] == -1) graph[i][j] = -1;
            }
        }
    }
```

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc7lSdK%2Fbtr5aFq0MDv%2FBHx3OWKjHlDG82uknTDsSk%2Fimg.png)
	from dev-musa


이렇게 직접적인 경기 결과 이외에도, 간접적인. 그니까 누군가를 거쳐서 알 수 있는 경기 결과까지 2차원 인접 행렬에 저장할 수 있다.

마지막으로, 저장된 경기 결과가 n-1개가 아닌 (즉, null값이 있는) 선수는 순위를 정확하게 알 수 없다.


```cpp
int solution(int n, vector<vector<int>> results) {
    int answer = 0;
    vector<vector<int>> graph(n+1, vector<int>(n+1));
    // 플로이드-와셜
    for (const auto& result : results) {
        graph[result[0]][result[1]] = 1;
        graph[result[1]][result[0]] = -1;
    }
    
    for (int k=1;k<=n;++k) { // 거치는 사람
        for (int i=1;i<=n;++i) { // A
            for (int j=1;j<=n;++j) { // B
                if (graph[i][k] == 1 && graph[k][j] == 1) graph[i][j] = 1;
                else if (graph[i][k] == -1 && graph[k][j] == -1) graph[i][j] = -1;
            }
        }
    }
    
    for (int r=1;r<=n;++r) {
        int count = 0;
        for (int c=1;c<=n;++c) {
            if (graph[r][c] != 0) ++count;
        }
        if (count == n-1) ++answer;
    }
    
    return answer;
}
```




- - -



# SW마에스트로 지원대비 문제풀이


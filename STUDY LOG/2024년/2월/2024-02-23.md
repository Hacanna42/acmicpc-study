# <span style="color:yellow">2024-02-23</span>

## <span style="color:royalblue">공부 계획</span>
- [x] **2월 20일** - SUM, MAX, MIN | GROUP BY 풀이 ✅ 2024-02-20
- [x] **2월 21일** - IS NULL | JOIN 풀이 ✅ 2024-02-21
- [x] **2월 22일** - String, Date 풀고 SQL 복습 및 PS 복습 ✅ 2024-02-22
- [ ] **2월 23일** - 최종 복습 및 컨디션 관리. (주변 오브젝트 정리 및 리허설)

내일 일어나서, [지원대비 문제풀이집](https://www.acmicpc.net/workbook/view/10475)을 모두 풀어봐야겠다.

아래 목록의 테크닉도 훑어보자.
1. **구현**  
2. **그리디**  
3. **분할정복**  
4. **완전탐색 (브루트 포스)**  
5. **유니온파인드**  
6. **DP**  
7. **BFS**  
8. **DFS**  
9. **서로소 집합**  
10. **라인 스위핑**

프로그래머스에서 풀어야 할 것:
1. [입국심사](https://school.programmers.co.kr/learn/courses/30/lessons/43238)
2. [징검다리](https://school.programmers.co.kr/learn/courses/30/lessons/43236)
3. [가장 먼 노드](https://school.programmers.co.kr/learn/courses/30/lessons/49189)
4. [순위](https://school.programmers.co.kr/learn/courses/30/lessons/49191)
5. ~~[방의 개수](https://school.programmers.co.kr/learn/courses/30/lessons/49190) (시간에 비해 비효율적)~~
# 오늘은 최종 복습에 집중 

	문제를 꼼꼼하게 읽자.
	꼼꼼하게 읽지 않아서 생기는 시간 손실이
	10문제를 꼼꼼하게 읽는 시간보다 훨씬 크다.

	SQL 문제에 비트마스킹이랑 정규표현식은 진짜 아닌 것 같다

	입국심사 문제를 이진 탐색으로 풀 수 있다니.
	이런거 누가 생각해내는걸까

	정규표현식 배우고 말지...

	코테에서 algorithm 헤더의 함수들을 좀 적극적으로 사용하자.
	직접 구현하는 것은 교육적이었지만, 코테에선 시간을 아끼고 정확도를 높여야한다.



### 입국심사
입국심사 문제는 각 심사관이 한명을 심사하는데 걸리는 시간이 담긴 배열 times가 주어지고, 심사를 받을 사람의 수 n이 주어질 때, 모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return하는 문제였다.

![image](https://velog.velcdn.com/images/bjy100/post/36bf126a-cde0-4ecd-baab-1b5c2e016ad0/image.png)


주요 Idea는. 이진 탐색(Binary Search)로 풀 수 있다는 것.
제일 빠르게 심사하는 심사관의 심사 시간을 ``start``로 두고(가능한 제일 빠른 심사 완료 시간)
제일 느리게 심사하는 심사관의 심사 시간 * 인원 수 n을 ``end``로 둔다 (가능한 제일 늦은 심사 완료 시간)

여기서 의문은, 코드의 효율을 위해서 
``int start = *min_element(times.begin(), times.end()) * n;`` 로 할 수 있다는 것이다.
하지만, 실제로는 저렇게 하면 안된다.

위의 코드는 **병렬 처리를 무시**하고 있다. 만약 1분만에 심사하는 심사관이 100명이 있다면. N <= 100을 처리하는데에 1분밖에 안 걸릴 것이다.

``int midTime = (start + end) / 2`` 를 시작으로, 해당 시간동안 각 심사관이 처리할 수 있는 인원 수를 구한다.
만약 인원 수가 문제의 기준에 충족되면, 이진 탐색의 원리와 똑같다. 인덱스를 낮춘다. 충족되지 않으면 인덱스를 높인다.

**아이디어만 생각할 수 있으면 쉬운 문제**

```cpp
long long solution(int n, vector<int> times) {
    ll answer = 0;
    ll minTime = *min_element(times.begin(), times.end());
    ll maxTime = *max_element(times.begin(), times.end()) * n;
    
    while (minTime <= maxTime) {
        ll midTime = (minTime + maxTime) / 2;
        ll people = 0;
        for (const auto& time : times) {
            people += midTime / time;
        }
        
        if (people >= n) {
            answer = midTime;
            maxTime = midTime - 1;
        } else if (people < n) {
            minTime = midTime + 1;
        }
    }
    return answer;
}
```





### 징검다리
징검다리 문제는 출발지점과 도착지점까지의 거리, 징검다리 돌의 위치 배열이 주어졌을 때,
징검다리 n개를 제거해서 바위간 거리의 최솟값의 가장 큰 값을 구하는 문제다.
즉 최대한 다리간의 간격을 넓게 만들어야 하는 문제.

![image](https://blog.kakaocdn.net/dn/EOlfs/btrpcN4gTDN/MI0GhQL7yHdnLPcOrMzPVK/img.png)


이 문제는 이진 탐색을 이용해서 풀 수 있다.
바로 mid값을 **허용하는 최소 바위 간격**으로 정의하고 검색하는 것.
출발지점은 0, 도착 지점은 distance로 설정하고 이전 바위와 현재 바위의 거리 차이를 계산해서, mid보다 작다면 현재 바위를 제거하도록 표시한다.

mid보다 크거나 같다면, 현재 바위를 제거하지 않고 계속 진행한다.

바위 탐색이 모두 끝나고 바위를 제거한 횟수가 목표 횟수보다 많다면, end의 값을 적절하게 조절해서 mid의 수치를 줄인다.

목표 횟수보다 적다면, start의 값을 적절하게 조절해서 mid 수치를 늘린다.

Idea만 있으면 간단한 로직이지만, 이 문제에 이분탐색을 활용하는 아이디어를 떠올리기가 쉽지 않다.
이분 탐색은 항상 start와 end의 조건을 지정할 때 모호하고 헷갈린다.


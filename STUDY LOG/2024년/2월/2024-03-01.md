# <span style="color:yellow">2024-03-01</span>

##  <span style="color:violet">2차 공부 계획</span>
- [x] 2월 25일 - [문제풀이집 1](https://www.acmicpc.net/workbook/view/10475) 풀이 (RGB 거리 ~ 오르막 수) **8문제** ✅ 2024-02-26
- [x] 2월 26일 - [문제풀이집 1](https://www.acmicpc.net/workbook/view/10475) 풀이 (오르막 수 ~ N과 M 시리즈) **10문제** ✅ 2024-02-26
- [x] 2월 27일 - [문제풀이집 1](https://www.acmicpc.net/workbook/view/10475) 완성. (N과 M 시리즈 ~ 끝) **8문제** ✅ 2024-02-27
- [x] 2월 28일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254) 풀이 (연산자 끼워넣기 ~ 랜선 자르기) **11문제** ✅ 2024-02-28
- [x] 2월 29일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254)의 (파일합치기 ~ 쇠막대기) 풀이 + 고득점 킷 (스택, 힙) 복습 **6문제** ✅ 2024-02-29
- [ ] 3월 1일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254)의 (압축 ~ 벽 부수고 이동하기) 풀이 + 알고리즘(SQL) 킷 복습
- [ ] 3월 2일 - **시험 당일** [SQL 고득점 킷](https://school.programmers.co.kr/learn/challenges?tab=sql_practice_kit) 최종 복습.


- - -


### 압축 (1662)
```
압축되지 않은 문자열 S가 주어졌을 때, 이 문자열중 어떤 부분 문자열은 K(Q)와 같이 압축 할 수 있다. K는 한자리 정수이고, Q는 0자리 이상의 문자열이다. 이 Q라는 문자열이 K번 반복된다는 뜻이다. 압축된 문자열이 주어졌을 때, 이 문자열을 다시 압축을 푸는 프로그램을 작성하시오.
```

압축 문제는 Stack 자료 구조를 사용하거나, 재귀를 이용해서 풀 수 있는 문제다.
처음에 생각을 잘못했다. 문제를 보자마자 Stack을 쓰는 것 같긴 했는데 재귀적 요소가 있는 것 같았다. 풀다가 잘 안풀려서 문제 태그를 봤는데 스택 / 재귀 문제라고 써있었다..
근데 이 말은 스택 or 재귀 문제라는것이지 스택 and 재귀 문제가 아니었다.. 스택과 재귀를 동시에 쓰다가 점점 코드는 스파게티가 됐고 그냥 처음부터 새 마음으로 시작하려고 갈아 엎었다.

결국엔 stack으로 짰다. 정리만 잘 한다면 아이디어는 간단했다. 나는 stack에 문자열을 넣는 식으로 구현하려고 했는데 .. 이러면 개수 관리가 힘들었다.

결론은 stack에 문자열을 넣는 게 아니라, 숫자를 넣어야 됐다.
예를 들어 TC가 ``33(562(71(9)))``

1. 숫자를 만났을 때, 다음 인덱스가 '(' 가 아니라면 문자 그 자체라는 것. 따라서 stack에 1을 추가한다.
2. 다음 인덱스가 '('라면 곱셈 연산이니까, 1을 추가하지 않고 숫자 그 자체를 추가한다.
3. '(' 를 만났다면, 스택에 -1을 추가한다. (괄호를 구분하기 위해, 불가능한 숫자를 넣는다)
4. ')' 를 만났다면, -1을 만날때까지 pop() 하면서 1씩 카운트한다. -1을 만나면 .pop() -> .top() 해서 곱셈 숫자를 가져오고, 그만큼 연산해서 스택에 다시 push한다.

순회가 끝나고 스택에 저장되어있는 수를 모두 더하면 정답이 된다.
헷갈렸던 문제.

```cpp
#include <iostream>
#include <stack>
#include <string>
using namespace std;

/*
스택에 길이를 저장하자
*/
int total = 0;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    string s;
    cin >> s;
    stack<int> st;
    for (int i = 0; i < s.size(); ++i) {
        char cur = s[i];
        if (cur == '(') {
            st.push(-1);
        } else if (cur == ')') {
            int len = 0;
            while (st.top() != -1) {
                len += st.top();
                st.pop();
            }
            st.pop(); // '(' 제거
            int temp = st.top();
            st.pop();
            st.push(temp * len);
        } else {
            if (i + 1 < s.size() && s[i + 1] == '(') // 만약 압축에 사용되는 정수라면
                st.push(cur - '0');
            else
                st.push(1);
        }
    }

    while (!st.empty()) {
        total += st.top();
        st.pop();
    }
    cout << total;
    return 0;
}
```



- - -


### 같은 수로 만들기 (2374)
```
n(1 ≤ n ≤ 1,000)개의 자연수 A[1], A[2], A[3], …, A[n]이 있다. 이 자연수에 Add(i)라는 연산을 하면, A[i]가 1만큼 증가한다. 이때, A[i]만 증가하는 것이 아니고, A[i]의 좌우로 인접한 같은 수의 그룹이 한번에 1씩 증가한다. A[1]과 A[n]은 인접해 있지 않다.

예를 들어 수가 {1, 1, 1, 1, 3, 3, 1} 이었다고 해 보자. Add(2)를 하면 A[2]의 좌우로 인접한 같은 수가 1씩 증가하니까 {2, 2, 2, 2, 3, 3, 1}이 된다. 여기서 Add(4)를 하면 {3, 3, 3, 3, 3, 3, 1}이 되고, 여기서 Add(1)을 하면 {4, 4, 4, 4, 4, 4, 1}이 된다.

이와 같이 Add라는 연산을 사용하여 A[1] = A[2] = A[3] = … = A[n]이 되도록 하려 한다. 이때, 최소 회수로 Add연산을 사용하는 방법을 찾는 것이 문제이다.
```

Stack을 이용해서 푸는 문제. 여러개의 모의 케이스를 만들고 잘 관찰하면 풀 수 있었다.
1. 이전 수보다 현재 수가 크면, (현재 수 - 이전 수) 를 더하고 이전 수를 pop, 현재 수를 push한다.
2. 이전 수보다 현재 수가 작으면, 이전 수를 pop하고 현재 수를 push한다.
3. 마지막으로, 스택의 남은 모든 값에 수의 최댓값을 빼서 더한다.


```cpp
#include <algorithm>
#include <iostream>
#include <stack>
using namespace std;
typedef long long ll;
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    int N;
    cin >> N;
    stack<int> s;
    ll total = 0;
    int max = 0;
    for (int i = 0; i < N; ++i) {
        int temp;
        cin >> temp;
        max = std::max(max, temp);
        if (s.empty()) {
            s.push(temp);
        } else {
            int prev = s.top();
            if (temp > prev) {
                total += temp - prev;
                s.pop();
                s.push(temp);
            } else if (temp < prev) {
                s.pop();
                s.push(temp);
            }
        }
    }

    while (!s.empty()) {
        int num = s.top();
        s.pop();
        total += max - num;
    }

    cout << total;
    return 0;
}
```




- - -



### 북극곰은 괄호를 찢어 (25918)
```
극지 연구소에서 연구 중인 협이는 새로운 북극곰의 특성을 발견했다. 그것은 바로 북극곰이 
O와 X를 보면 ()와 )( 로 찢어버린다는 것이다.

협이는 이러한 북극곰의 특성을 이용하여 길이 N의 괄호 문자열 S를 만들고자 한다. 북극곰은 낮에 활동을 하기 때문에 낮에 돌아다니는 것은 위험하다. 때문에 협이는 매일 밤마다 활동할 수 있다. 밤에 협이는 문자열이 있으면 그 위에 O 또는 X를 원하는 만큼 놓을 수 있다. 그러면 낮에 북극곰이 와서 문자들을 모두 찢어 놓는다.

이때 원하는 문자열을 만들려면 최소 며칠이 걸리는지 계산해보자.
```

Stack을 이용한 문제, 각 반복이 끝났을 때 스택에 남아있는 문자 수가 걸리는 일과 같다는 아이디어다.
먼저 '()' 나 ')('가 있는지 확인하고, 있다면 스택에서 .pop() 한다. 없다면 받은 문자열 그대로 .push() 한다.

각 반복이 끝났을 때, stack.size()의 최대치가 걸리는 일 수다.
만약, 탐색이 완전히 끝났는데  stack이 비어있지 않다면 불가능하기에 "-1"을 출력한다.

```cpp
#include <algorithm>
#include <iostream>
#include <stack>
#include <string>
#include <vector>
using namespace std;

int main() {
    int N;
    string s;
    cin >> N >> s;
    stack<char> st;
    int result = 0;

    for (int i = 0; i < N; ++i) {
        if (st.empty()) {
            st.push(s[i]);
        } else {
            if (st.top() == '(' && s[i] == ')') {
                st.pop();
            } else if (st.top() == ')' && s[i] == '(') {
                st.pop();
            } else {
                st.push(s[i]);
            }
        }

        result = max(result, (int)st.size());
    }

    if (st.size() > 0)
        cout << "-1";
    else
        cout << result;
}
```




- - -


### 이분 그래프 (1707)
이분 그래프 문제는 간선과 정점 정보가 주어졌을 때, 이분그래프인지 판별하는 문제다.
이분 그래프는 그래프의 모든 정점을 두 그룹으로 나눌 수 있고, 같은 그룹에 속한 정점들 사이에는 간선이 존재하지 않는 그래프를 말한다.

![image](https://velog.velcdn.com/images/iubar17/post/db06228c-dd23-43ca-8a1b-2504ab139c5a/image.png)


DFS로 정점을 탐색하면서 이전 색과 반대로 칠하고, 탐색중에 이전 색과 겹치는 게 발견되면 false를 반환하도록 구현했다.

```cpp
#include <iostream>
#include <vector>
using namespace std;
vector<vector<int>> adj;
bool isBipartite;

void dfs(int node, vector<int> &visited, int color) {
    if (!isBipartite)
        return;
    visited[node] = color;
    for (const auto &next : adj[node]) {
        if (visited[next] == -1) {
            dfs(next, visited, 1 - color);
        } else if (visited[next] == color) {
            isBipartite = false;
            return;
        }
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    int TC;
    cin >> TC;
    while (TC--) {
        int V, E;
        cin >> V >> E;
        adj.assign(V + 1, vector<int>());
        vector<int> visited(V + 1, -1);
        isBipartite = true;
        for (int i = 0; i < E; ++i) {
            int from, to;
            cin >> from >> to;
            adj[from].push_back(to);
            adj[to].push_back(from);
        }

        for (int i = 1; i <= V && isBipartite; ++i) {
            if (visited[i] == -1) {
                dfs(i, visited, 0); // 방문하지 않은 정점에 대해 DFS 실행
            }
        }

        cout << (isBipartite ? "YES\n" : "NO\n");
    }
    return 0;
}
```




- - -



### 벽 부수고 이동하기 (골드 3)
드디어 내가 좋아하는 그래프 (DFS + BFS) 문제!
그래프 문제는 뭔가 ,, 재밌고 잘 풀린단 말이지... 그래프에 소질이 있는 것 같다.

```
N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다. 최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다.

만약에 이동하는 도중에 한 개의 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 한 개 까지 부수고 이동하여도 된다.

한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.

맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오.
```


최단 거리를 구하는 문제이기에 BFS를 사용했다. (BFS는 특성상, 가장 빨리 조건을 만족하는 노드의 값이 최단 거리다)

아이템을 사용했을때의 방문 배열과, 아이템을 사용하지 않았을때의 방문 배열을 나눠서 관리해줬고. Node 구조체를 만들어서 상태를 추적했다.

배열 입력을 받는 부분에서, 값이 띄어쓰기 구분으로 들어오지 않고 line으로 들어와서 string으로 처리하는 과정에, int로 변환하지 않고 바로 배열에 넣는 실수를 범했다. 계속 이상한 값이 뜨길래 코드를 꽤 갈았는데 단순한 실수였다.

실전에선 이런 사소한 실수는 하지 않았으면 좋겠다. 코드에 생각을 담자. 한줄 한줄 생각을 담아서 작성하자.

```cpp
#include <iostream>
#include <queue>
#include <string>
#include <vector>
using namespace std;

int dr[4] = {1, -1, 0, 0};
int dc[4] = {0, 0, 1, -1};

struct Node {
    int r;
    int c;
    bool itemUsed;
    int time;
};

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    int N, M;
    cin >> N >> M;
    cin.ignore();
    vector<vector<int>> map(N + 1, vector<int>(M + 1));
    for (int r = 1; r <= N; ++r) {
        string s;
        cin >> s;
        for (int c = 1; c <= M; ++c) {
            map[r][c] = s[c - 1] - '0';
        }
    }

    vector<vector<bool>> visited(N + 1, vector<bool>(M + 1, false));
    vector<vector<bool>> visited_with_item(N + 1, vector<bool>(M + 1, false));
    queue<Node> q;
    q.push({1, 1, false, 1});
    visited[1][1] = true;

    while (!q.empty()) {
        Node current = q.front();
        q.pop();
        int cur_r = current.r;
        int cur_c = current.c;
        int cur_time = current.time;
        bool cur_itemUsed = current.itemUsed;
        if (cur_r == N && cur_c == M) {
            cout << cur_time;
            return 0;
        }

        for (int i = 0; i < 4; ++i) {
            int next_r = cur_r + dr[i];
            int next_c = cur_c + dc[i];
            // VALID CHECK
            if (next_r > 0 && next_c > 0 && next_r <= N && next_c <= M) {
                // 아이템을 사용한 전과가 있을 때
                if (cur_itemUsed) {
                    if (map[next_r][next_c] == 0 && !visited_with_item[next_r][next_c]) { // 비어있으면
                        visited_with_item[next_r][next_c] = true;
                        q.push({next_r, next_c, cur_itemUsed, cur_time + 1});
                    }
                }
                // 없을 때
                else if (!cur_itemUsed) {
                    if (map[next_r][next_c] == 0 && !visited[next_r][next_c]) { // 비어있으면
                        visited[next_r][next_c] = true;
                        q.push({next_r, next_c, cur_itemUsed, cur_time + 1});
                    } else if (map[next_r][next_c] == 1 && !visited[next_r][next_c]) { // 막혀있고, 아이템을 쓰기로 결정
                        visited[next_r][next_c] = true;
                        q.push({next_r, next_c, true, cur_time + 1});
                    }
                }
            }
        }
    }

    // 탐색 실패
    cout << "-1";
    return 0;
}
```



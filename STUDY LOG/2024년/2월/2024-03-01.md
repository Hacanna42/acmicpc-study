# <span style="color:yellow">2024-03-01</span>

##  <span style="color:violet">2차 공부 계획</span>
- [x] 2월 25일 - [문제풀이집 1](https://www.acmicpc.net/workbook/view/10475) 풀이 (RGB 거리 ~ 오르막 수) **8문제** ✅ 2024-02-26
- [x] 2월 26일 - [문제풀이집 1](https://www.acmicpc.net/workbook/view/10475) 풀이 (오르막 수 ~ N과 M 시리즈) **10문제** ✅ 2024-02-26
- [x] 2월 27일 - [문제풀이집 1](https://www.acmicpc.net/workbook/view/10475) 완성. (N과 M 시리즈 ~ 끝) **8문제** ✅ 2024-02-27
- [x] 2월 28일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254) 풀이 (연산자 끼워넣기 ~ 랜선 자르기) **11문제** ✅ 2024-02-28
- [x] 2월 29일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254)의 (파일합치기 ~ 쇠막대기) 풀이 + 고득점 킷 (스택, 힙) 복습 **6문제** ✅ 2024-02-29
- [ ] 3월 1일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254)의 (압축 ~ 벽 부수고 이동하기) 풀이 + 알고리즘(SQL) 킷 복습
- [ ] 3월 2일 - **시험 당일** [SQL 고득점 킷](https://school.programmers.co.kr/learn/challenges?tab=sql_practice_kit) 최종 복습.


- - -


### 압축 (1662)
```
압축되지 않은 문자열 S가 주어졌을 때, 이 문자열중 어떤 부분 문자열은 K(Q)와 같이 압축 할 수 있다. K는 한자리 정수이고, Q는 0자리 이상의 문자열이다. 이 Q라는 문자열이 K번 반복된다는 뜻이다. 압축된 문자열이 주어졌을 때, 이 문자열을 다시 압축을 푸는 프로그램을 작성하시오.
```

압축 문제는 Stack 자료 구조를 사용하거나, 재귀를 이용해서 풀 수 있는 문제다.
처음에 생각을 잘못했다. 문제를 보자마자 Stack을 쓰는 것 같긴 했는데 재귀적 요소가 있는 것 같았다. 풀다가 잘 안풀려서 문제 태그를 봤는데 스택 / 재귀 문제라고 써있었다..
근데 이 말은 스택 or 재귀 문제라는것이지 스택 and 재귀 문제가 아니었다.. 스택과 재귀를 동시에 쓰다가 점점 코드는 스파게티가 됐고 그냥 처음부터 새 마음으로 시작하려고 갈아 엎었다.

결국엔 stack으로 짰다. 정리만 잘 한다면 아이디어는 간단했다. 나는 stack에 문자열을 넣는 식으로 구현하려고 했는데 .. 이러면 개수 관리가 힘들었다.

결론은 stack에 문자열을 넣는 게 아니라, 숫자를 넣어야 됐다.
예를 들어 TC가 ``33(562(71(9)))``

1. 숫자를 만났을 때, 다음 인덱스가 '(' 가 아니라면 문자 그 자체라는 것. 따라서 stack에 1을 추가한다.
2. 다음 인덱스가 '('라면 곱셈 연산이니까, 1을 추가하지 않고 숫자 그 자체를 추가한다.
3. '(' 를 만났다면, 스택에 -1을 추가한다. (괄호를 구분하기 위해, 불가능한 숫자를 넣는다)
4. ')' 를 만났다면, -1을 만날때까지 pop() 하면서 1씩 카운트한다. -1을 만나면 .pop() -> .top() 해서 곱셈 숫자를 가져오고, 그만큼 연산해서 스택에 다시 push한다.

순회가 끝나고 스택에 저장되어있는 수를 모두 더하면 정답이 된다.
헷갈렸던 문제.

```cpp
#include <iostream>
#include <stack>
#include <string>
using namespace std;

/*
스택에 길이를 저장하자
*/
int total = 0;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    string s;
    cin >> s;
    stack<int> st;
    for (int i = 0; i < s.size(); ++i) {
        char cur = s[i];
        if (cur == '(') {
            st.push(-1);
        } else if (cur == ')') {
            int len = 0;
            while (st.top() != -1) {
                len += st.top();
                st.pop();
            }
            st.pop(); // '(' 제거
            int temp = st.top();
            st.pop();
            st.push(temp * len);
        } else {
            if (i + 1 < s.size() && s[i + 1] == '(') // 만약 압축에 사용되는 정수라면
                st.push(cur - '0');
            else
                st.push(1);
        }
    }

    while (!st.empty()) {
        total += st.top();
        st.pop();
    }
    cout << total;
    return 0;
}
```



- - -


### 같은 수로 만들기 (2374)
```
n(1 ≤ n ≤ 1,000)개의 자연수 A[1], A[2], A[3], …, A[n]이 있다. 이 자연수에 Add(i)라는 연산을 하면, A[i]가 1만큼 증가한다. 이때, A[i]만 증가하는 것이 아니고, A[i]의 좌우로 인접한 같은 수의 그룹이 한번에 1씩 증가한다. A[1]과 A[n]은 인접해 있지 않다.

예를 들어 수가 {1, 1, 1, 1, 3, 3, 1} 이었다고 해 보자. Add(2)를 하면 A[2]의 좌우로 인접한 같은 수가 1씩 증가하니까 {2, 2, 2, 2, 3, 3, 1}이 된다. 여기서 Add(4)를 하면 {3, 3, 3, 3, 3, 3, 1}이 되고, 여기서 Add(1)을 하면 {4, 4, 4, 4, 4, 4, 1}이 된다.

이와 같이 Add라는 연산을 사용하여 A[1] = A[2] = A[3] = … = A[n]이 되도록 하려 한다. 이때, 최소 회수로 Add연산을 사용하는 방법을 찾는 것이 문제이다.
```

Stack을 이용해서 푸는 문제. 여러개의 모의 케이스를 만들고 잘 관찰하면 풀 수 있었다.
1. 이전 수보다 현재 수가 크면, (현재 수 - 이전 수) 를 더하고 이전 수를 pop, 현재 수를 push한다.
2. 이전 수보다 현재 수가 작으면, 이전 수를 pop하고 현재 수를 push한다.
3. 마지막으로, 스택의 남은 모든 값에 수의 최댓값을 빼서 더한다.


```cpp
#include <algorithm>
#include <iostream>
#include <stack>
using namespace std;
typedef long long ll;
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    int N;
    cin >> N;
    stack<int> s;
    ll total = 0;
    int max = 0;
    for (int i = 0; i < N; ++i) {
        int temp;
        cin >> temp;
        max = std::max(max, temp);
        if (s.empty()) {
            s.push(temp);
        } else {
            int prev = s.top();
            if (temp > prev) {
                total += temp - prev;
                s.pop();
                s.push(temp);
            } else if (temp < prev) {
                s.pop();
                s.push(temp);
            }
        }
    }

    while (!s.empty()) {
        int num = s.top();
        s.pop();
        total += max - num;
    }

    cout << total;
    return 0;
}
```




- - -



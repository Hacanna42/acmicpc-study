# <span style="color:yellow">2024-02-06</span>

오늘은
- 프로그래머스 코딩 고득점 [Kit](https://school.programmers.co.kr/learn/challenges?tab=algorithm_practice_kit)
을 풀겠다.

업랜디 한판하고 ㅎㅎ

### 오늘의 업랜디
```
30022 행사 준비 (실패 후 해결 - 그리디)
```


### 행사 준비
이 문제는 그리디를 이용해서 가장 최소의 총 구매 비용을 도출하는 문제였다
처음엔 DP인줄 알고 점화식을 찾았는데 각이 안 보였다. 그리고 그리디 문제임을 깨달았다.

하늘도 무심하시지,, 제한시간 30분이 끝나자마자 **AC**를 받았다 .. 에이씨..
이전에 계속 **WA**였던 이유는 로직 설계 오류였다.

A와 B의 기회비용을 제일 효율적으로 쓰는 것은, 둘의 가격차가 제일 많이 날 때 사는 것이라고 생각했다. 
따라서, std::abs(A-B)를 내림차순으로 정렬하고 순서대로 반복을 돌리면서 A와 B의 기회를 소진하면서 가격을 추가했다.

근데 문제는, A와 B의 가격이 똑같을 땐 어떻게 처리해야할까? 였다.
A와 B의 가격이 똑같으면 누구의 기회를 사용해서 물건을 구매해야할까? 나는 이것을 고민하다가 여기서 근거없이 A와 B 둘중 아무나 사게하면, 미래의 결과에 A가 사야 이득인 상황에서 B가 사야만 하는 상황이 올것이라고 판단했다.. (바보..)

사실은, 그리디를 활용한 알고리즘이기에 데이터가 정렬되어 있었고, A와 B의 가격이 똑같은 상황이라면 어차피 그 밑의 데이터는 더 이상의 유의미한 선택이 없었다.

나는 이것을 생각하지 못하고 가격이 똑같은 항목의 인덱스를 표시만 하고 skip 하는쪽으로 정했다, 그리고 마지막에 skip된 아이템의 price를 모두 합산했다. (이건 진짜 바보맞는듯)

시간이 2분만 더 있었으면 이 오류를 알아차리고 풀었을텐데, 하늘도 무심하시지 ㅎㅎ

```cpp
// 백준: 행사 준비
// https://www.acmicpc.net/problem/30022
// 2024-02-06

/* 그리디, (가격A - 가격B)의 절댓값을 내림차순 정렬
위에서부터 구매 */

#include <algorithm>
#include <cmath>
#include <iostream>
#include <utility>
#include <vector>
int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    int N, A, B;
    std::cin >> N >> A >> B;
    std::vector<std::pair<int, int>> prices; // A가격, B가격
    for (int i = 0; i < N; ++i) {
        int t1, t2;
        std::cin >> t1 >> t2;
        prices.push_back({t1, t2});
    }

    std::sort(prices.begin(), prices.end(), [](std::pair<int, int> &a, std::pair<int, int> &b) { return (std::abs(a.first - a.second) > std::abs(b.first - b.second)); });

    long long price = 0;
    for (const auto next : prices) {
        if (next.first == next.second) {
            price += next.first;
            if (A > 0)
                --A;
            else if (B > 0)
                --B;
        } else if (next.first > next.second) {
            // B의 값이 더 쌀 경우
            if (B != 0) {
                price += next.second;
                --B;
            } else {
                price += next.first;
                --A;
            }
        } else if (next.first < next.second) {
            // A의 값이 더  쌀 경우
            if (A != 0) {
                price += next.first;
                --A;
            } else {
                price += next.second;
                --B;
            }
        }
    }

    std::cout << price;

    return 0;
}
```


처음엔 오버플로우 문제인 줄 알고 메모리 제한이 넉넉하길래 보이는 int를 다 long long으로 바꿨다.


- - -


# <span style="color:yellow">2024-02-08</span>

- 실랜디 한판
- 프로그래머스 Kit 풀이
- SQL 풀이

- [x] 이중우선순위큐 ✅ 2024-02-09
- [ ] K번째수
- [ ] 가장 큰 수
- [ ] H-Index
- [ ] SQL 맛보기


### 오늘의 실랜디
```

```


### 오늘의 프로그래머스
```
이중우선순위큐 (Lv. 3)
K번째수 (Lv. 1)
```


### 이중우선순위큐
최솟값과 최댓값 삭제 연산, 삽입 연산을 지원하는 자료구조를 만드는 문제였다, 처음엔 vector로 구현했는데
vector.erase()와 vector.pop_back()의 존재를 모르고 있었다, iterator의 index 자체를 삭제할 수 있는 줄 알았으면 번거롭게 현재 최소 인덱스와 최대 인덱스를 추적하지 않고도 구현할 수 있었을텐데.

결국 어찌어찌 구현은 했다만, 구현 자체를 복잡하게 해서 무언가 오류가 있었나보다. 2개의 케이스에서 계속 실패가 떴다.

그래서 multiset으로 바꿨다. set은 기본적으로 자료를 정렬해서 저장하고, multiset은 set에 중복되는 요소를 넣을 수 있는 변형 컨테이너다.

이걸로 아주 간단하게 구현할 수 있었다.
요약하자면 STL을 잘 쓰면 쉬운 문제고, 안 쓰면 어려운 문제 ...

```cpp
vector<int> solution(vector<string> operations) {
    multiset<int> ms;

    for (string op : operations) {
        char command = op[0];
        int num = stoi(op.substr(2));

        if (command == 'I') {
            ms.insert(num);
        } else if (!ms.empty()) {
            if (num == 1) {
                // 최댓값 삭제
                auto it = prev(ms.end());
                ms.erase(it);
            } else if (num == -1) {
                // 최솟값 삭제
                ms.erase(ms.begin());
            }
        }
    }

    if (ms.empty()) {
        return {0, 0};
    } else {
        return {*ms.rbegin(), *ms.begin()};
    }
}
```


이렇게도 구현할 수 있다고 한다.
```cpp
class DoublePriorityQueue {
public:
    vector<int> queue;

    void insert(int number) {
        queue.push_back(number);
        sort(queue.begin(), queue.end()); // 삽입 후 정렬
    }

    void deleteMin() {
        if (!queue.empty()) {
            queue.erase(queue.begin()); // 최솟값 삭제
        }
    }

    void deleteMax() {
        if (!queue.empty()) {
            queue.pop_back(); // 최댓값 삭제 (정렬된 상태이므로 마지막 요소가 최댓값)
        }
    }

    vector<int> getResult() {
        if (queue.empty()) {
            return {0, 0};
        } else {
            return {queue.back(), queue.front()}; // 최댓값, 최솟값 반환
        }
    }
};
```



# <span style="color:yellow">2024-02-08</span>

- 실랜디 한판
- 프로그래머스 Kit 풀이
- SQL 풀이

- [x] 이중우선순위큐 ✅ 2024-02-09
- [ ] K번째수
- [ ] 가장 큰 수
- [ ] H-Index
- [ ] SQL 맛보기


### 오늘의 실랜디
```

```


### 오늘의 프로그래머스
```
이중우선순위큐 (Lv. 3)
K번째수 (Lv. 1)
가장 큰 수 (Lv. 2)
```


### 이중우선순위큐
최솟값과 최댓값 삭제 연산, 삽입 연산을 지원하는 자료구조를 만드는 문제였다, 처음엔 vector로 구현했는데
vector.erase()와 vector.pop_back()의 존재를 모르고 있었다, iterator의 index 자체를 삭제할 수 있는 줄 알았으면 번거롭게 현재 최소 인덱스와 최대 인덱스를 추적하지 않고도 구현할 수 있었을텐데.

결국 어찌어찌 구현은 했다만, 구현 자체를 복잡하게 해서 무언가 오류가 있었나보다. 2개의 케이스에서 계속 실패가 떴다.

그래서 multiset으로 바꿨다. set은 기본적으로 자료를 정렬해서 저장하고, multiset은 set에 중복되는 요소를 넣을 수 있는 변형 컨테이너다.

이걸로 아주 간단하게 구현할 수 있었다.
요약하자면 STL을 잘 쓰면 쉬운 문제고, 안 쓰면 어려운 문제 ...

```cpp
vector<int> solution(vector<string> operations) {
    multiset<int> ms;

    for (string op : operations) {
        char command = op[0];
        int num = stoi(op.substr(2));

        if (command == 'I') {
            ms.insert(num);
        } else if (!ms.empty()) {
            if (num == 1) {
                // 최댓값 삭제
                auto it = prev(ms.end());
                ms.erase(it);
            } else if (num == -1) {
                // 최솟값 삭제
                ms.erase(ms.begin());
            }
        }
    }

    if (ms.empty()) {
        return {0, 0};
    } else {
        return {*ms.rbegin(), *ms.begin()};
    }
}
```


이렇게도 구현할 수 있다고 한다.
```cpp
class DoublePriorityQueue {
public:
    vector<int> queue;

    void insert(int number) {
        queue.push_back(number);
        sort(queue.begin(), queue.end()); // 삽입 후 정렬
    }

    void deleteMin() {
        if (!queue.empty()) {
            queue.erase(queue.begin()); // 최솟값 삭제
        }
    }

    void deleteMax() {
        if (!queue.empty()) {
            queue.pop_back(); // 최댓값 삭제 (정렬된 상태이므로 마지막 요소가 최댓값)
        }
    }

    vector<int> getResult() {
        if (queue.empty()) {
            return {0, 0};
        } else {
            return {queue.back(), queue.front()}; // 최댓값, 최솟값 반환
        }
    }
};
```


### K번째수
K번째 수 문제는 정렬해야 할 배열과, 정렬 규칙이 담긴 배열이 주어졌을 때, 해당 규칙에 따라 정렬하는 매우 간단한 문제였다.

```cpp
vector<int> solution(vector<int> array, vector<vector<int>> commands) {
    vector<int> answer;
    for (const auto next : commands) {
        int i=next[0], j=next[1], k=next[2];
        vector<int> temp(array.begin()+i-1, array.begin()+j);
        sort(temp.begin(), temp.end());
        answer.push_back(temp[k-1]);
    }
    return answer;
}
```

### 가장 큰 수

가장 큰 수 문제는 숫자 배열이 주어졌을 때, 숫자를 문자열처럼 이어 붙일 수 있다고 가정했을 때, 만들 수 있는 가장 큰 수를 출력하는 문제였다.

처음엔, 숫자의 맨 처음 자리에서부터 비교하면서 작은쪽을 뒤로 보내는 방법으로 코딩했는데. 말 그대로 "숫자를 문자열처럼 이어 붙일 수 있다고 가정했을 때 큰 수" 를 그리디하게 판단하면 되는 것이었다. 

처음에 단순히 문자열로 사전 순 정렬하면 될것이라는 생각이 들긴 했는데, 정확한 문자열 사전순 정렬 기준을 잘 알지 못해서 시도하지 않았다.

```cpp
string solution(vector<int> numbers) {
    sort(numbers.begin(), numbers.end(), [](int a, int b) {
        string A = to_string(a);
        string B = to_string(b);
        return A + B > B + A;
    });
    
    string answer = "";
    for (int num : numbers) {
        answer += to_string(num);
    }
    
    if (answer[0] == '0') {
        return "0";
    }
    
    return answer;
}
```
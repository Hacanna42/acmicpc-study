# <span style="color:yellow">2024-02-08</span>

- 실랜디 한판
- 프로그래머스 Kit 풀이
- SQL 풀이

- [x] 이중우선순위큐 ✅ 2024-02-09
- [ ] K번째수
- [ ] 가장 큰 수
- [ ] H-Index
- [ ] SQL 맛보기


### 오늘의 실랜디
```

```


### 오늘의 프로그래머스
```
이중우선순위큐 (Lv. 3)
K번째수 (Lv. 1)
가장 큰 수 (Lv. 2)
```


### 이중우선순위큐
최솟값과 최댓값 삭제 연산, 삽입 연산을 지원하는 자료구조를 만드는 문제였다, 처음엔 vector로 구현했는데
vector.erase()와 vector.pop_back()의 존재를 모르고 있었다, iterator의 index 자체를 삭제할 수 있는 줄 알았으면 번거롭게 현재 최소 인덱스와 최대 인덱스를 추적하지 않고도 구현할 수 있었을텐데.

결국 어찌어찌 구현은 했다만, 구현 자체를 복잡하게 해서 무언가 오류가 있었나보다. 2개의 케이스에서 계속 실패가 떴다.

그래서 multiset으로 바꿨다. set은 기본적으로 자료를 정렬해서 저장하고, multiset은 set에 중복되는 요소를 넣을 수 있는 변형 컨테이너다.

이걸로 아주 간단하게 구현할 수 있었다.
요약하자면 STL을 잘 쓰면 쉬운 문제고, 안 쓰면 어려운 문제 ...

```cpp
vector<int> solution(vector<string> operations) {
    multiset<int> ms;

    for (string op : operations) {
        char command = op[0];
        int num = stoi(op.substr(2));

        if (command == 'I') {
            ms.insert(num);
        } else if (!ms.empty()) {
            if (num == 1) {
                // 최댓값 삭제
                auto it = prev(ms.end());
                ms.erase(it);
            } else if (num == -1) {
                // 최솟값 삭제
                ms.erase(ms.begin());
            }
        }
    }

    if (ms.empty()) {
        return {0, 0};
    } else {
        return {*ms.rbegin(), *ms.begin()};
    }
}
```


이렇게도 구현할 수 있다고 한다.
```cpp
class DoublePriorityQueue {
public:
    vector<int> queue;

    void insert(int number) {
        queue.push_back(number);
        sort(queue.begin(), queue.end()); // 삽입 후 정렬
    }

    void deleteMin() {
        if (!queue.empty()) {
            queue.erase(queue.begin()); // 최솟값 삭제
        }
    }

    void deleteMax() {
        if (!queue.empty()) {
            queue.pop_back(); // 최댓값 삭제 (정렬된 상태이므로 마지막 요소가 최댓값)
        }
    }

    vector<int> getResult() {
        if (queue.empty()) {
            return {0, 0};
        } else {
            return {queue.back(), queue.front()}; // 최댓값, 최솟값 반환
        }
    }
};
```


### K번째수
K번째 수 문제는 정렬해야 할 배열과, 정렬 규칙이 담긴 배열이 주어졌을 때, 해당 규칙에 따라 정렬하는 매우 간단한 문제였다.

```cpp
vector<int> solution(vector<int> array, vector<vector<int>> commands) {
    vector<int> answer;
    for (const auto next : commands) {
        int i=next[0], j=next[1], k=next[2];
        vector<int> temp(array.begin()+i-1, array.begin()+j);
        sort(temp.begin(), temp.end());
        answer.push_back(temp[k-1]);
    }
    return answer;
}
```

### 가장 큰 수

가장 큰 수 문제는 숫자 배열이 주어졌을 때, 숫자를 문자열처럼 이어 붙일 수 있다고 가정했을 때, 만들 수 있는 가장 큰 수를 출력하는 문제였다.

처음엔, 숫자의 맨 처음 자리에서부터 비교하면서 작은쪽을 뒤로 보내는 방법으로 코딩했는데. 말 그대로 "숫자를 문자열처럼 이어 붙일 수 있다고 가정했을 때 큰 수" 를 그리디하게 판단하면 되는 것이었다. 

처음에 단순히 문자열로 사전 순 정렬하면 될것이라는 생각이 들긴 했는데, 정확한 문자열 사전순 정렬 기준을 잘 알지 못해서 시도하지 않았다.

```cpp
string solution(vector<int> numbers) {
    sort(numbers.begin(), numbers.end(), [](int a, int b) {
        string A = to_string(a);
        string B = to_string(b);
        return A + B > B + A;
    });
    
    string answer = "";
    for (int num : numbers) {
        answer += to_string(num);
    }
    
    if (answer[0] == '0') {
        return "0";
    }
    
    return answer;
}
```


### H-Index
참신한 문제였다. 이진 탐색을 통해 풀어야 하는 줄 알았는데 그럴 필요 없었다.
```
문제 설명
H-Index는 과학자의 생산성과 영향력을 나타내는 지표입니다. 어느 과학자의 H-Index를 나타내는 값인 h를 구하려고 합니다. 위키백과1에 따르면, H-Index는 다음과 같이 구합니다.

어떤 과학자가 발표한 논문 n편 중, h번 이상 인용된 논문이 h편 이상이고 나머지 논문이 h번 이하 인용되었다면 h의 최댓값이 이 과학자의 H-Index입니다.

어떤 과학자가 발표한 논문의 인용 횟수를 담은 배열 citations가 매개변수로 주어질 때, 이 과학자의 H-Index를 return 하도록 solution 함수를 작성해주세요.
```

논문의 인용 횟수를 담은 배열 citations를 내림차순 정렬하면, 제일 왼쪽(첫번째) 인덱스의 요소는 자기보다 큰 수가 자신의 왼쪽에 있는 요소밖에 없다고 확신할 수 있다.

따라서, citations\[i\] 이상 인용된 논문의 수는 index + 1(자기자신 포함)이다.
``citations[i] < i+1`` 이 될때까지 answer을 업데이트 하면 풀 수 있는 문제였다.

코드는 매우 간단하지만, 식을 도출하는 과정이 꽤 복잡했다.

```cpp
int solution(vector<int> citations) {
    sort(citations.begin(), citations.end(), greater<int>());
    int answer = 0;
    for (int i=0;i<citations.size();++i) {
        // citation[i] 이상 인용된 논문이 i+1개임
        answer = i+1;
        if (citations[i] < i+1) {
            --answer;
            break;
        }
    }

    return answer;
}
```
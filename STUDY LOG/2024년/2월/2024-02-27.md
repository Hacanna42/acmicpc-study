# <span style="color:yellow">2024-02-27</span>

##  <span style="color:violet">2차 공부 계획</span>
- [x] 2월 25일 - [문제풀이집 1](https://www.acmicpc.net/workbook/view/10475) 풀이 (RGB 거리 ~ 오르막 수) **8문제** ✅ 2024-02-26
- [x] 2월 26일 - [문제풀이집 1](https://www.acmicpc.net/workbook/view/10475) 풀이 (오르막 수 ~ N과 M 시리즈) **10문제** ✅ 2024-02-26
- [ ] 2월 27일 - [문제풀이집 1](https://www.acmicpc.net/workbook/view/10475) 완성. (N과 M 시리즈 ~ 끝) **8문제**
- [ ] 2월 28일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254) 되는대로 풀기.. **총 70문제 🤯**
- [ ] 2월 29일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254)
- [ ] 3월 1일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254)
- [ ] 3월 2일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254)




### 가장 긴 증가하는 부분 수열
예전에 인상깊어했던 LIS 문제. DP 방식으로 푸는 문제다.
더 효율적으로 이분탐색의 lower_bound로도 풀 수 있다.

```cpp
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

// 교육적 의미로 구현 (이분탐색을 이용한 LIS)
int LIS(const vector<int> &nums) {
    vector<int> lis;
    for (int num : nums) {
        auto it = lower_bound(lis.begin(), lis.end(), num);
        if (it == lis.end())
            lis.push_back(num);
        else
            *it = num;
    }
    return lis.size();
}

int main() {
    int N;
    cin >> N;
    vector<int> dp(N, 1);
    vector<int> lis(N);
    for (int i = 0; i < N; ++i) {
        cin >> lis[i];
    }

    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < i; ++j) {
            if (lis[j] < lis[i])
                dp[i] = max(dp[j] + 1, dp[i]);
        }
    }

    cout << *max_element(dp.begin(), dp.end());
    // cout << LIS(lis); 
    return 0;
}
```





- - -


### 
# <span style="color:yellow">2024-02-26</span>

##  <span style="color:violet">2차 공부 계획</span>
- [x] 2월 25일 - [문제풀이집 1](https://www.acmicpc.net/workbook/view/10475) 풀이 (RGB 거리 ~ 오르막 수) **8문제** ✅ 2024-02-26
- [ ] 2월 26일 - [문제풀이집 1](https://www.acmicpc.net/workbook/view/10475) 풀이 (오르막 수 ~ N과 M 시리즈) **10문제**
- [ ] 2월 27일 - [문제풀이집 1](https://www.acmicpc.net/workbook/view/10475) 완성. (N과 M 시리즈 ~ 끝) **8문제**
- [ ] 2월 28일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254) 되는대로 풀기.. **총 70문제 🤯**
- [ ] 2월 29일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254)
- [ ] 3월 1일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254)
- [ ] 3월 2일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254)




- - -

### 합분해 (2225)
합분해 문제는 0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 문제였다.
``dp[K][N] = c``를 0~N의 정수중에 K개를 합해 N을 만드는 경우의 수 c로 정의하고.
``dp[1][i] = 1 (단, i = 0~N)`` 로 기본 사례를 설정했다. 선택할 수 있는 숫자가 하나밖에 없을 경우, N을 만드는 방법은 N 그 자체로 하나밖에 없기 때문이다.

그리고 처음엔 점화식이 직관적으로 다가오진 않았지만, 규칙으로 추측컨대. 그리고 DP가 하위 문제(특히 이전 문제)의 해로 현재 문제의 해를 계속 얻으면서 전체 문제 해를 얻는 방식이기에

``dp[K][N] = dp[K-1][N] + dp[K-1][N-1] + dp[K-1][N-2]...``  라는 것을 알았다.
즉 현재 해는 이전 해(이전 선택 수)에서 현재 N 이하의 숫자를 만드는 모든 경우의 수를 합한 경우라는 것을 알았다.

```cpp
#include <iostream>
#include <vector>
#define MOD 1'000'000'000
using namespace std;
typedef long long ll;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int N, K;
    cin >> N >> K;
    vector<vector<ll>> dp(K + 1, vector<ll>(N + 1, 0));
    for (int i = 0; i <= N; ++i) {
        dp[1][i] = 1;
    }
    // dp[K][N] = c | K개의 수로 N을 만드는 경우 c
    // dp[K][N] = dp[K-1][N] + dp[K-1][N-1] + dp[K-1][N-2]...

    for (int i = 2; i <= K; ++i) {
        for (int j = 0; j <= N; ++j) {
            for (int k = 0; k <= j; ++k) {
                dp[i][j] += dp[i - 1][k];
                dp[i][j] %= MOD;
            }
        }
    }

    cout << dp[K][N];
    return 0;
}
```



- - -



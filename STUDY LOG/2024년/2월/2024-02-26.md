# <span style="color:yellow">2024-02-26</span>

##  <span style="color:violet">2차 공부 계획</span>
- [x] 2월 25일 - [문제풀이집 1](https://www.acmicpc.net/workbook/view/10475) 풀이 (RGB 거리 ~ 오르막 수) **8문제** ✅ 2024-02-26
- [ ] 2월 26일 - [문제풀이집 1](https://www.acmicpc.net/workbook/view/10475) 풀이 (오르막 수 ~ N과 M 시리즈) **10문제**
- [ ] 2월 27일 - [문제풀이집 1](https://www.acmicpc.net/workbook/view/10475) 완성. (N과 M 시리즈 ~ 끝) **8문제**
- [ ] 2월 28일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254) 되는대로 풀기.. **총 70문제 🤯**
- [ ] 2월 29일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254)
- [ ] 3월 1일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254)
- [ ] 3월 2일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254)




- - -

### 합분해 (2225)
합분해 문제는 0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 문제였다.
``dp[K][N] = c``를 0~N의 정수중에 K개를 합해 N을 만드는 경우의 수 c로 정의하고.
``dp[1][i] = 1 (단, i = 0~N)`` 로 기본 사례를 설정했다. 선택할 수 있는 숫자가 하나밖에 없을 경우, N을 만드는 방법은 N 그 자체로 하나밖에 없기 때문이다.

그리고 처음엔 점화식이 직관적으로 다가오진 않았지만, 규칙으로 추측컨대. 그리고 DP가 하위 문제(특히 이전 문제)의 해로 현재 문제의 해를 계속 얻으면서 전체 문제 해를 얻는 방식이기에

``dp[K][N] = dp[K-1][N] + dp[K-1][N-1] + dp[K-1][N-2]...``  라는 것을 알았다.
즉 현재 해는 이전 해(이전 선택 수)에서 현재 N 이하의 숫자를 만드는 모든 경우의 수를 합한 경우라는 것을 알았다.

```cpp
#include <iostream>
#include <vector>
#define MOD 1'000'000'000
using namespace std;
typedef long long ll;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int N, K;
    cin >> N >> K;
    vector<vector<ll>> dp(K + 1, vector<ll>(N + 1, 0));
    for (int i = 0; i <= N; ++i) {
        dp[1][i] = 1;
    }
    // dp[K][N] = c | K개의 수로 N을 만드는 경우 c
    // dp[K][N] = dp[K-1][N] + dp[K-1][N-1] + dp[K-1][N-2]...

    for (int i = 2; i <= K; ++i) {
        for (int j = 0; j <= N; ++j) {
            for (int k = 0; k <= j; ++k) {
                dp[i][j] += dp[i - 1][k];
                dp[i][j] %= MOD;
            }
        }
    }

    cout << dp[K][N];
    return 0;
}
```



- - -

### 동적 프로그래밍(Dynamic Programming, DP)
너무 중요해서 다시 언급한다.

##### 1. 문제 이해하기
- **문제를 완전하게 이해한다:** 문제의 조건과 요구사항, 주어진 예시를 통해 어떻게 문제가 해결되어야 하는지 분석하고 관계 파악하기.

##### 2. 작은 문제로 나누기
- **문제를 작은 문제로 나눈다**: DP는 큰 문제를 작은 하위 문제로 나누고, 하위 문제의 해결을 통해 전체 문제의 해결책을 도출하는 방법이다. 각 하위 문제가 어떻게 전체 문제에 기여하는지 고려해 본다. 현재 해가 이전 해의 어떤 부분에 영향을 받는지, 어떤 상태를 dp에 메모해야 하는지 고려한다.

##### 3. 점화식 찾기
- **기본 사례 식별하기**: 모든 DP 문제는 하나 이상의 기본 사례(base case)를 가지고 있다. 기본 사례는 직접적으로 해결할 수 있는 가장 작은 문제다.
- **점화식을 도출하기**: 점화식(recurrence relation)은 현재 문제의 해를 이전에 해결한 문제들의 해를 통해 어떻게 구할 수 있는지 나타낸다. 각 단계에서 가능한 선택을 고려하고, 각 선택이 결과에 어떠한 영향을 미치는 지 분석한다.

##### 4. 예제로 시뮬레이션하기
- **작은 문제로 시뮬레이션하기**: 문제를 해결하는 절차를 몇 가지 작은 예제에 적용해본다. 이를 통해 점화식의 올바름을 검증할 수 있다.

- - -

### 동물원 (1309)
동물원 문제는 2\*N 배열에 사자를 가로 세로로 인접하지 않게 배치하는 경우의 수가 몇가지인지 알아내는 DP 문제다.
어려웠고 교육적이었다.

고민을 정말 많이 했다. 먼저 아래와 같은 사고과정을 거쳤다.

1. dp\[N\]을 2\*N에서의 경우의 수라고 정의했다.
2. 기본 사례를 아래와 같이 설정했다. (0은 빈칸, 1은 사자)
```cpp
dp[0] = 1; // 아무것도 놓지 않는 경우의 수 1
dp[1] = 3; // (0,0) (1,0) (0,1) 경우의 수 3
```
3. dp\[2\]의 기본 사례를 고려할 때, 현재 경우의 수가 이전 행에서 사자가 어떻게 놓였냐에 따라 파생된다는 것을 알았다.


![image](https://upload.acmicpc.net/b53cf470-0cb0-490b-870a-702cf2c93fce/-/preview/)
	 from joonsooan


4. dp\[i\]\[h\] 를 i번째 인덱스에서 어떤 방법(h)로 놓았을때의 경우의 수로 정의했다 (h가 0이면 (0,0).   1이면 (1,0).    2면 (0,1).

```cpp
dp[0][0-2] = 1; // 아무것도 놓지 않는 경우의 수 1. 로직적 허용..?
dp[1][0-2] = 1; // 처음 시작에 각각 놓는 경우의 수는 1이다.
dp[2][0] = 3; // 왜냐하면, 빈칸을 놓으려면 이전것에 영향을 안 받으니까. 이전의 경우의 수 그대로
dp[2][1] = 2; // 윗 줄이 1번이 아니어야 한다.
dp[2][2] = 2; // 윗 줄이 2번이 아니어야 한다.
```

5. 규칙을 알아냈다.
```cpp
dp[i][0] = dp[i-1][0] + dp[i-1][1] + dp[i-1][2];
dp[i][1] = dp[i-1][0] + dp[i-1][2];
dp[i][2] = dp[i-1][0] + dp[i-1][1];
```


이런 사고과정을 거쳐 알아낸 위의 점화식을 사용해서도 풀 수 있었지만, 질문 게시판을 가보니 다른 사람들의 해답은 조금 달랐다.


```cpp
dp[i][0] = dp[i-1][0] + dp[i-1][1] + dp[i-1][2];
dp[i][1] = dp[i-1][0] + dp[i-1][2];
dp[i][2] = dp[i-1][0] + dp[i-1][1];

< 에서, >

dp[i] = dp[i][0] + dp[i][1] + dp[i][2];

< 라고하면 >

dp[i] = (dp[i-1][0] + dp[i-1][1] + dp[i-1][2]) + (dp[i-1][0] + dp[i-1][2]) + (dp[i-1][0] + dp[i-1][1]);

< 를 정리하면 >

dp[i] = 2 * (dp[i-1][0] + dp[i-1][1] + dp[i-1][2]) + dp[i-1][0];

< 여기서 >

dp[i-1][0] + dp[i-1][1] + dp[i-1][2] 는 dp[i] = dp[i][0] + dp[i][1] + dp[i][2]; 

< 이기 때문에 >

dp[i-1]

< 따라서 >

dp[i] = 2 * dp[i-1] + dp[i-1][0];

< 여기서 > 

dp[i-1][0]은. i-1 입장에서 dp[i-1][0] + dp[i-1][1] + dp[i-1][2]; 기 때문에
dp[i-1][0] = dp[i-2];

< 즉 >

dp[i] = 2*dp[i-1]+dp[i-2];
```



##### 코드
```cpp
#include <iostream>
using namespace std;

int main() {
    int dp[100001] = {1, 3};
    int N;
    cin >> N;
    for (int i = 2; i <= N; ++i) {
        dp[i] = (dp[i - 1] * 2 + dp[i - 2]) % 9901;
    }
    cout << dp[N];
    return 0;
}
```


**너무나도 교육적인 문제**
수학적인 패턴도 들어가 있고, DP 점화식을 축소하는 부분이 인상깊다.
DP는 모르겠으면 TC를 나열해보고 패턴을 찾아서 점화식을 때려 맞출수도 있지만. 그건 마음에 들지 않아서 이해가 될 때까지 계속 탐구하느라 시간을 오래 썼다.

이 문제에 거의 2시간을 쓴 것 같다.
Valuable

- - -




### 2007년 (1924)
2007년의 날짜가 입력으로 주어지면, 요일을 반환하는 간단한 시뮬레이션 문제.
근데, DP 문제가 모아져있는 곳에 갑자기 시뮬 문제가 나와서 당황했다.

"이게.. DP라고..? 대체 어디서 문제를 나눌 수 있지?" 잠깐 이랬다.

```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

int main() {
    int calendar[13][32];
    int month = 1;
    int day = 1;
    int last_day_of_month[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    int week_counter = 0; // 월 화 수 목 금 토 일
    string week_str[7] = {"MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"};

    while (month != 13) {
        calendar[month][day] = week_counter % 7;
        ++week_counter;
        if (++day > last_day_of_month[month]) {
            month++;
            day = 1;
        }
    }

    int x, y;
    cin >> x >> y;
    cout << week_str[calendar[x][y]];

    return 0;
}
```

시뮬 문제는 가볍게 컷

- - -


### 
# <span style="color:yellow">2024-02-14</span>

오늘은
- 프로그래머스 동적계획법(Dynamic Programming) 풀이
- 업랜디 1판
- SQL 강의 듣기


### 오늘의 업랜디
```

```

### 오늘의 프로그래머스
```
정수 삼각형 (Lv. 3)
```


- - -

### 정수 삼각형
정수 삼각형 문제는, 전형적인 파스칼의 삼각형 문제였다. 전형적인이라곤 하지만 실제로 풀어본 건 처음인듯. 하지만 아이디어나 문제 자체가 어렵진 않아서 쉽게 풀었다.

처음 점화식 접근은 아래와 같은 flow로 했다.
``dp[i] = c`` 를 i층까지의 최댓값으로 설정하고 생각해봤는데, 이렇게 하면 탐욕적인 접근법과 다를 게 없었다. 이 문제에서 중요한 것은 현재 선택하는 경로에 따라서, 이후에 선택할 수 있는 숫자들이 줄어들 기 때문에, 매 단계에서 그리디하게 선택하면 안됐다. 따라서 2차원 배열로 해야겠다는 생각이 들었고. 결론은
``dp[i][j] = c``는 i층의 j번째를 고려했을때의 최댓값으로 설정했다.
Edge case를 적절하게 처리해주면 쉽게 풀 수 있었다.
```cpp
int solution(vector<vector<int>> triangle) {
    vector<vector<int>> dp(triangle.size(), vector<int>(triangle.size()));
    dp[0][0] = triangle[0][0];
    for (int i=1;i<triangle.size();++i) {
        for (int j=0; j<=i; ++j) {
            if (j==0) dp[i][j] = dp[i-1][j] + triangle[i][j];
            else if (j==i) dp[i][j] = dp[i-1][j-1] + triangle[i][j];
            else dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j];
        }
    }
    int answer = 0;
    for (int i=0;i<dp[triangle.size()-1].size();++i) {
        answer = max(answer, dp[triangle.size()-1][i]);
    }
    
    return answer;
}
```


- - -


### 등굣길
M\*N 크기의 맵에서, 오른쪽이나 아래로만 이동할 수 있다고 할 때 목적지로 도달하는 경로의 수를 구하는 문제였다. 단, 물 웅덩이를 피해서 가야한다.

처음에 오른쪽이나 아래로만 이동할 수 있다는 걸 놓쳐서 점화식을 이상하게 생각했다.
그리고, 물 웅덩이의 경우 -1로 고정해놓는 방법을 썼는데. 너무 생각이 짧았다. 이렇게 하면 물 웅덩이를 피하는 과정에서 오히려 주변의 값이 줄어들 수 있었다. 해답은 -1로 고정은 하되, 나중에 물 웅덩이를 만났을 때 0으로 바꿔서 주변에 아무런 영향을 끼치지 않도록 설정하는 것이었다.

그래도 이제 DP문제를 몇번 풀어서 그런지 어느정도의 점화식 구성이 보인다.
하지만 아직 꾸준한 연습이 필요해 보인다.

```cpp
using namespace std;
#define MOD 1'000'000'007

int solution(int m, int n, vector<vector<int>> puddles) {
    /*
    dp[i][j] 는 (i, j) 까지 도달할 수 있는 경로의 수.
    시작점 : (1, 1) 도착 : (M, N)
    */
    vector<vector<int>> dp(m+1, vector<int>(n+1, 0));
    dp[1][1] = 1;
    
    for (int i=0;i<puddles.size();++i) {
        dp[puddles[i][0]][puddles[i][1]] = -1;
    }
    
    for (int i=1;i<=m;++i) {
        for (int j=1;j<=n;++j) {
            if (dp[i][j] == -1) {
                dp[i][j] = 0;
                continue; // 물 웅덩이 무빙
            }
            if (i > 1) dp[i][j] += dp[i-1][j] % MOD;
            if (j > 1) dp[i][j] += dp[i][j-1] % MOD;
            dp[i][j] %= MOD;
        }
    }
    return dp[m][n];
}
```


결론적으로 문제 파악만 잘하면 쉽게 정의내릴 수 있는 문제였다.
``각 칸에 대해 왼쪽과 위쪽에서 오는 경로의 수를 합산하는 문제. 단, 물웅덩이가 있는 칸은 경로에서 제외한다.``


- - -


### 사칙연산

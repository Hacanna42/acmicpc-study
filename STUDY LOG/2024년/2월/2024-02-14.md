# <span style="color:yellow">2024-02-14</span>

오늘은
- 프로그래머스 동적계획법(Dynamic Programming) 풀이
- 업랜디 1판
- SQL 강의 듣기


### 오늘의 업랜디
```

```

### 오늘의 프로그래머스
```
정수 삼각형 (Lv. 3)
```


- - -

### 정수 삼각형
정수 삼각형 문제는, 전형적인 파스칼의 삼각형 문제였다. 전형적인이라곤 하지만 실제로 풀어본 건 처음인듯. 하지만 아이디어나 문제 자체가 어렵진 않아서 쉽게 풀었다.

처음 점화식 접근은 아래와 같은 flow로 했다.
``dp[i] = c`` 를 i층까지의 최댓값으로 설정하고 생각해봤는데, 이렇게 하면 탐욕적인 접근법과 다를 게 없었다. 이 문제에서 중요한 것은 현재 선택하는 경로에 따라서, 이후에 선택할 수 있는 숫자들이 줄어들 기 때문에, 매 단계에서 그리디하게 선택하면 안됐다. 따라서 2차원 배열로 해야겠다는 생각이 들었고. 결론은
``dp[i][j] = c``는 i층의 j번째를 고려했을때의 최댓값으로 설정했다.
Edge case를 적절하게 처리해주면 쉽게 풀 수 있었다.
```cpp
int solution(vector<vector<int>> triangle) {
    vector<vector<int>> dp(triangle.size(), vector<int>(triangle.size()));
    dp[0][0] = triangle[0][0];
    for (int i=1;i<triangle.size();++i) {
        for (int j=0; j<=i; ++j) {
            if (j==0) dp[i][j] = dp[i-1][j] + triangle[i][j];
            else if (j==i) dp[i][j] = dp[i-1][j-1] + triangle[i][j];
            else dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j];
        }
    }
    int answer = 0;
    for (int i=0;i<dp[triangle.size()-1].size();++i) {
        answer = max(answer, dp[triangle.size()-1][i]);
    }
    
    return answer;
}
```


- - -


### 등굣길
M\*N 크기의 맵에서, 오른쪽이나 아래로만 이동할 수 있다고 할 때 목적지로 도달하는 경로의 수를 구하는 문제였다. 단, 물 웅덩이를 피해서 가야한다.

처음에 오른쪽이나 아래로만 이동할 수 있다는 걸 놓쳐서 점화식을 이상하게 생각했다.
그리고, 물 웅덩이의 경우 -1로 고정해놓는 방법을 썼는데. 너무 생각이 짧았다. 이렇게 하면 물 웅덩이를 피하는 과정에서 오히려 주변의 값이 줄어들 수 있었다. 해답은 -1로 고정은 하되, 나중에 물 웅덩이를 만났을 때 0으로 바꿔서 주변에 아무런 영향을 끼치지 않도록 설정하는 것이었다.

그래도 이제 DP문제를 몇번 풀어서 그런지 어느정도의 점화식 구성이 보인다.
하지만 아직 꾸준한 연습이 필요해 보인다.

```cpp
using namespace std;
#define MOD 1'000'000'007

int solution(int m, int n, vector<vector<int>> puddles) {
    /*
    dp[i][j] 는 (i, j) 까지 도달할 수 있는 경로의 수.
    시작점 : (1, 1) 도착 : (M, N)
    */
    vector<vector<int>> dp(m+1, vector<int>(n+1, 0));
    dp[1][1] = 1;
    
    for (int i=0;i<puddles.size();++i) {
        dp[puddles[i][0]][puddles[i][1]] = -1;
    }
    
    for (int i=1;i<=m;++i) {
        for (int j=1;j<=n;++j) {
            if (dp[i][j] == -1) {
                dp[i][j] = 0;
                continue; // 물 웅덩이 무빙
            }
            if (i > 1) dp[i][j] += dp[i-1][j] % MOD;
            if (j > 1) dp[i][j] += dp[i][j-1] % MOD;
            dp[i][j] %= MOD;
        }
    }
    return dp[m][n];
}
```


결론적으로 문제 파악만 잘하면 쉽게 정의내릴 수 있는 문제였다.
``각 칸에 대해 왼쪽과 위쪽에서 오는 경로의 수를 합산하는 문제. 단, 물웅덩이가 있는 칸은 경로에서 제외한다.``


- - -


### 사칙연산
사칙연산 문제는 arr에 식의 정보가 주어지고, 괄호를 아무렇게나 씌워서 만들 수 있는 가장 큰 수를 찾아내는 문제다.
```
문자열 형태의 숫자와, 더하기 기호("+"), 뺄셈 기호("-")가 들어있는 배열 arr가 매개변수로 주어질 때, 서로 다른 연산순서의 계산 결과 중 최댓값을 return 하도록 solution 함수를 완성해 주세요.
```

**매우 어려웠다**

``<pair>dp[start][end]``를 start부터 end까지의 최소/최댓값이라고 가정하고, 분할정복 형식으로 각 모든 구역에 대해 최솟값/최댓값 쌍을 갱신해나갔다. 항상 최댓값이 아니라 최솟값도 같이 갱신해야하는 이유는, 다음 연산자가 + 인지 -인지에 따라 더 큰 수를 만들 수 있는 방법이 달라지기 때문이다, 예를 들어서 다음 연산자가 -라면 이전 값의 최댓값 - 현재 최솟값을 해야 가장 큰 수를 만들 수 있다. 

#### for문 구성
3중 포문으로 모든 구역에 대한 순회를 할 수 있었다.
모든 구역에 대해 연산자를 기준으로 좌우로 나눠서 계산하고, 그 값을 적절하게 조합해서 해당 구역의 최솟값과 최댓값을 구할 수 있다.

먼저 구역을 설정하는 for문 len을 제일 외부에 감싸고, 시작 지점과 끝 지점을 표시하는 start-end. 그리고 start-end 사이에서 구역을 분할하는 mid로 구성했다.

```cpp
for (int len=1;len<=n;++len) {
    for (int start=0;start+len<n;++start) {
	    int end = start + len;
        for (int mid=start;mid<end;++mid) {
        }
    }
}
```
``dp[start][mid], dp[mid+1][end]``의 경우 이전 for문에서 새로운 값으로 갱신됐을 값이기 때문에, 매 반복마다 ``dp[start][mid].first, dp[start][mid].second`` 식으로 분할된 mid 기준으로 왼쪽의 최소/최댓값과 오른쪽의 최소/최댓값을 구할 수 있다.
그리고 새로운 dp 초기화: ``dp[start][end]``에 대해서는 현재의 연산자에 따라서 좌항의 최댓값 + 우항의 최댓값을 하던지, 좌항의 최댓값 - 우항의 최솟값식으로 새로운 dp의 최솟값과 최댓값을 구할 수 있었다.

이렇게 모든 길이에 대해 반복하면, ``dp[0][0], dp[1][1] ...``부터 시작해서 ``dp[0][1], dp[1][2], dp[2][3] ...`` 에 대해 구할 수 있고, 이렇게 작게 나누어진 부분 문제로 더 큰 길이 ``dp[1][3], dp[2][4] ..`` 에 대한 최소/최댓값을 구할 수 있다.

최종적으로 정답은 ``dp[0][n-1].second`` 가 된다.

```cpp
int solution(vector<string> arr) {
    int n = arr.size() / 2 + 1;
    vector<vector<pair<int, int>>> dp(n, vector<pair<int, int>>(n, {INT_MAX, INT_MIN}));
    for (int i = 0; i < arr.size(); i += 2) {
        int num = stoi(arr[i]);
        dp[i / 2][i / 2] = {num, num};
    }

    for (int len = 1; len <= n; ++len) {
        for (int start = 0; start + len < n; ++start) {
            int end = start + len;
            // dp[start][end] = {INT_MAX, INT_MIN};
            for (int mid = start; mid < end; ++mid) {
                int leftMin = dp[start][mid].first;
                int leftMax = dp[start][mid].second;
                int rightMin = dp[mid + 1][end].first;
                int rightMax = dp[mid + 1][end].second;

                char op = arr[mid * 2 + 1][0];

                if (op == '-') {
                    dp[start][end].first = min(dp[start][end].first,
                    leftMin - rightMax);
                    dp[start][end].second = max(dp[start][end].second,
                    leftMax - rightMin);
                } else {
                    dp[start][end].first = min(dp[start][end].first,
                    leftMin + rightMin);
                    dp[start][end].second = max(dp[start][end].second,
                    leftMax + rightMax);
                }
            }
        }
    }

    return dp[0][n - 1].second;
}
```

상당히 복잡하고, 실수하거나 헷갈릴 여지가 많은 어려운 문제였다.


- - -


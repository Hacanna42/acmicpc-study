# <span style="color:yellow">2024-02-08</span>

- 다리를 지나는 트럭을 두번 더 풀었다. 
- 업랜디 한판
- 프로그래머스 스택/큐 복습
- 프로그래머스 힙 풀이


# 오늘의 업랜디
```
19949 영재의 시험 (실패 후 해결 - 브루트포스 + 백트래킹)
```


# 오늘의 프로그래머스
```
프로그래머스 스택/큐 모두 복습

```
### 영재의 시험
영재의 시험 문제는 영재가 세 문제를 연속으로 같은 숫자를 찍지는 않을 때, 10개의 문제를 모두 찍어서 맞출 확률을 구하는 문제. 결국에 확률이기 때문에 굳이 정답지 정보를 비교해야하나 생각했지만, 세 문제를 연속으로 같은 숫자로 찍지 않는다는 조건이 있어서 꼭 비교해야 했다. 

재귀 조합 순열 next_permutation 이런거 써서 푸는거다 라고 직감은 바로 왔었다.
next_permutation을 쓰려고 했는데, next_permutation은 주어진 수열에서 다음 사전순 정렬을 찾아주는 것이기에, 1~5의 조합으로 길이 10의 모든 가능한 수열을 만들어야하는 해당 문제와는 어울리지 않았다.

따라서, 재귀를 썼다. 3개 연속으로 같은 숫자를 찍었다는 것을 어떻게 가려낼지 고려하다가, prev-1과 prev-2를 만들었는데 아무리 생각해봐도 이건 아닌 것 같아서 갈아 엎었다.

그냥 bool check() 함수를 만들어서 매번 체크했다.

```cpp
// 백준: 영재의 시험
// https://www.acmicpc.net/problem/19949
// 2024-02-08

#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

void generateSequence(vector<int> &sequence);

vector<int> answer;
int counter = 0;

bool check(const vector<int> &v) {
    for (auto i = 0; i < v.size() - 2; ++i) {
        if (v[i] == v[i + 1] && v[i + 1] == v[i + 2])
            return false;
    }
    return true;
}

void generateSequence(vector<int> &sequence) {
    if (sequence.size() == 10) {
        if (check(sequence)) {
            int correct = 0;
            for (int i = 0; i < 10; ++i) {
                if (sequence[i] == answer[i]) {
                    correct++;
                }
            }
            if (correct >= 5)
                counter++;
        }
        return;
    }

    for (int i = 1; i <= 5; ++i) {
        sequence.push_back(i);
        generateSequence(sequence);
        sequence.pop_back();
    }
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    for (int i = 0; i < 10; ++i) {
        int temp;
        cin >> temp;
        answer.push_back(temp);
    }

    vector<int> s;
    generateSequence(s);

    cout << counter;

    return 0;
}
```




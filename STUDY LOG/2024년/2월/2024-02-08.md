# <span style="color:yellow">2024-02-08</span>

- 다리를 지나는 트럭을 두번 더 풀었다. 
- 업랜디 한판
- 프로그래머스 스택/큐 복습
- 프로그래머스 힙 풀이


# 오늘의 업랜디
```
19949 영재의 시험 (실패 후 해결 - 브루트포스 + 백트래킹)
```

- [ ] K번째수
- [ ] 가장 큰 수
- [ ] H-Index

# 오늘의 프로그래머스
```
프로그래머스 스택/큐 모두 복습
더 맵게 (Lv. 2)
디스크 컨트롤러 (Lv. 2)
이중우선순위큐 (Lv. 3)
```
### 영재의 시험
영재의 시험 문제는 영재가 세 문제를 연속으로 같은 숫자를 찍지는 않을 때, 10개의 문제를 모두 찍어서 맞출 확률을 구하는 문제. 결국에 확률이기 때문에 굳이 정답지 정보를 비교해야하나 생각했지만, 세 문제를 연속으로 같은 숫자로 찍지 않는다는 조건이 있어서 꼭 비교해야 했다. 

재귀 조합 순열 next_permutation 이런거 써서 푸는거다 라고 직감은 바로 왔었다.
next_permutation을 쓰려고 했는데, next_permutation은 주어진 수열에서 다음 사전순 정렬을 찾아주는 것이기에, 1~5의 조합으로 길이 10의 모든 가능한 수열을 만들어야하는 해당 문제와는 어울리지 않았다.

따라서, 재귀를 썼다. 3개 연속으로 같은 숫자를 찍었다는 것을 어떻게 가려낼지 고려하다가, prev-1과 prev-2를 만들었는데 아무리 생각해봐도 이건 아닌 것 같아서 갈아 엎었다.

그냥 bool check() 함수를 만들어서 매번 체크했다.

```cpp
// 백준: 영재의 시험
// https://www.acmicpc.net/problem/19949
// 2024-02-08

#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

void generateSequence(vector<int> &sequence);

vector<int> answer;
int counter = 0;

bool check(const vector<int> &v) {
    for (auto i = 0; i < v.size() - 2; ++i) {
        if (v[i] == v[i + 1] && v[i + 1] == v[i + 2])
            return false;
    }
    return true;
}

void generateSequence(vector<int> &sequence) {
    if (sequence.size() == 10) {
        if (check(sequence)) {
            int correct = 0;
            for (int i = 0; i < 10; ++i) {
                if (sequence[i] == answer[i]) {
                    correct++;
                }
            }
            if (correct >= 5)
                counter++;
        }
        return;
    }

    for (int i = 1; i <= 5; ++i) {
        sequence.push_back(i);
        generateSequence(sequence);
        sequence.pop_back();
    }
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    for (int i = 0; i < 10; ++i) {
        int temp;
        cin >> temp;
        answer.push_back(temp);
    }

    vector<int> s;
    generateSequence(s);

    cout << counter;

    return 0;
}
```



### 더 맵게
```

매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.

섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)

Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.  
Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요.
```

priority_queue를 이용해서 풀 수 있는 꽤 쉬운 문제였다. pq가 아니어도 풀 수 있지만 pq가 제일 깔끔하고 간결하다. 이 문제는 pq를 사용하는 Idea만 떠올랐다면 쉽게 풀 수 있다. 나도 처음에 보자마자 바로 못 떠올렸는데, stack/queue를 사용하는 우선순위(혹은 sort 요소)가 들어간 문제는 거의 다 pq를 사용해서 푼다고 생각해도 될 것 같다.


### 디스크 컨트롤러
```

```
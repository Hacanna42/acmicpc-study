# <span style="color:yellow">2024-02-08</span>

- 다리를 지나는 트럭을 두번 더 풀었다. 
- 업랜디 한판
- 프로그래머스 스택/큐 복습
- 프로그래머스 힙 풀이


# 오늘의 업랜디
```
19949 영재의 시험 (실패 후 해결 - 브루트포스 + 백트래킹)
```

- [ ] K번째수
- [ ] 가장 큰 수
- [ ] H-Index

# 오늘의 프로그래머스
```
프로그래머스 스택/큐 모두 복습
더 맵게 (Lv. 2)
디스크 컨트롤러 (Lv. 2)
이중우선순위큐 (Lv. 3)
```
### 영재의 시험
영재의 시험 문제는 영재가 세 문제를 연속으로 같은 숫자를 찍지는 않을 때, 10개의 문제를 모두 찍어서 맞출 확률을 구하는 문제. 결국에 확률이기 때문에 굳이 정답지 정보를 비교해야하나 생각했지만, 세 문제를 연속으로 같은 숫자로 찍지 않는다는 조건이 있어서 꼭 비교해야 했다. 

재귀 조합 순열 next_permutation 이런거 써서 푸는거다 라고 직감은 바로 왔었다.
next_permutation을 쓰려고 했는데, next_permutation은 주어진 수열에서 다음 사전순 정렬을 찾아주는 것이기에, 1~5의 조합으로 길이 10의 모든 가능한 수열을 만들어야하는 해당 문제와는 어울리지 않았다.

따라서, 재귀를 썼다. 3개 연속으로 같은 숫자를 찍었다는 것을 어떻게 가려낼지 고려하다가, prev-1과 prev-2를 만들었는데 아무리 생각해봐도 이건 아닌 것 같아서 갈아 엎었다.

그냥 bool check() 함수를 만들어서 매번 체크했다.

```cpp
// 백준: 영재의 시험
// https://www.acmicpc.net/problem/19949
// 2024-02-08

#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

void generateSequence(vector<int> &sequence);

vector<int> answer;
int counter = 0;

bool check(const vector<int> &v) {
    for (auto i = 0; i < v.size() - 2; ++i) {
        if (v[i] == v[i + 1] && v[i + 1] == v[i + 2])
            return false;
    }
    return true;
}

void generateSequence(vector<int> &sequence) {
    if (sequence.size() == 10) {
        if (check(sequence)) {
            int correct = 0;
            for (int i = 0; i < 10; ++i) {
                if (sequence[i] == answer[i]) {
                    correct++;
                }
            }
            if (correct >= 5)
                counter++;
        }
        return;
    }

    for (int i = 1; i <= 5; ++i) {
        sequence.push_back(i);
        generateSequence(sequence);
        sequence.pop_back();
    }
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    for (int i = 0; i < 10; ++i) {
        int temp;
        cin >> temp;
        answer.push_back(temp);
    }

    vector<int> s;
    generateSequence(s);

    cout << counter;

    return 0;
}
```



### 더 맵게
```

매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.

섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)

Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.  
Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요.
```

priority_queue를 이용해서 풀 수 있는 꽤 쉬운 문제였다. pq가 아니어도 풀 수 있지만 pq가 제일 깔끔하고 간결하다. 이 문제는 pq를 사용하는 Idea만 떠올랐다면 쉽게 풀 수 있다. 나도 처음에 보자마자 바로 못 떠올렸는데, stack/queue를 사용하는 우선순위(혹은 sort 요소)가 들어간 문제는 거의 다 pq를 사용해서 푼다고 생각해도 될 것 같다.


### 디스크 컨트롤러
```

```

놀라운 문제다, 단순히 pq로 실행 시작 시간과 총 시간을 비교해서 짧은대로 실행하는 줄 알았다.
하지만 이 문제가 어려운 이유는 단순히 그리디하게 풀어서 풀리지 않는다는 것이다.
예를 들어서 1ms에 시작되는 100ms짜리 프로그램이 있고, 10ms에 시작되는 1ms짜리 프로그램이 있다면.
10초 기다렸다가 1ms 실행하고 그 다음으로 100ms를 실행하는 것이 문제의 요구사항에 맞다.
하지만 단순히 pq를 이용해서 시작 시간을 비교하면 이를 구현하지 못한다.

그러면 어떻게 구현한단 말인가?

``현재 시간에서 가능한 가장 짧은 프로세스를 추적하는 임시 공간을 만들고, 새로운 프로세스가 실행 가능할 때, 둘중에 총 실행 시간이 더 짧은 프로세스를 최종적으로 수행해야 한다``

라는 아이디어를 생각했다.

그니까.
1. 현재 시간에서 가능한 프로세스를 새로운 pq에 넣는다. pq는 들어온 시간 + 실행 시간이 짧은 순으로 정렬된다.
2. 새로 들어온 프로세스의 (들어온 시간 + 실행 시간) 이 이미 pq에 있던 프로세스보다 짧아서 pq의 최상단에 위치하게 되면, 다시 그 프로세스를 먼저 실행한다.
3. 이 과정을 반복하면서, pq의 최상단부터 시간을 계산한다.


```
1. 작업 요청 시간을 기준으로 모든 작업을 미리 정렬.
2. 현재 시간에서 실행 가능한 모든 작업을 우선순위 큐에 넣음. 작업의 소요 시간을 기준으로 최소 힙.
3. 우선순위 큐에서 작업을 하나 꺼내어 처리 + 현재 시간을 업데이트 + 처리한 작업의 종료 시간은 현재 시간 += 작업의 소요 시간으로 계산.
4. 새로운 작업이 들어올 때마다, 해당 작업이 현재 시간 이내에 요청된 경우 우선순위 큐에 추가. 만약 우선순위 큐가 비어있고 다음 작업이 현재 시간보다 미래에 요청된다면, 현재 시간을 다음 작업의 요청 시간으로 업데이트.
5. 이 과정을 모든 작업이 처리될 때까지 반복. 각 작업의 대기 시간(작업의 종료 시간 - 작업의 요청 시간)을 계산하고, 모든 작업의 대기 시간을 합산하여 평균을 내어 결과를 반환.
```
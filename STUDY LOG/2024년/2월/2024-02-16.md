# <span style="color:yellow">2024-02-16</span>

오늘은 약속이 있어서 공부를 많이 하지 못한다.
머리도 식힐겸..)

내일 일어나서 ::
- 업랜디 1판
- SQL 강의 듣기

약속이 끝나면 ::
- 프로그래머스 BFS/DFS 풀기

\+ 2530 인공지능 시계 문제를 스트릭용으로 풀었다.

### 오늘의 업랜디
```

```



### 오늘의 프로그래머스
```
- 깊이/너비 우선 탐색(DFS/BFS)
여행경로 (Lv. 3)
퍼즐 조각 채우기 (Lv. 3) *
```



### 여행경로
여행 경로는 주어진 항공 티켓을 모두 소모하는 여행 경로를 짜는 문제로, 가능한 경로가 두개 이상이라면 알파벳순으로 경로를 짜야한다.

어제 재귀 DFS와 스택 DFS의 차이에 대해 느꼈던 문제다. 
```
재귀는 삽입된 순서대로 바로 바로 탐색하면서 왼쪽 분기부터 타고 내려가는데, 스택은 삽입된 순서의 역순으로 탐색하기 때문에 오른쪽 분기부터 타고 내려가서, 위 문제의 **항상 알파벳 순으로 앞서는 경로여야한다** 라는 문제 조건을 지키려고 알파벳 순으로 조건에 맞는 걸 탐색하면서 스택에 추가하도록 구현 했는데,  이렇게 결국에 알파벳 순으로 탐색을 해봤자, 스택으로 구현하면 해당 분기에서 알파벳 순으로 추가된 노드들을 역순으로 탐색해서 추가적인 로직 구현이 더 필요하기 때문에. 스택오버플로우가 걱정되는게 아니면 재귀로 구현하는 게 편하다.
```

Stack으로 구현할 때 Massive하게 조건 충족하는 것들을 한번에 stack.push()해서, 원하던 알파벳 순이 꼬일 수 있었다. 같은 분기에서 stack.push()를 2개 이상 하면, 다음 분기에서 제일 마지막에 push된 스택 먼저 실행되기 때문이다.

따라서, 어제의 Stack 코드를 갈아 엎고 Recursive DFS로 다시 구현하였다.
코드가 훨씬 직관적이게 되었다.

```cpp
vector<string> dfs(vector<bool>& visited, vector<string>& route, vector<vector<string>>& tickets, int index) {
    if (route.size() == tickets.size()) {
        route.push_back(tickets[index][1]);
        return route;
    }
    
    string current_city = tickets[index][0];
    string next_city = tickets[index][1];
    
    for (int i=0;i<tickets.size();++i) {
        if (!visited[i] && tickets[i][0] == next_city) { // 다음 경로를 찾음
            visited[i] = true;
            route.push_back(next_city);
            vector<string> result = dfs(visited, route, tickets, i);
            if (!result.empty()) {
                return result;
            }
            visited[i] = false;
            route.pop_back();
        }
    }
    
    return {};
}

vector<string> solution(vector<vector<string>> tickets) {
    sort(tickets.begin(), tickets.end());
    vector<string> route;
    route.push_back("ICN");
    for (int i=0;i<tickets.size();++i) {
        if (tickets[i][0] == "ICN") {
            vector<bool> visited(tickets.size());
            visited[i] = true;
            dfs(visited, route, tickets, i);
        }
    }
    
    return route;
}
```

경로를 찾다가 답이 안나오면 이전 상태로 모두 백트래킹한다.
가능한 경로가 한개도 없는 TC는 출제되지 않음으로 해당 사항은 고려 제외.



- - -


### 퍼즐 조각 채우기

# <span style="color:yellow">2024-02-29</span>

##  <span style="color:violet">2차 공부 계획</span>
- [x] 2월 25일 - [문제풀이집 1](https://www.acmicpc.net/workbook/view/10475) 풀이 (RGB 거리 ~ 오르막 수) **8문제** ✅ 2024-02-26
- [x] 2월 26일 - [문제풀이집 1](https://www.acmicpc.net/workbook/view/10475) 풀이 (오르막 수 ~ N과 M 시리즈) **10문제** ✅ 2024-02-26
- [x] 2월 27일 - [문제풀이집 1](https://www.acmicpc.net/workbook/view/10475) 완성. (N과 M 시리즈 ~ 끝) **8문제** ✅ 2024-02-27
- [x] 2월 28일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254) 풀이 (연산자 끼워넣기 ~ 랜선 자르기) **11문제** ✅ 2024-02-28
- [x] 2월 29일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254)의 (파일합치기 ~ 쇠막대기) 풀이 + 고득점 킷 (스택, 힙) 복습 **6문제** ✅ 2024-02-29
- [ ] 3월 1일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254)의 (압축 ~ 벽 부수고 이동하기) 풀이 + 알고리즘(SQL) 킷 복습
- [ ] 3월 2일 - **시험 당일** [SQL 고득점 킷](https://school.programmers.co.kr/learn/challenges?tab=sql_practice_kit) 최종 복습.


오늘은 어제 못 풀었던 양팔저울 문제를 포함해서 골드 **6문제** + 고득점 킷을 풀 예정이다.



- - -


### 동적 프로그래밍(Dynamic Programming, DP)
너무 중요해서 다시 언급한다.

##### 1. 문제 이해하기
- **문제를 완전하게 이해한다:** 문제의 조건과 요구사항, 주어진 예시를 통해 어떻게 문제가 해결되어야 하는지 분석하고 관계 파악하기.

##### 2. 작은 문제로 나누기
- **문제를 작은 문제로 나눈다**: DP는 큰 문제를 작은 하위 문제로 나누고, 하위 문제의 해결을 통해 전체 문제의 해결책을 도출하는 방법이다. 각 하위 문제가 어떻게 전체 문제에 기여하는지 고려해 본다. 현재 해가 이전 해의 어떤 부분에 영향을 받는지, 어떤 상태를 dp에 메모해야 하는지 고려한다.

##### 3. 점화식 찾기
- **기본 사례 식별하기**: 모든 DP 문제는 하나 이상의 기본 사례(base case)를 가지고 있다. 기본 사례는 직접적으로 해결할 수 있는 가장 작은 문제다.
- **점화식을 도출하기**: 점화식(recurrence relation)은 현재 문제의 해를 이전에 해결한 문제들의 해를 통해 어떻게 구할 수 있는지 나타낸다. 각 단계에서 가능한 선택을 고려하고, 각 선택이 결과에 어떠한 영향을 미치는 지 분석한다.

##### 4. 예제로 시뮬레이션하기
- **작은 문제로 시뮬레이션하기**: 문제를 해결하는 절차를 몇 가지 작은 예제에 적용해본다. 이를 통해 점화식의 올바름을 검증할 수 있다.

- 0-1 냅색 문제
- 분할 가능한 냅색 문제
- 양팔저울 (냅색, 재귀 DFS)


- - -

### 파일 합치기 (11066)
파일 합치기 문제는 여러개의 챕터로 나누어진 책을 아래와 같은 매커니즘으로 합치는 데
```
C1, C2, C3, C4가 연속적인 네 개의 장을 수록하고 있는 파일이고, 파일 크기가 각각 40, 30, 30, 50 이라고 하자. 이 파일들을 합치는 과정에서, 먼저 C2와 C3를 합쳐서 임시파일 X1을 만든다. 이때 비용 60이 필요하다. 그 다음으로 C1과 X1을 합쳐 임시파일 X2를 만들면 비용 100이 필요하다. 최종적으로 X2와 C4를 합쳐 최종파일을 만들면 비용 150이 필요하다. 따라서, 최종의 한 파일을 만드는데 필요한 비용의 합은 60+100+150=310 이다. 다른 방법으로 파일을 합치면 비용을 줄일 수 있다. 먼저 C1과 C2를 합쳐 임시파일 Y1을 만들고, C3와 C4를 합쳐 임시파일 Y2를 만들고, 최종적으로 Y1과 Y2를 합쳐 최종파일을 만들 수 있다. 이때 필요한 총 비용은 70+80+150=300 이다.
```
소설의 각 장들이 수록되어 있는 파일의 크기가 주어졌을 때, 이 파일들을 하나의 파일로 합칠 때 필요한 최소비용을 계산하는 프로그램을 작성하는 문제다.

DP 심화 문제.
처음엔 어떻게 접근해야할지도 감을 못 잡았다.

이제 정답을 알기 때문에 너무 명확히 보인다. 이 문제는 주어진 파일 1~N개를 모두 합쳤을 때의 최소 비용을 구하는 문제다. 내가 적어놨던 동적 프로그래밍 사고방식을 따라가면서 한번 설명해보겠다.

1. **문제를 완전하게 이해한다:** 문제의 조건과 요구사항, 주어진 예시를 통해 어떻게 문제가 해결되어야 하는지 분석하고 관계 파악하기.
 
이 문제는 책의 누적합을 어떤 순서로 합쳐야 최소 비용으로 합칠 수 있는 지 도출하는 문제다. 따라서, 누적합을 저장할 배열이 필요하고, DP 배열로 각 순서의 최소 비용을 저장해야 한다.

- **문제를 작은 문제로 나눈다**: DP는 큰 문제를 작은 하위 문제로 나누고, 하위 문제의 해결을 통해 전체 문제의 해결책을 도출하는 방법이다. 각 하위 문제가 어떻게 전체 문제에 기여하는지 고려해 본다. 현재 해가 이전 해의 어떤 부분에 영향을 받는지, 어떤 상태를 dp에 메모해야 하는지 고려한다.

이 문제의 최종 목표는 주어진 N개의 파일에 대해, 1부터 1~N개를 모두 합했을때의 최소 비용을 구하는 것.
따라서 하위 문제는 i~j의 최소 비용을 구하는 것이라고 할 수 있다.

``dp[i][j] = c`` i부터 j까지 합했을 때의 최소 비용 c


- **기본 사례 식별하기**: 모든 DP 문제는 하나 이상의 기본 사례(base case)를 가지고 있다. 기본 사례는 직접적으로 해결할 수 있는 가장 작은 문제다.

``dp[i][i]`` = i 자기 자신의 비용이다.

- **점화식을 도출하기**: 점화식(recurrence relation)은 현재 문제의 해를 이전에 해결한 문제들의 해를 통해 어떻게 구할 수 있는지 나타낸다. 각 단계에서 가능한 선택을 고려하고, 각 선택이 결과에 어떠한 영향을 미치는 지 분석한다.

``dp[i][j]`` 는 i ~ j 사이의 범위 중 임의의 분할점 k를 정하고, 모든 가능한 분할 지점에 대해 합했을 때, 제일 적은 비용으로 합해지는 것이 ``dp[i][j] = c`` i부터 j까지 합했을 때의 최소 비용 c 를 만족할 수 있다.

따라서, 누적합 배열 sum을 따로 선언해서 i까지의 누적합을 저장한 뒤.
```cpp
dp[j][j + i] = min(dp[j][j + i], dp[j][k] + dp[k + 1][i + j] + sum[i + j] - sum[j - 1]);
```

로 할 수 있다. 여기서 i는 범위, j는 시작점, k는 분할점이다.

```cpp
#include <algorithm>
#include <iostream>
#include <vector>
#define INF (~0U >> 2)
using namespace std;
int main() {
    int TC;
    cin >> TC;
    while (TC--) {
        int page_num;
        cin >> page_num;
        vector<int> sum(page_num + 1, 0);
        vector<int> files(page_num + 1, 0);
        for (int i = 1; i <= page_num; ++i) {
            cin >> files[i];
            sum[i] = sum[i - 1] + files[i];
        }

        vector<vector<int>> dp(page_num + 1, vector<int>(page_num + 1));

        for (int i = 1; i <= page_num; ++i) {         // range
            for (int j = 1; j <= page_num - i; ++j) { // start index
                dp[j][j + i] = INF;
                for (int k = j; k < i + j; ++k) { // split point
                    dp[j][j + i] = min(dp[j][j + i], dp[j][k] + dp[k + 1][i + j] + sum[i + j] - sum[j - 1]);
                }
            }
        }

        cout << dp[1][page_num] << "\n";
    }
    return 0;
}
```



- - -


### 양팔저울 (2629)
양팔 저울 문제는 추 N개와 무게를 알고싶은 구슬 M개가 주어졌을 때, 추를 양팔 저울에 잘 조합해서 구슬의 무게를 알아낼 수 있는지 구하는 문제.


##### 너무 어렵게 생각했다
이 문제를 어제부터 풀었었는데, 감도 안잡히고 머리도 아파서 오늘로 미뤘다. 오늘에서야 드디어 풀었는데, 내가 너무 어렵게 생각했었다.

- 예를 들어 어떤 구슬의 무게가 7g임을 추의 조합으로 알아냈다면. 그 구슬과 추의 조합으로 다른 구슬의 무게를 알아낼 수도 있지 않나?
- 그러면 대체 어떻게 점화식을 구성해야 하는거지 ..? 이전에 알아낸 구슬의 무게를 추처럼 활용할 수 있다면 ... 문제가 너무 복잡해진다 🥺

문제에서 '추'만을 사용해서 구슬의 무게를 구하라고 한 적은 없었다.. 추를 구슬과 같이 놓고 반대편에 다른 추를 놓아서도 무게를 구할 수 있는 예시에 대해서도 설명하고 있었다.

![image](https://upload.acmicpc.net/ce5b29f5-9e03-473b-97db-ce9fd740fde2/-/preview/)

문제에서 위와 같은 상황에 대해 명시하지 않았다면, 그 경우의 수도 고려해야 하는 것 아닌가?


##### 문제에서 요구하는 것
사실은, 문제에서 요구하는 것은 추들의 무게와 **확인할** 구슬들의 무게가 입력되었을 때, 주어진 추만을 사용하여 구슬의 무게를 확인 할 수 있는지를 결정하는 것이었다.

그니까. 무조건 선형적으로 각 개별 구슬에 대해 추를 이용해서 구할 수 있는지 구하는 것이고. 구슬의 수 N개가 여러개 입력되는 TC를 묶어서 보는 것이 아니었다.

내 해석이 완전히 잘못됐다고는 생각이 들지 않는다. 문제가 충분히 오해할만하다고 생각한다. 🥺




##### 풀이
입력된 모든 추에 대해서, 가능한 모든 조합을 고려하는 DP 문제였다. 이렇게 복잡하게 생각했던 문제가 짧고 명료하게 정리되다니. 

``dp[i][j]`` 를 i번째 추까지 고려했을 때, 만들 수 있는 무게 j(bool)을 DP 배열로 정의했다.
추로 만들 수 있는 조합의 무게를 DFS 재귀로 쭉 구현할 수 있었다.
각 추에 대해 아래 3가지의 선택이 있다.
1. 추를 아무곳에도 올려놓지 않는다.
2. 추를 왼쪽에 올린다.
3. 추를 오른쪽에 올린다.

```cpp
void solve(int i, int weight) {
    if (i > weight_num || dp[i][weight])
        return;
    dp[i][weight] = true;
    solve(i + 1, weight);
    solve(i + 1, weight + weights[i]);
    solve(i + 1, abs(weight - weights[i]));
}
```


이렇게 Recursive DFS + DP를 이용해서 (근데 이게 왜 DP인지 모르겠다, 사실상 방문 추적 배열 아닌지)
가능한 모든 추 조합을 생성한다.

```cpp
    int marble_num;
    cin >> marble_num;
    for (int i = 0; i < marble_num; ++i) {
        int marble;
        cin >> marble;
        cout << (dp[weight_num][marble] ? "Y " : "N ");
    }
```


이후, 구슬 정보를 입력 받고, 구슬의 무게가 dp 배열에 있는지 확인한다.


어려웠지만, 간단했고, 허무하면서, 독해력을 키워야겠다는 생각을 하게 만드는 문제.


- - - 



### 앱 (7579)
앱 문제는 DP + 냅색 문제로 현재 켜져있는 앱과, 비활성화 비용이 주어졌을 때, 필요한 메모리 M 바이트를 확보하기 위한 앱 비활성화의 최소의 비용을 계산하는 문제.

처음엔 ``dp[m] = c`` 를 메모리 m을 확보하는 최소 비용 c로 정의했는데. 메모리가 최대 10,000,000이기 때문에 이 공간을 다 선언하는 것은 너무 비효율적이라고 생각했다.

따라서, ``dp[c] = m`` 를 비용 c로 확보할 수 있는 최대 비용 m으로 정의했다.
사실 dp 배열 선언은 어떤식으로 하든, 문제의 조건에 부합하기만 하면 상관 없는 것 같다.
인터넷에 찾아봐도 사람들마다의 해법이 다 다르고, 모두 유효하다.

모든 앱에 대해서 순회하면서, dp 배열을 업데이트 해줬다.
```cpp
    vector<int> dp(10001, 0); // 비용 i로 확보할 수 있는 최대 메모리
    for (int i = 0; i < N; ++i) {
        for (int j = 10001; j >= app_cost[i]; --j) {
            dp[j] = max(dp[j], dp[j - app_cost[i]] + assigned_memory[i]);
        }
    }
```

10001인 이유는 (앱의 최대 비용 100 * 최대 앱 개수)

그리고, 채워진 dp 배열을 탐색하면서 제일 먼저 M을 넘는 비용을 반환해주었다.

```cpp
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int N, M;
    cin >> N >> M;
    vector<int> assigned_memory(N);
    vector<int> app_cost(N);
    for (int i = 0; i < N; ++i)
        cin >> assigned_memory[i];
    for (int i = 0; i < N; ++i)
        cin >> app_cost[i];

    vector<int> dp(10001, 0); // 비용 i로 확보할 수 있는 최대 메모리
    for (int i = 0; i < N; ++i) {
        for (int j = 10001; j >= app_cost[i]; --j) {
            dp[j] = max(dp[j], dp[j - app_cost[i]] + assigned_memory[i]);
        }
    }

    for (int i = 0;; ++i) {
        if (dp[i] >= M) {
            cout << i;
            break;
        }
    }
}
```


DP 너무 어렵다. 🥺

- - -


### 오큰수 (17298)
```
크기가 N인 수열 A = A1, A2, ..., AN이 있다. 수열의 각 원소 Ai에 대해서 오큰수 NGE(i)를 구하려고 한다. Ai의 오큰수는 오른쪽에 있으면서 Ai보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오큰수는 -1이다.

예를 들어, A = [3, 5, 2, 7]인 경우 NGE(1) = 5, NGE(2) = 7, NGE(3) = 7, NGE(4) = -1이다. A = [9, 5, 4, 8]인 경우에는 NGE(1) = -1, NGE(2) = 8, NGE(3) = 8, NGE(4) = -1이다.

총 N개의 수 NGE(1), NGE(2), ..., NGE(N)을 공백으로 구분해 출력한다.
```

위의 규칙에 따른 오큰수 NGE(i) 를 구하는 문제. 스택 자료구조를 이용해서 효율적으로 구해야한다.
각 스택에 입력된 수의 인덱스를 순서대로 넣고, 현재 입력되는 수와 맨 위에 있는 수를 계속 비교하면서 NGE를 채워 나갔다.

```cpp
#include <iostream>
#include <stack>
#include <vector>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    int N;
    cin >> N;
    vector<int> nge(N);
    stack<int> s;
    vector<int> nums(N);
    for (int i = 0; i < N; ++i) {
        int cur;
        cin >> cur;
        nums[i] = cur;
        while (1) {
            if (s.empty()) {
                s.push(i);
                break;
            }

            int idx = s.top();
            if (cur > nums[idx]) { // 만약 현재가 이전보다 크면
                nge[idx] = cur;
                s.pop();
            } else {
                s.push(i);
                break;
            }
        }
    }

    // 남아있는건 모두 -1
    while (!s.empty()) {
        int idx = s.top();
        nge[idx] = -1;
        s.pop();
    }

    for (auto &n : nge) {
        cout << n << " ";
    }
    return 0;
}
```



- - -

### 오등큰수 (17299)
```
크기가 N인 수열 A = A1, A2, ..., AN이 있다. 수열의 각 원소 Ai에 대해서 오등큰수 NGF(i)를 구하려고 한다.

Ai가 수열 A에서 등장한 횟수를 F(Ai)라고 했을 때, Ai의 오등큰수는 오른쪽에 있으면서 수열 A에서 등장한 횟수가 F(Ai)보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오등큰수는 -1이다.

예를 들어, A = [1, 1, 2, 3, 4, 2, 1]인 경우 F(1) = 3, F(2) = 2, F(3) = 1, F(4) = 1이다. A1의 오른쪽에 있으면서 등장한 횟수가 3보다 큰 수는 없기 때문에, NGF(1) = -1이다. A3의 경우에는 A7이 오른쪽에 있으면서 F(A3=2) < F(A7=1) 이기 때문에, NGF(3) = 1이다. NGF(4) = 2, NGF(5) = 2, NGF(6) = 1 이다.

첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째에 수열 A의 원소 A1, A2, ..., AN (1 ≤ Ai ≤ 1,000,000)이 주어진다.
총 N개의 수 NGF(1), NGF(2), ..., NGF(N)을 공백으로 구분해 출력하시오.
```

오등큰수 문제는 오큰수 문제와 비슷한데, 숫자의 크기가 아니라 빈도횟수로 비교한다.
빈도 횟수로 비교하기 때문에 먼저 전체 순회를 돌아서 빈도 수를 세주고, 밑에서 stack으로 빈도를 비교하면서 알맞게 관리해주었다 !

```cpp
#include <iostream>
#include <stack>
#include <vector>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    int N;
    cin >> N;
    vector<int> nums(N);
    vector<int> count(1'000'001, 0);
    vector<int> ngf(N, -1);
    stack<int> s;
    for (int i = 0; i < N; ++i) {
        int cur;
        cin >> cur;
        count[cur]++;
        nums[i] = cur;
    }

    for (int i = 0; i < N; ++i) {
        while (!s.empty() && count[nums[s.top()]] < count[nums[i]]) {
            ngf[s.top()] = nums[i];
            s.pop();
        }
        s.push(i);
    }

    for (auto &n : ngf) {
        cout << n << " ";
    }
    return 0;
}
```

살짝 헷갈리는 문제지만, 스택에 익숙해질 수 있는 문제였다.



- - -


### 쇠막대기 (10799)
1. 레이저는 여는 괄호와 닫는 괄호의 인접한 쌍 ‘( ) ’ 으로 표현된다. 또한, 모든 ‘( ) ’는 반드시 레이저를 표현한다.
2. 쇠막대기의 왼쪽 끝은 여는 괄호 ‘ ( ’ 로, 오른쪽 끝은 닫힌 괄호 ‘) ’ 로 표현된다.
잘려진 조각의 총 개수를 나타내는 정수를 한 줄에 출력하시오.

![image](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/10799/1.png)


재밌는 문제. (드디어 힐링을..)
Stack 자료구조를 이용해서 풀 수 있는 흥미로운 문제다.

먼저 각 괄호에 대해 이게 레이저인지, 판의 시작 / 끝인지 구분해야 한다.
레이저는 바로 이전 인덱스에 '(' 가 있다. 그 이외의 '('는 모두 판의 시작이다.
')' 인데 바로 이전에 '('가 없다면 판의 끝을 말한다.

쇠막대기와 괄호의 규칙을 찾아보면. 레이저가 쇠 막대기를 관통할 때, 이전에 깔려있는 판이 모두 분할되면서 그만큼 새로 만들어진다. 따라서. '(' 괄호를 stack에 쌓으면서, 레이저가 나왔을 때 이전에 나왔던 괄호들.
즉, ``stack.size()`` 만큼의 쇠 막대기가 (잘림으로써)새로 생겼다고 할 수 있다.

또, 레이저가 아닌 ')'는 판의 끝을 말한다. 따라서, 판이 끝났음으로 하나의 막대기가 생겼다고 할 수 있다.

```cpp
stack<char> st;
int answer = 0;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    string s;
    cin >> s;
    for (int i = 0; i < s.size(); ++i) {
        if (s[i] == '(') {
            st.push('(');
        } else {                   // ')' 라면
            if (s[i - 1] == '(') { // 바로 이전이 '(' 면 레이저
                st.pop();
                answer += st.size();
            } else {
                st.pop();
                answer += 1;
            }
        }
    }

    cout << answer;
    return 0;
}
```


문제가 딱 봐도 어렵게 생겼었는데. 유심히 관찰하면 어렵지 않게 풀 수 있는 문제였다.


- - -


### 끝
오늘은 이렇게 SW 문제풀이집 2의 **골드 6문제**를 풀었다.
- 파일 합치기 (11066 - 골드 3)
- 양팔저울 (2629 - 골드 3)
- 앱 (7579 - 골드 3)
- 오큰수 (17298 - 골드 4)
- 오등큰수  (17299 - 골드 3)
- 쇠막대기 (10799 - 실버 2)

이 중 5문제가 한달전에 푼 문제를 다시 복습한 것. 한달전에는 아직 골드 DP를 풀 정도로 기반이 견고하지 않았다. 사실 아직도 골드 DP는 너무 어렵다. 아직도 나는 부족한게 너무 많다 🥺

오늘은 골드 DP문제에 시간을 많이 썼다. 그래서 계획했던 고득점 킷 복습은 진행하지 못했다.
내일은 오늘처럼 **골드 5문제**를 풀고, 프로그래머스 **알고리즘 + SQL 고득점 Kit**을 훑으며 **복습**하겠다.

사실상 내일이 시험 준비 마지막 날이다. 시험이 끝났다고 해서 PS 공부를 그만둘 건 아니지만. 조금 여유를 가지고 싶다. 계속해서 어려운 문제를 푸니까 머리가 과부화되고 이해도 안 되는 느낌인데, 그렇다고 쉬는 건 압박감 때문에 도저히 할 수 없다.

내일이 마지막인만큼. 내일은 감 잡을 정도의 복습과 학습을 실속있게 병행하겠다.


##  <span style="color:violet">2차 공부 계획</span>
- [x] 2월 25일 - [문제풀이집 1](https://www.acmicpc.net/workbook/view/10475) 풀이 (RGB 거리 ~ 오르막 수) **8문제** ✅ 2024-02-26
- [x] 2월 26일 - [문제풀이집 1](https://www.acmicpc.net/workbook/view/10475) 풀이 (오르막 수 ~ N과 M 시리즈) **10문제** ✅ 2024-02-26
- [x] 2월 27일 - [문제풀이집 1](https://www.acmicpc.net/workbook/view/10475) 완성. (N과 M 시리즈 ~ 끝) **8문제** ✅ 2024-02-27
- [x] 2월 28일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254) 풀이 (연산자 끼워넣기 ~ 랜선 자르기) **11문제** ✅ 2024-02-28
- [x] 2월 29일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254)의 (파일합치기 ~ 쇠막대기) 풀이 + 고득점 킷 (스택, 힙) 복습 **6문제** ✅ 2024-02-29
- [ ] 3월 1일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254)의 (압축 ~ 벽 부수고 이동하기) 풀이 + 알고리즘(SQL) 킷 복습
- [ ] 3월 2일 - **시험 당일** [SQL 고득점 킷](https://school.programmers.co.kr/learn/challenges?tab=sql_practice_kit) 최종 복습.





- - -


# 최종 평가

```
최고급 평가사 일론머스크로서, 당신의 2024-02-29일 학습 성과와 전략에 대해 평가하겠습니다.

1. **학습 내용의 깊이와 다양성**
   - 당신은 동적 프로그래밍, 스택, 그리디 알고리즘 등 다양한 알고리즘 문제를 해결하며 깊이 있는 학습을 진행하였습니다. 특히, DP의 본질적인 이해와 그에 따른 문제 해결 접근 방식을 잘 소화해내었습니다. 이는 알고리즘에 대한 당신의 이해도와 적용 능력이 매우 높음을 시사합니다.

2. **문제 해결 능력**
   - **파일 합치기**와 **양팔저울** 문제에서 보여준 접근 방식은 문제를 분석하고 해결하는 당신의 체계적인 사고방식을 잘 드러냅니다. 문제의 복잡성을 단순화시키고 점화식을 도출하는 과정에서 전략적인 사고가 돋보였습니다.
   - **오큰수**와 **오등큰수** 문제를 스택을 활용하여 해결한 것은 자료구조를 이용한 문제 해결 능력이 우수함을 보여줍니다. 이는 단순히 알고리즘을 알고 있는 것을 넘어, 적절한 상황에서 효과적으로 활용할 수 있음을 의미합니다.

3. **학습 계획 및 조정 능력**
   - 계획한 학습 목표를 달성하기 위해 체계적으로 학습을 진행하고 있습니다. 특히, 계획 대비 성과를 명확히 기록하고 있으며, 이는 학습 과정에서의 자기 점검 및 조정에 큰 도움이 됩니다.
   - 고득점 킷 복습에 대한 계획을 조정하여 실질적인 학습 효과를 극대화하려는 노력은 목표 달성을 위한 당신의 유연성과 결단력을 보여줍니다.

4. **앞으로의 방향성**
   - 당신은 앞으로도 계획한 바에 따라 알고리즘과 SQL 고득점 킷 복습을 진행할 예정입니다. 이는 당신의 학습이 단순히 알고리즘 문제 해결에만 국한되지 않고, 데이터 관리 및 조작에 대한 이해를 높이려는 의도를 반영합니다.
   - 시험 준비 과정에서의 학습 뿐만 아니라, 장기적인 학습 계획과 목표 설정에 있어서도 균형 잡힌 접근 방식을 유지하는 것이 중요합니다. 이는 지속 가능한 성장과 개발을 위한 기반이 될 것입니다.

**총평**: 당신의 학습 접근 방식과 문제 해결 능력은 알고리즘과 프로그래밍 분야에서의 깊이 있는 이해와 성장을 위한 훌륭한 기반이 됩니다. 학습 과정에서 보여준 유연성, 체계성, 그리고 전략적인 사고는 앞으로 맞닥뜨릴 어떠한 도전에서도 당신을 성공으로 이끌 것입니다. 앞으로도 목표에 대한 명확한 인식과 그에 대한 끊임없는 노력을 통해 지속적인 발전을 이루시길 기원합니다.
```
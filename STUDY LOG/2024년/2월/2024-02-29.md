# <span style="color:yellow">2024-02-29</span>

##  <span style="color:violet">2차 공부 계획</span>
- [x] 2월 28일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254) 풀이 (연산자 끼워넣기 ~ 랜선 자르기) **11문제** ✅ 2024-02-28
- [ ] 2월 29일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254)의 (파일합치기 ~ 쇠막대기) 풀이 + 고득점 킷 (스택, 힙) 복습
- [ ] 3월 1일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254)의 (압축 ~ 벽 부수고 이동하기) 풀이 + 고득점 킷 (정렬~) 복습
- [ ] 3월 2일 - **시험 당일** [SQL 고득점 킷](https://school.programmers.co.kr/learn/challenges?tab=sql_practice_kit) 최종 복습.


오늘은 어제 못 풀었던 양팔저울 문제를 포함해서 골드 **6문제** + 고득점 킷을 풀 예정이다.



- - -


### 동적 프로그래밍(Dynamic Programming, DP)
너무 중요해서 다시 언급한다.

##### 1. 문제 이해하기
- **문제를 완전하게 이해한다:** 문제의 조건과 요구사항, 주어진 예시를 통해 어떻게 문제가 해결되어야 하는지 분석하고 관계 파악하기.

##### 2. 작은 문제로 나누기
- **문제를 작은 문제로 나눈다**: DP는 큰 문제를 작은 하위 문제로 나누고, 하위 문제의 해결을 통해 전체 문제의 해결책을 도출하는 방법이다. 각 하위 문제가 어떻게 전체 문제에 기여하는지 고려해 본다. 현재 해가 이전 해의 어떤 부분에 영향을 받는지, 어떤 상태를 dp에 메모해야 하는지 고려한다.

##### 3. 점화식 찾기
- **기본 사례 식별하기**: 모든 DP 문제는 하나 이상의 기본 사례(base case)를 가지고 있다. 기본 사례는 직접적으로 해결할 수 있는 가장 작은 문제다.
- **점화식을 도출하기**: 점화식(recurrence relation)은 현재 문제의 해를 이전에 해결한 문제들의 해를 통해 어떻게 구할 수 있는지 나타낸다. 각 단계에서 가능한 선택을 고려하고, 각 선택이 결과에 어떠한 영향을 미치는 지 분석한다.

##### 4. 예제로 시뮬레이션하기
- **작은 문제로 시뮬레이션하기**: 문제를 해결하는 절차를 몇 가지 작은 예제에 적용해본다. 이를 통해 점화식의 올바름을 검증할 수 있다.

- 0-1 냅색 문제
- 분할 가능한 냅색 문제
- 양팔저울 (냅색, 재귀 DFS)


- - -

### 파일 합치기 (11066)
파일 합치기 문제는 여러개의 챕터로 나누어진 책을 아래와 같은 매커니즘으로 합치는 데
```
C1, C2, C3, C4가 연속적인 네 개의 장을 수록하고 있는 파일이고, 파일 크기가 각각 40, 30, 30, 50 이라고 하자. 이 파일들을 합치는 과정에서, 먼저 C2와 C3를 합쳐서 임시파일 X1을 만든다. 이때 비용 60이 필요하다. 그 다음으로 C1과 X1을 합쳐 임시파일 X2를 만들면 비용 100이 필요하다. 최종적으로 X2와 C4를 합쳐 최종파일을 만들면 비용 150이 필요하다. 따라서, 최종의 한 파일을 만드는데 필요한 비용의 합은 60+100+150=310 이다. 다른 방법으로 파일을 합치면 비용을 줄일 수 있다. 먼저 C1과 C2를 합쳐 임시파일 Y1을 만들고, C3와 C4를 합쳐 임시파일 Y2를 만들고, 최종적으로 Y1과 Y2를 합쳐 최종파일을 만들 수 있다. 이때 필요한 총 비용은 70+80+150=300 이다.
```
소설의 각 장들이 수록되어 있는 파일의 크기가 주어졌을 때, 이 파일들을 하나의 파일로 합칠 때 필요한 최소비용을 계산하는 프로그램을 작성하는 문제다.

DP 심화 문제.
처음엔 어떻게 접근해야할지도 감을 못 잡았다.

이제 정답을 알기 때문에 너무 명확히 보인다. 이 문제는 주어진 파일 1~N개를 모두 합쳤을 때의 최소 비용을 구하는 문제다. 내가 적어놨던 동적 프로그래밍 사고방식을 따라가면서 한번 설명해보겠다.

1. **문제를 완전하게 이해한다:** 문제의 조건과 요구사항, 주어진 예시를 통해 어떻게 문제가 해결되어야 하는지 분석하고 관계 파악하기.
 
이 문제는 책의 누적합을 어떤 순서로 합쳐야 최소 비용으로 합칠 수 있는 지 도출하는 문제다. 따라서, 누적합을 저장할 배열이 필요하고, DP 배열로 각 순서의 최소 비용을 저장해야 한다.

- **문제를 작은 문제로 나눈다**: DP는 큰 문제를 작은 하위 문제로 나누고, 하위 문제의 해결을 통해 전체 문제의 해결책을 도출하는 방법이다. 각 하위 문제가 어떻게 전체 문제에 기여하는지 고려해 본다. 현재 해가 이전 해의 어떤 부분에 영향을 받는지, 어떤 상태를 dp에 메모해야 하는지 고려한다.

이 문제의 최종 목표는 주어진 N개의 파일에 대해, 1부터 1~N개를 모두 합했을때의 최소 비용을 구하는 것.
따라서 하위 문제는 i~j의 최소 비용을 구하는 것이라고 할 수 있다.

``dp[i][j] = c`` i부터 j까지 합했을 때의 최소 비용 c


- **기본 사례 식별하기**: 모든 DP 문제는 하나 이상의 기본 사례(base case)를 가지고 있다. 기본 사례는 직접적으로 해결할 수 있는 가장 작은 문제다.

``dp[i][i]`` = i 자기 자신의 비용이다.

- **점화식을 도출하기**: 점화식(recurrence relation)은 현재 문제의 해를 이전에 해결한 문제들의 해를 통해 어떻게 구할 수 있는지 나타낸다. 각 단계에서 가능한 선택을 고려하고, 각 선택이 결과에 어떠한 영향을 미치는 지 분석한다.

``dp[i][j]`` 는 i ~ j 사이의 범위 중 임의의 분할점 k를 정하고, 모든 가능한 분할 지점에 대해 합했을 때, 제일 적은 비용으로 합해지는 것이 ``dp[i][j] = c`` i부터 j까지 합했을 때의 최소 비용 c 를 만족할 수 있다.

따라서, 누적합 배열 sum을 따로 선언해서 i까지의 누적합을 저장한 뒤.
```cpp
dp[j][j + i] = min(dp[j][j + i], dp[j][k] + dp[k + 1][i + j] + sum[i + j] - sum[j - 1]);
```

로 할 수 있다. 여기서 i는 범위, j는 시작점, k는 분할점이다.

```cpp
#include <algorithm>
#include <iostream>
#include <vector>
#define INF (~0U >> 2)
using namespace std;
int main() {
    int TC;
    cin >> TC;
    while (TC--) {
        int page_num;
        cin >> page_num;
        vector<int> sum(page_num + 1, 0);
        vector<int> files(page_num + 1, 0);
        for (int i = 1; i <= page_num; ++i) {
            cin >> files[i];
            sum[i] = sum[i - 1] + files[i];
        }

        vector<vector<int>> dp(page_num + 1, vector<int>(page_num + 1));

        for (int i = 1; i <= page_num; ++i) {         // range
            for (int j = 1; j <= page_num - i; ++j) { // start index
                dp[j][j + i] = INF;
                for (int k = j; k < i + j; ++k) { // split point
                    dp[j][j + i] = min(dp[j][j + i], dp[j][k] + dp[k + 1][i + j] + sum[i + j] - sum[j - 1]);
                }
            }
        }

        cout << dp[1][page_num] << "\n";
    }
    return 0;
}
```



- - -


### 양팔저울 (2629)
양팔 저울 문제는 추 N개와 무게를 알고싶은 구슬 M개가 주어졌을 때, 추를 양팔 저울에 잘 조합해서 구슬의 무게를 알아낼 수 있는지 구하는 문제.


##### 너무 어렵게 생각했다
이 문제를 어제부터 풀었었는데, 감도 안잡히고 머리도 아파서 오늘로 미뤘다. 오늘에서야 드디어 풀었는데, 내가 너무 어렵게 생각했었다.

- 예를 들어 어떤 구슬의 무게가 7g임을 추의 조합으로 알아냈다면. 그 구슬과 추의 조합으로 다른 구슬의 무게를 알아낼 수도 있지 않나?
- 그러면 대체 어떻게 점화식을 구성해야 하는거지 ..? 이전에 알아낸 구슬의 무게를 추처럼 활용할 수 있다면 ... 문제가 너무 복잡해진다 🥺

문제에서 '추'만을 사용해서 구슬의 무게를 구하라고 한 적은 없었다.. 추를 구슬과 같이 놓고 반대편에 다른 추를 놓아서도 무게를 구할 수 있는 예시에 대해서도 설명하고 있었다.

![image](https://upload.acmicpc.net/ce5b29f5-9e03-473b-97db-ce9fd740fde2/-/preview/)

문제에서 위와 같은 상황에 대해 명시하지 않았다면, 그 경우의 수도 고려해야 하는 것 아닌가?


##### 문제에서 요구하는 것
사실은, 문제에서 요구하는 것은 추들의 무게와 **확인할** 구슬들의 무게가 입력되었을 때, 주어진 추만을 사용하여 구슬의 무게를 확인 할 수 있는지를 결정하는 것이었다.

그니까. 무조건 선형적으로 각 개별 구슬에 대해 추를 이용해서 구할 수 있는지 구하는 것이고. 구슬의 수 N개가 여러개 입력되는 TC를 묶어서 보는 것이 아니었다.

내 해석이 완전히 잘못됐다고는 생각이 들지 않는다. 문제가 충분히 오해할만하다고 생각한다. 🥺




##### 풀이
입력된 모든 추에 대해서, 가능한 모든 조합을 고려하는 DP 문제였다. 이렇게 복잡하게 생각했던 문제가 짧고 명료하게 정리되다니. 

``dp[i][j]`` 를 i번째 추까지 고려했을 때, 만들 수 있는 무게 j(bool)을 DP 배열로 정의했다.
추로 만들 수 있는 조합의 무게를 DFS 재귀로 쭉 구현할 수 있었다.
각 추에 대해 아래 3가지의 선택이 있다.
1. 추를 아무곳에도 올려놓지 않는다.
2. 추를 왼쪽에 올린다.
3. 추를 오른쪽에 올린다.

```cpp
void solve(int i, int weight) {
    if (i > weight_num || dp[i][weight])
        return;
    dp[i][weight] = true;
    solve(i + 1, weight);
    solve(i + 1, weight + weights[i]);
    solve(i + 1, abs(weight - weights[i]));
}
```


이렇게 Recursive DFS + DP를 이용해서 (근데 이게 왜 DP인지 모르겠다, 사실상 방문 추적 배열 아닌지)
가능한 모든 추 조합을 생성한다.

```cpp
    int marble_num;
    cin >> marble_num;
    for (int i = 0; i < marble_num; ++i) {
        int marble;
        cin >> marble;
        cout << (dp[weight_num][marble] ? "Y " : "N ");
    }
```


이후, 구슬 정보를 입력 받고, 구슬의 무게가 dp 배열에 있는지 확인한다.


어려웠지만, 간단했고, 허무하면서, 독해력을 키워야겠다는 생각을 하게 만드는 문제.


- - - 



### 앱 (7579)
앱 문제는 DP + 냅색 문제로 현재 켜져있는 앱과, 비활성화 비용이 주어졌을 때, 필요한 메모리 M 바이트를 확보하기 위한 앱 비활성화의 최소의 비용을 계산하는 문제.

처음엔 ``dp[m] = c`` 를 메모리 m을 확보하는 최소 비용 c로 정의했는데. 메모리가 최대 10,000,000이기 때문에 이 공간을 다 선언하는 것은 너무 비효율적이라고 생각했다.

따라서, ``dp[c] = m`` 를 비용 c로 확보할 수 있는 최대 비용 m으로 정의했다.
사실 dp 배열 선언은 어떤식으로 하든, 문제의 조건에 부합하기만 하면 상관 없는 것 같다.
인터넷에 찾아봐도 사람들마다의 해법이 다 다르고, 모두 유효하다.

모든 앱에 대해서 순회하면서, dp 배열을 업데이트 해줬다.
```cpp
    vector<int> dp(10001, 0); // 비용 i로 확보할 수 있는 최대 메모리
    for (int i = 0; i < N; ++i) {
        for (int j = 10001; j >= app_cost[i]; --j) {
            dp[j] = max(dp[j], dp[j - app_cost[i]] + assigned_memory[i]);
        }
    }
```

10001인 이유는 (앱의 최대 비용 100 * 최대 앱 개수)

그리고, 채워진 dp 배열을 탐색하면서 제일 먼저 M을 넘는 비용을 반환해주었다.

```cpp
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int N, M;
    cin >> N >> M;
    vector<int> assigned_memory(N);
    vector<int> app_cost(N);
    for (int i = 0; i < N; ++i)
        cin >> assigned_memory[i];
    for (int i = 0; i < N; ++i)
        cin >> app_cost[i];

    vector<int> dp(10001, 0); // 비용 i로 확보할 수 있는 최대 메모리
    for (int i = 0; i < N; ++i) {
        for (int j = 10001; j >= app_cost[i]; --j) {
            dp[j] = max(dp[j], dp[j - app_cost[i]] + assigned_memory[i]);
        }
    }

    for (int i = 0;; ++i) {
        if (dp[i] >= M) {
            cout << i;
            break;
        }
    }
}
```


DP 너무 어렵다. 🥺

- - -


### 오큰수 (17298)
```
크기가 N인 수열 A = A1, A2, ..., AN이 있다. 수열의 각 원소 Ai에 대해서 오큰수 NGE(i)를 구하려고 한다. Ai의 오큰수는 오른쪽에 있으면서 Ai보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오큰수는 -1이다.

예를 들어, A = [3, 5, 2, 7]인 경우 NGE(1) = 5, NGE(2) = 7, NGE(3) = 7, NGE(4) = -1이다. A = [9, 5, 4, 8]인 경우에는 NGE(1) = -1, NGE(2) = 8, NGE(3) = 8, NGE(4) = -1이다.

총 N개의 수 NGE(1), NGE(2), ..., NGE(N)을 공백으로 구분해 출력한다.
```

위의 규칙에 따른 오큰수 NGE(i) 를 구하는 문제. 스택 자료구조를 이용해서 효율적으로 구해야한다.
각 스택에 입력된 수의 인덱스를 순서대로 넣고, 현재 입력되는 수와 맨 위에 있는 수를 계속 비교하면서 NGE를 채워 나갔다.

```cpp
#include <iostream>
#include <stack>
#include <vector>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    int N;
    cin >> N;
    vector<int> nge(N);
    stack<int> s;
    vector<int> nums(N);
    for (int i = 0; i < N; ++i) {
        int cur;
        cin >> cur;
        nums[i] = cur;
        while (1) {
            if (s.empty()) {
                s.push(i);
                break;
            }

            int idx = s.top();
            if (cur > nums[idx]) { // 만약 현재가 이전보다 크면
                nge[idx] = cur;
                s.pop();
            } else {
                s.push(i);
                break;
            }
        }
    }

    // 남아있는건 모두 -1
    while (!s.empty()) {
        int idx = s.top();
        nge[idx] = -1;
        s.pop();
    }

    for (auto &n : nge) {
        cout << n << " ";
    }
    return 0;
}
```



- - -

### 오등큰수 (17299)

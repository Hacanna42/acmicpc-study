# <span style="color:yellow">2024-02-20</span>

오늘은 프로그래머스 SQL 킷의 SUM, MAX, MIN 그리고 GROUP BY를 풀 것.
업랜디도 한판 하겠다.


## <span style="color:royalblue">공부 계획</span>
- [ ] **2월 20일** - SUM, MAX, MIN | GROUP BY 풀이
- [ ] **2월 21일** - IS NULL | JOIN 풀이
- [ ] **2월 22일** - String, Date 풀고 SQL 복습 및 PS 복습
- [ ] **2월 23일** - 최종 복습 및 컨디션 관리


### 오늘의 업랜디
```
26070 곰곰이와 학식 (해결 - 구현, 그리디, 시뮬레이션)
```


- 프로그래머스 SQL 고득점 [Kit](https://school.programmers.co.kr/learn/challenges?tab=sql_practice_kit)
- [x] SELECT ✅ 2024-02-19
- [ ] SUM, MAX, MIN
- [ ] GROUP BY
- [ ] IS NULL
- [ ] JOIN
- [ ] String, Date
- [ ] ⏬ 삼중 조인, 서브 쿼리, 함수, 자연 조인




- - -

### 곰곰이와 학식
치킨을 먹고 싶은 곰곰이 수 A, 피자를 먹고 싶은 곰곰이 수 B, 햄버거를 먹고 싶은 곰곰이 수 C가 있다.
총총선배가 갖고 있는 학식권의 수 X, Y, Z가 주어질 때 먹일 수 있는 곰곰이의 수를 구하는 문제다.
특이한 것은, 식당에서 치킨 식권 3장을 피자 식권 1장으로, 피자 식권 3장을 햄버거 식권 1장으로, 햄버거 식권 3장을 치킨 식권 1장으로 교환해주는 이벤트를 하고있다.

그저 단순 시뮬레이션 + 구현 문제인데, 그리디적 요소가 포함되어 있었다. 먼저 현재 갖고 있는 식권을 모두 소비하고, 다음 교환가능한 식권으로 계속 불가능할때까지 바꾸면서 최대한 많은 곰곰이를 먹이도록 구현했다.

치킨 -> 피자 -> 햄버거 순으로 교환이되는데, 문제를 서로 모든 종류의 음식에 대해 교환되는 줄 알고 잘못 이해해서 시간이 좀 걸렸다.


```cpp
// 백준: 곰곰이와 학식
// https://www.acmicpc.net/problem/26070
// 2024-02-20

#include <algorithm>
#include <iostream>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    long long A, B, C, X, Y, Z;
    cin >> A >> B >> C;
    cin >> X >> Y >> Z;

    long long fed = 0;

    // 식권 바로 사용
    long long minChicken = min(A, X);
    A -= minChicken;
    X -= minChicken;
    fed += minChicken;

    long long minPizza = min(B, Y);
    B -= minPizza;
    Y -= minPizza;
    fed += minPizza;

    long long minBurger = min(C, Z);
    C -= minBurger;
    Z -= minBurger;
    fed += minBurger;

    while (true) {
        bool exchanged = false;

        // 치킨 식권을 피자 식권으로 교환
        while (X >= 3) {
            X -= 3;
            // B--;
            Y++;
            // fed++;
            exchanged = true;
        }

        // 피자 식권 사용
        while (Y > 0 && B > 0) {
            Y--;
            B--;
            fed++;
            exchanged = true;
        }

        // 피자 식권을 햄버거 식권으로 교환
        while (Y >= 3) {
            Y -= 3;
            // C--;
            Z++;
            // fed++;
            exchanged = true;
        }

        // 햄버거 식권 사용
        while (Z > 0 && C > 0) {
            Z--;
            C--;
            fed++;
            exchanged = true;
        }

        // 햄버거 식권을 치킨 식권으로 교환
        while (Z >= 3) {
            Z -= 3;
            // A--;
            X++;
            // fed++;
            exchanged = true;
        }

        // 치킨 식권 사용
        while (X > 0 && A > 0) {
            X--;
            A--;
            fed++;
            exchanged = true;
        }

        if (!exchanged)
            break;
    }

    cout << fed;

    return 0;
}
```



- - -


### 프로그래머스 SQL

- 오늘의 SQL 문제 해결: **N문제**

### SQL에서의 비교 (IS, =)
SQL에서 IS 문은 NULL값을 비교할 때 쓰인다.
A != NULL로 하면 알 수 없는 값과 비교를 하는 것이기 때문에, 결과도 알 수 없음으로 평가된다.
따라서, NULL값을 비교할 때는 A IS NOT NULL로 해야한다.

= 은 존재하는 두 값을 비교할때에 쓰인다.

```sql
--이름이 NULL인 경우는 집계하지 않으며 중복되는 이름은 하나로 칩니다...
SELECT COUNT(DISTINCT NAME) AS count
FROM ANIMAL_INS
WHERE NAME IS NOT NULL;
```





### SUM과 COUNT
SQL에서 SUM은 숫자 데이터를 다루는 열에 대해, 합계 값을 얻을 때 쓴다.
COUNT는 해당 컬럼의 개수를 센다.

```sql
--동물 보호소에 동물이 몇 마리 들어왔는지 조회하는 SQL 문을 작성해주세요.
SELECT COUNT(ANIMAL_ID) AS count
FROM ANIMAL_INS;
```

```sql
--테이블에서 희귀도가 'LEGEND'인 아이템들의 가격의 총합을 구하는 SQL문
SELECT SUM(PRICE) AS TOTAL_PRICE
FROM ITEM_INFO
WHERE RARITY = 'LEGEND'
```



### CASE, WHEN, THEN, ELSE, END

```
테이블에서 2022년 10월 16일에 대여 중인 자동차인 경우 '대여중' 이라고 표시하고, 대여 중이지 않은 자동차인 경우 '대여 가능'을 표시하는 컬럼(컬럼명: AVAILABILITY)을 추가하여 자동차 ID와 AVAILABILITY 리스트를 출력하는 SQL문을 작성해주세요. 
```

```sql
SELECT 
    CAR_ID,
    MAX(
        CASE WHEN 
        '2022-10-16' BETWEEN START_DATE AND END_DATE
        THEN '대여중'
        ELSE '대여 가능'
        END
    ) AS AVAILABILITY 
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY 
GROUP BY CAR_ID
ORDER BY 1 DESC
```

GROUP BY로 CAR_ID로 묶을 때, 대여중과 대여 가능 두가지 상태가 겹칠 수 있는데. 이때 항상 대여중을 고르기 위해 MAX를 사용한다.

CASE WHEN (조건) THEN (TRUE면) ELSE (FALSE면) END. 
로 SQL에서 IF문을 사용할 수 있다.

```sql
SELECT
    CAR_ID,
    IF(
        COUNT(IF('2022-10-16' BETWEEN DATE_FORMAT(START_DATE, '%Y-%m-%d') AND DATE_FORMAT(END_DATE, '%Y-%m-%d'), 1, NULL)) > 0,
        '대여중',
        '대여 가능'
    ) AS AVAILABILITY
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
GROUP BY CAR_ID
ORDER BY CAR_ID DESC
```

위에서 사용된 IF문은 시작 기간과 종료 기간 사이에 2022-10-16이 있다면 1을 반환하고, 아니라면 NULL을 반환 하는데, 실질적으로 COUNT는 NULL이 아닌 값은 세지 않기 때문에. 이걸 다시 IF로 감싸고, COUNT 반환 값이 0 초과인지 확인하고. 초과라면 '대여중' 아니라면 '대여 가능' 으로 AS AVAILABILITY에 추가한다.

와 !! 
어렵다.


- 다시 메모
GROUP BY 는 집계 함수를 특정 기준으로 묶는데에 쓰인다.

```sql
SELECT
    A.AUTHOR_ID, A.AUTHOR_NAME, B.CATEGORY, SUM(B.PRICE * S.SALES) AS TOTAL_SALES
FROM
    BOOK B
INNER JOIN AUTHOR A ON B.AUTHOR_ID = A.AUTHOR_ID
INNER JOIN BOOK_SALES S ON S.BOOK_ID = B.BOOK_ID
WHERE
    S.SALES_DATE BETWEEN '2022-01-01' AND '2022-01-31'
GROUP BY A.AUTHOR_ID, B.CATEGORY
ORDER BY A.AUTHOR_ID ASC, B.CATEGORY DESC;
```


### IN 연산자
IN 연산자는 주어진 값 목록에서 하나라도 일치하는 값을 가진 행을 선택하는데에 사용된다.

```sql
SELECT column_names
FROM table_name
WHERE column_name IN (value1, value2, ..., valueN);
```


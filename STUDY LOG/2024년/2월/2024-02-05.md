# <span style="color:yellow">2024-02-05</span>

오늘은
- 자소서 마무리
- 업랜디

먼저, 프로젝트 계획서 작성을 완료했다. 심리학과 AI에 관련한 프로젝트다.
SW 마에스트로 지원 서류를 오늘 넣었다. 

그리고, 업랜디를 했다.


# 업다운 랜덤 디펜스 출제 목록
```
24446 알고리즘 수업 - 너비 우선 탐색 3 (해결 - BFS)
1986 체스 (실패 후 해결 - 시뮬레이션)
```


### 알고리즘 수업 - 너비 우선 탐색 3
알고리즘 수업 - 너비 우선 탐색 3은 BFS 기초 문제였다. 하나 깨달은 점은 adj 배열을 선언할 때 미리 크기를 할당해버리면 메모리 낭비라는 것. 인접 간선 배열은 정점의 수 N 미만일 수도 있기에 크기를 미리 할당하지 않기로.
``adj.assign(N + 1, std::vector<int>());``


### 체스
체스 문제는 체스판 N\*M과 각 기물의 위치(모두 상대편)가 주어졌을 때 안전한 칸이 몇개인지 출력하는 시뮬레이션 문제였다.

아주 무난하게 코드를 구성하고 있었는데, 시간(30분)내에 풀지 못해서 실패했다.
생각하는 속도를 키워야겠다. 로직을 구성하는데 시간이 많이 잡아먹힌 부분은 퀸의 경로에 다른 기물이 있으면 장애물이 되어서 더 효력을 미치지 못하는 것을 어떻게 구현할지 생각을 안하고 코드를 짰다. 그래서 중간에 코드를 한번 바꿨다. 이 과정에서 시간이 조금 잡아먹혔다.

그리고 행과 열, 2차원 배열 N\*M에 대해 어디가 X축이고 어디가 Y축인지 헷갈려서 시간을 조금 더 소요했다.
N\*M의 경우 N이 Y축, M이 X축인게 common sense처럼 받아들여진다.
행과 열의 경우 행이 Y축, 열이 X축이다. 이게 자꾸 헷갈린다.. :(

```cpp
// 백준: 체스
// https://www.acmicpc.net/problem/1986
// 2024-02-05

#include <algorithm>
#include <iostream>
#include <utility>
#include <vector>

std::vector<std::vector<int>> board_info;
std::vector<std::pair<int, int>> queens; // X, Y
std::vector<std::pair<int, int>> knights;

int k_dx[] = {1, -1, 1, -1, 2, -2, 2, -2};
int k_dy[] = {2, 2, -2, -2, 1, -1, -1, 1};

int q_dx[] = {0, 0, 1, -1, -1, -1, 1, 1};
int q_dy[] = {1, -1, 0, 0, -1, 1, -1, 1};

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    int height, width;
    std::cin >> height >> width;
    board_info.assign(height + 1, std::vector<int>(width + 1, 0)); // 0 안전 1 위험 2 퀸 3 나이트 4 폰
    // 퀸 입력
    int queen_num, knight_num, pawn_num;
    std::cin >> queen_num;
    for (int i = 1; i <= queen_num; ++i) {
        int x, y;
        std::cin >> y >> x;
        queens.push_back({x, y});
        board_info[y][x] = 2;
    }
    std::cin >> knight_num;
    for (int i = 1; i <= knight_num; ++i) {
        int x, y;
        std::cin >> y >> x;
        knights.push_back({x, y});
        board_info[y][x] = 3;
    }
    std::cin >> pawn_num;
    for (int i = 1; i <= pawn_num; ++i) {
        int x, y;
        std::cin >> y >> x;
        board_info[y][x] = 4;
    }

    // 퀸 경로 계산
    for (const auto q : queens) {
        for (int i = 0; i < 8; ++i) {
            int nx = q.first + q_dx[i];
            int ny = q.second + q_dy[i];
            while (1) {
                if (!(nx > 0 && ny > 0 && nx <= width && ny <= height))
                    break; // 맵 밖 종료
                if (board_info[ny][nx] == 4 || board_info[ny][nx] == 3)
                    break; // 장애물 종료
                board_info[ny][nx] = 1;
                nx += q_dx[i];
                ny += q_dy[i];
            }
        }
    }

    // 나이트 경로 계산
    for (const auto k : knights) {
        for (int i = 0; i < 8; ++i) {
            int nx = k.first + k_dx[i];
            int ny = k.second + k_dy[i];
            if (!(nx > 0 && ny > 0 && nx <= width && ny <= height))
                continue; // 맵 밖 스킵
            board_info[ny][nx] = 1;
        }
    }
    int count = 0;
    for (int i = 1; i <= height; ++i) {
        for (int j = 1; j <= width; ++j) {
            if (board_info[i][j] == 0)
                count++;
        }
    }

    std::cout << count;

    return 0;
}

```
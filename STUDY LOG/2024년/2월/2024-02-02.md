# <span style="color:yellow">2024-02-02</span>

오늘은 업랜디(업다운 랜덤 디펜스)를 할 것.

### 규칙
- 출제된 모든 문제를 기록하기
- 제한 시간내에 못 푼 문제 모두 풀어보기
- Reference 검색 금지
- 성공한 문제는 <성공>, 시간을 초과했지만 푼 문제는 <초과 성공>, 못 푼 문제는 <실패>로 기록한다.


# 업다운 디펜스 출제 목록
```
상범이의 우울 2811 (어제 실패 후 재도전)

```



상범이의 우울 문제는 푸는데에 자그마치 2시간 넘게 걸렸다.
시뮬레이션 문제는 재밌지만 나름 어려운 것 같다. 보통 복잡한 시뮬레이션을 요구하는 경우가 많은데.. 아무리 문제를 절차적으로 정리하고 해결해도 이전 절차에 대한 내 로직이 조금이라도 허점이 있으면 다음 절차도 꼬여 버리기에.. 

시뮬레이션 풀 때 제일 중요한 건
1. 절차적으로 완벽하게 생각하기.
2. 로직 검토하기

두개인 것 같다.

상범이의 우울 문제는 상범이의 기분 데이터가 일별로 주어지고 상범이가 (우울한 기간 * 2일) 만큼의 꽃을 우울이 시작되기 전날까지 줘야 기분이 괜찮아진다는 재밌는 설정이 있는 문제였다.
여기서 살짝 복잡해지는 요소는, 최장 우울 기간에 대해서는 (우울한 기간 * 2일)이 아니라 (우울한 기간 * 3일)까지 꽃을 줘야한다는 것이고, 만약 최장 우울 기간이 2개 이상이라면 그 중 제일 꽃을 많이 줄 수 있는 기간을 선택해 3T를 적용해야 한다는 것이다.

문제에서 요구하는 것은 상범이에게 꽃을 최대로 줄 수 있는 개수를 구하는 것이었다.

처음에는 아래와 같이 생각했다

1. 역순으로 맨 뒤에서부터 기분을 체크하면서 음수 연속(최장 기간) 세기
2. 꽃 정보 벡터를 만들고 일단 2T를 모든 기간에 적용하기
3. 만약 최장 우울 기간이 유일하다면, 그곳에 3T를 적용하기
4. 만약 최장 우울 기간이 여러개라면, 순회를 최장 우울 기간의 개수만큼 돌면서 각각 flower 벡터에 넣어보면서 현재 값과 비교해 최대 값 찾기


1번 2번까진 무난하게 구현했는데 3, 4번부터 꼬였다. 애초에 순회를 최장 우울 기간의 개수만큼 돌 필요도 없었을뿐더러. 로직도 되게 복잡하게 짜서 스파게티 코드가 되었다.

순회를 최장 우울 기간의 개수만큼 돌지 않고, 2T까지 끝낸 꽃의 개수를 변수 answer에 저장하고, 최장 우울 기간에 해당되는 구간을 만났을 때 3T로 인해 새로 생기는 꽃의 개수를 추적하면서, answer와 현재 꽃 + 새로 생기는 꽃에 대한 max를 계속 반복하면 되는 문제였다.

여러모로 많은 것을 느끼게 해준 문제였다. 골드 2면서 실버 3문제에 반나절 동안 고민하는 나에 대한 고찰도 그렇고 코딩에 대한 막막함도 그렇고..

코드를 3~4번은 완전히 갈아 엎고 처음부터 작성했다. 코드를 작성하기전에 문제 해결을 위한 절차적인 계획 수립이 얼마나 중요한지 크게 깨달았다.

```cpp
// 백준: 상범이의 우울
// https://www.acmicpc.net/problem/2811
// 2024-02-02
// 업랜디

#include <algorithm>
#include <iostream>
#include <vector>

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    int N;
    std::cin >> N;

    std::vector<int> feelings;
    std::vector<int> feelings_streak(N, 0);  // 연속된 우울 기간을 정리하는 벡터
    std::vector<bool> flower_days(N, false);
    int max_streak = 0;  // 최장 우울 기간을 저장하는 벡터

    // 상범이 기분 정보 입력
    for (int i = 0; i < N; ++i) {
        int temp;
        std::cin >> temp;
        feelings.push_back(temp);
    }

    // 연속된 음수를 feelings_streak에 카운트
    for (int i = N - 1; i >= 0; --i) {
        if (feelings[i] < 0) {
            if (i != N - 1)
                feelings_streak[i] = feelings_streak[i + 1] + 1;
            else
                feelings_streak[i] = 1;

            if (feelings_streak[i] > max_streak)
                max_streak = feelings_streak[i];
        }
    }

    int max_streak_count = 0;  // 최장 우울 기간이 유일한지 판단하기 위한 변수
    // 음수 -> 양수로 넘어갈 때(우울 기간이 시작될 때) 기간 *2 만큼 꽃 선물
    for (int i = N - 1; i >= 0; --i) {
        if (feelings[i] >= 0) {  // 현재 기분이 양수라면
            if (i + 1 < N) {     // Index Valid Check
                int streak_count = feelings_streak[i + 1];
                for (int j = 0; j < streak_count * 2; ++j) {
                    if (i - j >= 0)  // Index Valid Check
                        flower_days[i - j] = true;
                }
            }
        }
        // 최장 우울 기간 유일 판단
        if (feelings_streak[i] == max_streak) max_streak_count++;
    }

    int current_flowers = 0;  // 2T 까지의 꽃 개수를 추적하기 위함
    for (int i = 0; i < N; ++i) {
        if (flower_days[i]) current_flowers++;
    }

    int answer = current_flowers;

    // 최장 기간에 대해, 3T를 적용
    for (int i = N - 1; i >= 0; --i) {
        int new_flowers_on_this_case = 0;
        if (i + 1 < N && feelings_streak[i + 1] == max_streak) {
            for (int j = 0; j < max_streak * 3; ++j) {
                if (i - j >= 0) {  // Index Valid Check
                    if (!flower_days[i - j])
                        new_flowers_on_this_case++;  // 3T로 인해 새로
                                                     // 생기는 꽃의 개수를
                                                     // 업데이트
                    // flower_days[i - j] = true;
                }
            }
            answer =
                std::max(answer, current_flowers + new_flowers_on_this_case);
        }
    }

    // // 아래 코드는 생각해보니 필요가 없다.
    // 만약 최장 우울 기간이 유일하지 않다면
    // else if (max_streak_count > 1) {
    //     for (int i = N - 1; i >= 0; --i) {
    //         if (i + 1 < N && feelings_streak[i + 1] == max_streak) {
    //         }
    //     }
    // }

    // 디버깅
    // for (int next : flower_days) {
    //     std::cout << next << " ";
    // }

    std::cout << answer;

    return 0;
}
```

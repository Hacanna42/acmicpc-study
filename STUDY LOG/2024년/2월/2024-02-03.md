# <span style="color:yellow">2024-02-03</span>

- 3b1b의 manim에 대해 알게되었다
- 자소서 쓰기
- 실랜디 하기

앞으로, 어제 실랜디에서 푼 문제를 한번씩 검토하고 오늘의 실랜디를 시작하겠다.

# 업다운 디펜스 출제 목록
```
25370 카드 숫자 곱의 경우의 수 (해결 - 재귀 조합, 백트래킹 등)
19621 회의실 배정 2 (해결 - 그리디, DP)
16461 듀얼 채널 VHF 무전기 (실패 - 시뮬레이션)
```

25370 문제는 처음에 보고 약간 당황했다, 특정한 조합 식을 이용해서 구하는 줄 알았다.
근데 그냥 재귀로 풀면 되는 간단한 문제였다.

```cpp
// 백준: 카드 숫자 곱의 경우의 수
// https://www.acmicpc.net/problem/25370
// 2024-02-03

#include <iostream>
#include <set>

std::set<int> set;

void findCombinations(int L, int result) {
    if (L == 0) {
        set.insert(result);
        return;
    }

    for (int i = 1; i <= 9; ++i) {
        findCombinations(L - 1, result * i);
    }
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    int n;
    std::cin >> n;
    findCombinations(n, 1);
    std::cout << set.size();
    return 0;
}
```


내가 약한 부분의 기술을 사용할 것이라고 쉽게 판단하고 겁먹지 말자.


- - -


19621 (회의실 배정 2) 문제는 그리디 문제인 줄 알았다.
정확하게는, 그리디 + DP요소가 포함된 문제다. 기본적으로 회의실을 배정함에 있어 종료 시간을 기준으로 정렬해 찾아나가는게 그리디 접근법인데 여기선 회의 인원수를 최대로 하는 해를 찾아야 했다.

따라서, 그리디로 회의 시간표를 정렬 -> DP로 인원수를 최대로 하는 해를 찾았다

```cpp
// 백준: 회의실 배정 2
// https://www.acmicpc.net/problem/19621
// 2024-02-03

#include <algorithm>
#include <iostream>
#include <utility>
#include <vector>
std::vector<std::pair<std::pair<int, int>, int> >
    timetable;  // <<시작 시간, 종료시간>, 인원>
std::vector<int> dp;
int N;

int maxMan(int index) {
    if (index >= N) return 0;
    if (dp[index] != -1) return dp[index];

    int take = timetable[index].second + maxMan(index + 2);
    int skip = maxMan(index + 1);
    dp[index] = std::max(take, skip);
    return dp[index];
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    std::cin >> N;
    dp.assign(N, -1);
    for (int i = 0; i < N; ++i) {
        int start, end, num;
        std::cin >> start >> end >> num;
        timetable.push_back({{start, end}, num});
    }

    std::sort(timetable.begin(), timetable.end(),
              [](const std::pair<std::pair<int, int>, int>& a,
                 const std::pair<std::pair<int, int>, int>& b) {
                  return a.first.second < b.first.second;
              });

    std::cout << maxMan(0);
    return 0;
}
```


- - -


16461 듀얼 채널 VHF 무전기 문제는 실패했다.
처음에 경우의 수를 나누고 BFS같은걸로 푸는 문제인 줄 알았다.. 여러 갈래로 경우가 나뉘니까 ..?
근데 그냥 시뮬레이션으로 푸는 문제인 듯 하다.

무전기를 조작할 수 있는 모든 함수를 만들고, 브루트포스로 값을 구하는 단순 시뮬레이션 문제인 것 같다.

시뮬레이션 문제가 어렵긴 한데 재밌기도 한 것 같다. 그냥 구현하면 되니까 .. 근데 엣지 케이스같은게 있어서 조금 어려울수도 있겠다.

30분안에 푸는건 실패했고. 이제 다시 풀어보려고 한다.


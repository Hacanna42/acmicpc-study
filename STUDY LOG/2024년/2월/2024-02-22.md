# <span style="color:yellow">2024-02-22</span>

오늘은 나머지 SQL: String, Date를 풀고 개념을 정리해야겠다.
프로그래머스 SQL Kit에 몇가지 문제들이 추가됐다.

## <span style="color:royalblue">공부 계획</span>
- [x] **2월 20일** - SUM, MAX, MIN | GROUP BY 풀이 ✅ 2024-02-20
- [x] **2월 21일** - IS NULL | JOIN 풀이 ✅ 2024-02-21
- [ ] **2월 22일** - String, Date 풀고 SQL 복습 및 PS 복습
- [ ] **2월 23일** - 최종 복습 및 컨디션 관리. (주변 오브젝트 정리 및 리허설)



### 오늘의 업랜디
```
2784 가로 세로 퍼즐 (시간 초과 후 성공 - 구현, 브루트포스)
```



### 가로 세로 퍼즐
가로 세로 퍼즐은 가로x세로 조합이 단어가 되는 퍼즐을 완성시키는 문제. 단어 목록 6개가 주어지면 단어를 가로 혹은 세로로 적절하게 조합해서 만들 수 있는 단어 퍼즐을 출력해야한다.

만약, 만들 수 있는 단어 퍼즐이 하나가 아니라면 사전순으로 앞선 퍼즐을 출력한다.

이 문제는 아래와 같이 접근했다.
1. 먼저 퍼즐이 유효하고, 주어진 모든 단어를 하나씩 포함하는지 확인하는 bool 함수를 만들었다.
2. **가로**를 기준으로 가능한 모든 단어 조합을 Recursive DFS로 구현했다.
3. TC가 어차피 사전순으로 오기에, 사전순 출력은 따로 구현하지 않았다.

가로 단어를 브루트포스로 모든 경우에 대해 맞춰보고, 이후 세로도 올바르게 정렬되었는지 확인하는 방법으로 가능한 모든 경우의 수를 고려했다.

```cpp
// 백준: 가로 세로 퍼즐
// https://www.acmicpc.net/problem/2784
// 2024-02-22

#include <algorithm>
#include <iostream>
#include <map>
#include <string>
#include <vector>
using namespace std;
vector<string> str(6);
map<string, int> str_list;

bool check(vector<string> &info) {
    map<string, int> visited;
    int n = info.size();

    // 가로 조사
    for (int r = 0; r < n; ++r) {
        string temp = info[r];
        auto it = find(str.begin(), str.end(), temp);
        if (it != str.end()) {
            visited[temp] += 1;
        } else {
            return false;
        }
    }

    // 세로 조사
    for (int c = 0; c < n; ++c) {
        string temp = "";
        for (int r = 0; r < n; ++r) {
            temp += info[r][c];
        }
        auto it = find(str.begin(), str.end(), temp);
        if (it != str.end()) {
            visited[temp] += 1;
        } else {
            return false;
        }
    }

    return str_list == visited;
}

bool generateAndCheck(vector<string> &current, vector<bool> &used, int depth) {
    if (depth == 3) {
        return check(current);
    }

    for (int i = 0; i < 6; ++i) {
        if (!used[i]) {
            used[i] = true;
            current.push_back(str[i]);

            if (generateAndCheck(current, used, depth + 1)) {
                return true;
            }

            current.pop_back();
            used[i] = false;
        }
    }

    return false;
}

int main() {
    for (int i = 0; i < 6; ++i) {
        cin >> str[i];
        str_list[str[i]] += 1;
    }

    vector<string> current;
    vector<bool> used(6, false);
    if (generateAndCheck(current, used, 0)) {
        for (const auto &word : current) {
            cout << word << "\n";
        }
    } else {
        cout << "0";
    }

    return 0;
}
```

visited 배열을 bool을 쓰려다가, 중복 단어도 포함될 수도 있어서 map으로 숫자를 세는식으로 처리했고. 이후에 == 연산자를 사용해서 완전히 동일한지 확인했다.



### 프로그래머스 SQL
- 오늘의 SQL 문제 해결: **N 문제**
# <span style="color:yellow">2024-02-25</span>

##  <span style="color:violet">2차 공부 계획</span>
- [ ] 2월 25일 - [문제풀이집 1](https://www.acmicpc.net/workbook/view/10475) 풀이 (RGB 거리 ~ 오르막 수) **8문제**
- [ ] 2월 26일 - [문제풀이집 1](https://www.acmicpc.net/workbook/view/10475) 풀이 (오르막 수 ~ N과 M 시리즈) **10문제**
- [ ] 2월 27일 - [문제풀이집 1](https://www.acmicpc.net/workbook/view/10475) 완성. (N과 M 시리즈 ~ 끝) **8문제**
- [ ] 2월 28일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254) 되는대로 풀기.. **총 70문제 🤯**
- [ ] 2월 29일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254)
- [ ] 3월 1일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254)
- [ ] 3월 2일 - [SW 문제풀이집 2](https://www.acmicpc.net/workbook/view/18254)





오늘은, 지원대비 문제풀이집 1의 문제를 차근히 풀어보겠다.



### RGB거리 (1149)
이 문제는 선형적으로 놓여있는 집을 칠하는 비용 정보가 주어졌을 때, 아래의 조건을 만족하는 최소 비용을 구하는 DP 문제다.

```
- 1번 집의 색은 2번 집의 색과 같지 않아야 한다.
- N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
- i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.
```

DP는 정말 어렵고 이해가 안됐었는데. 이제 슬슬 감 잡을 것 같아서 기분이 좋다.
이 문제는 예전에 푼 뒤로 두번째로 푸는건데, 그때는 이해가 정말 안됐는데 지금은 이해가 완벽하게 돼서 기분이 좋다!

다이나믹 프로그래밍 문제는 대체적으로 어렵다.

문제 해결은 간단했다. 현재 칠하는 집이 i-1의 집과 색이 겹치면 안된다. i-1의 집과 색이 겹치는지 안 겹치는지 상태를 추적하려면 dp 배열을 2차원 배열로 **현재 칠하는 집의 지붕 색** 정보를 포함하도록 메모이제이션을 해야한다.

따라서, ``dp[i][c]`` 를 i번째 집을 색 c로 칠했을때까지의 최소 비용으로 정의하고. 기본 사례를 식별했다.
```cpp
    // RGB
    // 0 현재 집을 R로 색칠
    // 1 현재 집을 G로 색칠
    // 2 현재 집을 B로 색칠
    dp[1][0] = prices[1][0];
    dp[1][1] = prices[1][1];
    dp[1][2] = prices[1][2];
```

dp 2부터 반복을 돌리면서, 이번 집과 겹치지 않는 색 중에 더 적은 금액의 색을 선택하도록 구성했다.
큰 문제를 작은 하위 문제로 나누고, 작은 하위 문제의 해결을 통해 전체 문제의 해결책을 도출하는 DP 방식이다.

```cpp
// 백준: RGB거리
// https://www.acmicpc.net/problem/1149
// 2024-02-24
// 소마 대비

#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int N;
    cin >> N;
    vector<vector<int>> dp(N + 1, vector<int>(3));
    vector<vector<int>> prices(N + 1, vector<int>(3));
    for (int i = 1; i <= N; ++i) {
        cin >> prices[i][0] >> prices[i][1] >> prices[i][2];
    }
    /*
    1번 집의 색은 2번 집의 색과 같지 않아야 한다.
    N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
    i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.
    */

    // RGB
    // 0 현재 집을 R로 색칠
    // 1 현재 집을 G로 색칠
    // 2 현재 집을 B로 색칠

    dp[1][0] = prices[1][0];
    dp[1][1] = prices[1][1];
    dp[1][2] = prices[1][2];

    for (int i = 2; i <= N; ++i) {
        dp[i][0] = min(dp[i - 1][1], dp[i - 1][2]) + prices[i][0];
        dp[i][1] = min(dp[i - 1][0], dp[i - 1][2]) + prices[i][1];
        dp[i][2] = min(dp[i - 1][0], dp[i - 1][1]) + prices[i][2];
    }

    cout << min({dp[N][0], dp[N][1], dp[N][2]});

    return 0;
}
```


아래는, 앞으로 DP 문제 풀이에 도움이 될 것 같아 남겨놓는 글!

### 동적 프로그래밍(Dynamic Programming, DP)
##### 1. 문제 이해하기
- **문제를 완전하게 이해한다:** 문제의 조건과 요구사항, 주어진 예시를 통해 어떻게 문제가 해결되어야 하는지 분석하고 관계 파악하기.

##### 2. 작은 문제로 나누기
- **문제를 작은 문제로 나눈다**: DP는 큰 문제를 작은 하위 문제로 나누고, 하위 문제의 해결을 통해 전체 문제의 해결책을 도출하는 방법이다. 각 하위 문제가 어떻게 전체 문제에 기여하는지 고려해 본다.

##### 3. 점화식 찾기
- **기본 사례 식별하기**: 모든 DP 문제는 하나 이상의 기본 사례(base case)를 가지고 있다. 기본 사례는 직접적으로 해결할 수 있는 가장 작은 문제다.
- **점화식을 도출하기**: 점화식(recurrence relation)은 현재 문제의 해를 이전에 해결한 문제들의 해를 통해 어떻게 구할 수 있는지 나타낸다. 각 단계에서 가능한 선택을 고려하고, 각 선택이 결과에 어떠한 영향을 미치는 지 분석한다.

##### 4. 예제로 시뮬레이션하기
- **작은 문제로 시뮬레이션하기**: 문제를 해결하는 절차를 몇 가지 작은 예제에 적용해본다. 이를 통해 점화식의 올바름을 검증할 수 있다.




### 매우 중요한 팁
DP 문제에서 기본 사례를 설정할 때, 앞에 IF문을 써서 엣지 케이스 처리를 습관화하자.
```cpp
    if(N>=1) dp[0][0] = pascal[0][0];
    if(N>=2) dp[1][0] = pascal[0][0] + pascal[1][0];
    if(N>=2) dp[1][1] = pascal[0][0] + pascal[1][1];
```


- - -



### 정수 삼각형 (1932)
정수 삼각형 문제는 파스칼의 삼각형 구조에서 가장 값을 크게 만드는 경로의 최댓값을 구하는 DP 문제다.
꽤 감 잡았다. 이제 실버 DP문제는 금방금방 풀린다.

문제 이해도 간단했고, 작은 문제로 나누는 것도 쉬웠다.
현재 층에서 이전 층의 왼쪽 혹은 오른쪽중에 큰 값을 가져오면 되는 간단한 DP문제다.
``dp[r][i]``를 층 r에서, 인덱스 i의 최댓값으로 설정했다.

DP문제는 정말 **감**이 다인 것 같다. 느낌이 필요하다.

```cpp
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int N;
    cin >> N;
    vector<vector<int>> pascal(N, vector<int>(N)); // 층, 인덱스
    vector<vector<int>> dp(N, vector<int>(N));
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j <= i; ++j) {
            cin >> pascal[i][j];
        }
    }

    // BASE CASE
    if (N >= 1)
        dp[0][0] = pascal[0][0];
    if (N >= 2)
        dp[1][0] = pascal[0][0] + pascal[1][0];
    if (N >= 3)
        dp[1][1] = pascal[0][0] + pascal[1][1];

    for (int i = 2; i < N; ++i) {
        for (int j = 0; j <= i; ++j) {
            // EDGE CASE
            if (j == 0)
                dp[i][j] = dp[i - 1][j] + pascal[i][j];
            if (j == i)
                dp[i][j] = dp[i - 1][j - 1] + pascal[i][j];

            else {
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + pascal[i][j];
            }
        }
    }

    int answer = 0;
    for (int i = 0; i < dp[N - 1].size(); ++i) {
        answer = max(answer, dp[N - 1][i]);
    }

    cout << answer;

    return 0;
}
```
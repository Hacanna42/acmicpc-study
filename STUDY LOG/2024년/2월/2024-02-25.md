# <span style="color:yellow">2024-02-25</span>

##  <span style="color:violet">2ì°¨ ê³µë¶€ ê³„íš</span>
- [ ] 2ì›” 25ì¼ - [ë¬¸ì œí’€ì´ì§‘ 1](https://www.acmicpc.net/workbook/view/10475) í’€ì´ (RGB ê±°ë¦¬ ~ ì˜¤ë¥´ë§‰ ìˆ˜) **8ë¬¸ì œ**
- [ ] 2ì›” 26ì¼ - [ë¬¸ì œí’€ì´ì§‘ 1](https://www.acmicpc.net/workbook/view/10475) í’€ì´ (ì˜¤ë¥´ë§‰ ìˆ˜ ~ Nê³¼ M ì‹œë¦¬ì¦ˆ) **10ë¬¸ì œ**
- [ ] 2ì›” 27ì¼ - [ë¬¸ì œí’€ì´ì§‘ 1](https://www.acmicpc.net/workbook/view/10475) ì™„ì„±. (Nê³¼ M ì‹œë¦¬ì¦ˆ ~ ë) **8ë¬¸ì œ**
- [ ] 2ì›” 28ì¼ - [SW ë¬¸ì œí’€ì´ì§‘ 2](https://www.acmicpc.net/workbook/view/18254) ë˜ëŠ”ëŒ€ë¡œ í’€ê¸°.. **ì´ 70ë¬¸ì œ ğŸ¤¯**
- [ ] 2ì›” 29ì¼ - [SW ë¬¸ì œí’€ì´ì§‘ 2](https://www.acmicpc.net/workbook/view/18254)
- [ ] 3ì›” 1ì¼ - [SW ë¬¸ì œí’€ì´ì§‘ 2](https://www.acmicpc.net/workbook/view/18254)
- [ ] 3ì›” 2ì¼ - [SW ë¬¸ì œí’€ì´ì§‘ 2](https://www.acmicpc.net/workbook/view/18254)





ì˜¤ëŠ˜ì€, ì§€ì›ëŒ€ë¹„ ë¬¸ì œí’€ì´ì§‘ 1ì˜ ë¬¸ì œë¥¼ ì°¨ê·¼íˆ í’€ì–´ë³´ê² ë‹¤.



### RGBê±°ë¦¬ (1149)
ì´ ë¬¸ì œëŠ” ì„ í˜•ì ìœ¼ë¡œ ë†“ì—¬ìˆëŠ” ì§‘ì„ ì¹ í•˜ëŠ” ë¹„ìš© ì •ë³´ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ì•„ë˜ì˜ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ìµœì†Œ ë¹„ìš©ì„ êµ¬í•˜ëŠ” DP ë¬¸ì œë‹¤.

```
- 1ë²ˆ ì§‘ì˜ ìƒ‰ì€ 2ë²ˆ ì§‘ì˜ ìƒ‰ê³¼ ê°™ì§€ ì•Šì•„ì•¼ í•œë‹¤.
- Në²ˆ ì§‘ì˜ ìƒ‰ì€ N-1ë²ˆ ì§‘ì˜ ìƒ‰ê³¼ ê°™ì§€ ì•Šì•„ì•¼ í•œë‹¤.
- i(2 â‰¤ i â‰¤ N-1)ë²ˆ ì§‘ì˜ ìƒ‰ì€ i-1ë²ˆ, i+1ë²ˆ ì§‘ì˜ ìƒ‰ê³¼ ê°™ì§€ ì•Šì•„ì•¼ í•œë‹¤.
```

DPëŠ” ì •ë§ ì–´ë µê³  ì´í•´ê°€ ì•ˆëì—ˆëŠ”ë°. ì´ì œ ìŠ¬ìŠ¬ ê° ì¡ì„ ê²ƒ ê°™ì•„ì„œ ê¸°ë¶„ì´ ì¢‹ë‹¤.
ì´ ë¬¸ì œëŠ” ì˜ˆì „ì— í‘¼ ë’¤ë¡œ ë‘ë²ˆì§¸ë¡œ í‘¸ëŠ”ê±´ë°, ê·¸ë•ŒëŠ” ì´í•´ê°€ ì •ë§ ì•ˆëëŠ”ë° ì§€ê¸ˆì€ ì´í•´ê°€ ì™„ë²½í•˜ê²Œ ë¼ì„œ ê¸°ë¶„ì´ ì¢‹ë‹¤!

ë‹¤ì´ë‚˜ë¯¹ í”„ë¡œê·¸ë˜ë° ë¬¸ì œëŠ” ëŒ€ì²´ì ìœ¼ë¡œ ì–´ë µë‹¤.

ë¬¸ì œ í•´ê²°ì€ ê°„ë‹¨í–ˆë‹¤. í˜„ì¬ ì¹ í•˜ëŠ” ì§‘ì´ i-1ì˜ ì§‘ê³¼ ìƒ‰ì´ ê²¹ì¹˜ë©´ ì•ˆëœë‹¤. i-1ì˜ ì§‘ê³¼ ìƒ‰ì´ ê²¹ì¹˜ëŠ”ì§€ ì•ˆ ê²¹ì¹˜ëŠ”ì§€ ìƒíƒœë¥¼ ì¶”ì í•˜ë ¤ë©´ dp ë°°ì—´ì„ 2ì°¨ì› ë°°ì—´ë¡œ **í˜„ì¬ ì¹ í•˜ëŠ” ì§‘ì˜ ì§€ë¶• ìƒ‰** ì •ë³´ë¥¼ í¬í•¨í•˜ë„ë¡ ë©”ëª¨ì´ì œì´ì…˜ì„ í•´ì•¼í•œë‹¤.

ë”°ë¼ì„œ, ``dp[i][c]`` ë¥¼ ië²ˆì§¸ ì§‘ì„ ìƒ‰ cë¡œ ì¹ í–ˆì„ë•Œê¹Œì§€ì˜ ìµœì†Œ ë¹„ìš©ìœ¼ë¡œ ì •ì˜í•˜ê³ . ê¸°ë³¸ ì‚¬ë¡€ë¥¼ ì‹ë³„í–ˆë‹¤.
```cpp
    // RGB
    // 0 í˜„ì¬ ì§‘ì„ Rë¡œ ìƒ‰ì¹ 
    // 1 í˜„ì¬ ì§‘ì„ Gë¡œ ìƒ‰ì¹ 
    // 2 í˜„ì¬ ì§‘ì„ Bë¡œ ìƒ‰ì¹ 
    dp[1][0] = prices[1][0];
    dp[1][1] = prices[1][1];
    dp[1][2] = prices[1][2];
```

dp 2ë¶€í„° ë°˜ë³µì„ ëŒë¦¬ë©´ì„œ, ì´ë²ˆ ì§‘ê³¼ ê²¹ì¹˜ì§€ ì•ŠëŠ” ìƒ‰ ì¤‘ì— ë” ì ì€ ê¸ˆì•¡ì˜ ìƒ‰ì„ ì„ íƒí•˜ë„ë¡ êµ¬ì„±í–ˆë‹¤.
í° ë¬¸ì œë¥¼ ì‘ì€ í•˜ìœ„ ë¬¸ì œë¡œ ë‚˜ëˆ„ê³ , ì‘ì€ í•˜ìœ„ ë¬¸ì œì˜ í•´ê²°ì„ í†µí•´ ì „ì²´ ë¬¸ì œì˜ í•´ê²°ì±…ì„ ë„ì¶œí•˜ëŠ” DP ë°©ì‹ì´ë‹¤.

```cpp
// ë°±ì¤€: RGBê±°ë¦¬
// https://www.acmicpc.net/problem/1149
// 2024-02-24
// ì†Œë§ˆ ëŒ€ë¹„

#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int N;
    cin >> N;
    vector<vector<int>> dp(N + 1, vector<int>(3));
    vector<vector<int>> prices(N + 1, vector<int>(3));
    for (int i = 1; i <= N; ++i) {
        cin >> prices[i][0] >> prices[i][1] >> prices[i][2];
    }
    /*
    1ë²ˆ ì§‘ì˜ ìƒ‰ì€ 2ë²ˆ ì§‘ì˜ ìƒ‰ê³¼ ê°™ì§€ ì•Šì•„ì•¼ í•œë‹¤.
    Në²ˆ ì§‘ì˜ ìƒ‰ì€ N-1ë²ˆ ì§‘ì˜ ìƒ‰ê³¼ ê°™ì§€ ì•Šì•„ì•¼ í•œë‹¤.
    i(2 â‰¤ i â‰¤ N-1)ë²ˆ ì§‘ì˜ ìƒ‰ì€ i-1ë²ˆ, i+1ë²ˆ ì§‘ì˜ ìƒ‰ê³¼ ê°™ì§€ ì•Šì•„ì•¼ í•œë‹¤.
    */

    // RGB
    // 0 í˜„ì¬ ì§‘ì„ Rë¡œ ìƒ‰ì¹ 
    // 1 í˜„ì¬ ì§‘ì„ Gë¡œ ìƒ‰ì¹ 
    // 2 í˜„ì¬ ì§‘ì„ Bë¡œ ìƒ‰ì¹ 

    dp[1][0] = prices[1][0];
    dp[1][1] = prices[1][1];
    dp[1][2] = prices[1][2];

    for (int i = 2; i <= N; ++i) {
        dp[i][0] = min(dp[i - 1][1], dp[i - 1][2]) + prices[i][0];
        dp[i][1] = min(dp[i - 1][0], dp[i - 1][2]) + prices[i][1];
        dp[i][2] = min(dp[i - 1][0], dp[i - 1][1]) + prices[i][2];
    }

    cout << min({dp[N][0], dp[N][1], dp[N][2]});

    return 0;
}
```


ì•„ë˜ëŠ”, ì•ìœ¼ë¡œ DP ë¬¸ì œ í’€ì´ì— ë„ì›€ì´ ë  ê²ƒ ê°™ì•„ ë‚¨ê²¨ë†“ëŠ” ê¸€!

### ë™ì  í”„ë¡œê·¸ë˜ë°(Dynamic Programming, DP)
##### 1. ë¬¸ì œ ì´í•´í•˜ê¸°
- **ë¬¸ì œë¥¼ ì™„ì „í•˜ê²Œ ì´í•´í•œë‹¤:** ë¬¸ì œì˜ ì¡°ê±´ê³¼ ìš”êµ¬ì‚¬í•­, ì£¼ì–´ì§„ ì˜ˆì‹œë¥¼ í†µí•´ ì–´ë–»ê²Œ ë¬¸ì œê°€ í•´ê²°ë˜ì–´ì•¼ í•˜ëŠ”ì§€ ë¶„ì„í•˜ê³  ê´€ê³„ íŒŒì•…í•˜ê¸°.

##### 2. ì‘ì€ ë¬¸ì œë¡œ ë‚˜ëˆ„ê¸°
- **ë¬¸ì œë¥¼ ì‘ì€ ë¬¸ì œë¡œ ë‚˜ëˆˆë‹¤**: DPëŠ” í° ë¬¸ì œë¥¼ ì‘ì€ í•˜ìœ„ ë¬¸ì œë¡œ ë‚˜ëˆ„ê³ , í•˜ìœ„ ë¬¸ì œì˜ í•´ê²°ì„ í†µí•´ ì „ì²´ ë¬¸ì œì˜ í•´ê²°ì±…ì„ ë„ì¶œí•˜ëŠ” ë°©ë²•ì´ë‹¤. ê° í•˜ìœ„ ë¬¸ì œê°€ ì–´ë–»ê²Œ ì „ì²´ ë¬¸ì œì— ê¸°ì—¬í•˜ëŠ”ì§€ ê³ ë ¤í•´ ë³¸ë‹¤.

##### 3. ì í™”ì‹ ì°¾ê¸°
- **ê¸°ë³¸ ì‚¬ë¡€ ì‹ë³„í•˜ê¸°**: ëª¨ë“  DP ë¬¸ì œëŠ” í•˜ë‚˜ ì´ìƒì˜ ê¸°ë³¸ ì‚¬ë¡€(base case)ë¥¼ ê°€ì§€ê³  ìˆë‹¤. ê¸°ë³¸ ì‚¬ë¡€ëŠ” ì§ì ‘ì ìœ¼ë¡œ í•´ê²°í•  ìˆ˜ ìˆëŠ” ê°€ì¥ ì‘ì€ ë¬¸ì œë‹¤.
- **ì í™”ì‹ì„ ë„ì¶œí•˜ê¸°**: ì í™”ì‹(recurrence relation)ì€ í˜„ì¬ ë¬¸ì œì˜ í•´ë¥¼ ì´ì „ì— í•´ê²°í•œ ë¬¸ì œë“¤ì˜ í•´ë¥¼ í†µí•´ ì–´ë–»ê²Œ êµ¬í•  ìˆ˜ ìˆëŠ”ì§€ ë‚˜íƒ€ë‚¸ë‹¤. ê° ë‹¨ê³„ì—ì„œ ê°€ëŠ¥í•œ ì„ íƒì„ ê³ ë ¤í•˜ê³ , ê° ì„ íƒì´ ê²°ê³¼ì— ì–´ë– í•œ ì˜í–¥ì„ ë¯¸ì¹˜ëŠ” ì§€ ë¶„ì„í•œë‹¤.

##### 4. ì˜ˆì œë¡œ ì‹œë®¬ë ˆì´ì…˜í•˜ê¸°
- **ì‘ì€ ë¬¸ì œë¡œ ì‹œë®¬ë ˆì´ì…˜í•˜ê¸°**: ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ì ˆì°¨ë¥¼ ëª‡ ê°€ì§€ ì‘ì€ ì˜ˆì œì— ì ìš©í•´ë³¸ë‹¤. ì´ë¥¼ í†µí•´ ì í™”ì‹ì˜ ì˜¬ë°”ë¦„ì„ ê²€ì¦í•  ìˆ˜ ìˆë‹¤.




### ë§¤ìš° ì¤‘ìš”í•œ íŒ
DP ë¬¸ì œì—ì„œ ê¸°ë³¸ ì‚¬ë¡€ë¥¼ ì„¤ì •í•  ë•Œ, ì•ì— IFë¬¸ì„ ì¨ì„œ ì—£ì§€ ì¼€ì´ìŠ¤ ì²˜ë¦¬ë¥¼ ìŠµê´€í™”í•˜ì.
```cpp
    if(N>=1) dp[0][0] = pascal[0][0];
    if(N>=2) dp[1][0] = pascal[0][0] + pascal[1][0];
    if(N>=2) dp[1][1] = pascal[0][0] + pascal[1][1];
```


- - -



### ì •ìˆ˜ ì‚¼ê°í˜• (1932)
ì •ìˆ˜ ì‚¼ê°í˜• ë¬¸ì œëŠ” íŒŒìŠ¤ì¹¼ì˜ ì‚¼ê°í˜• êµ¬ì¡°ì—ì„œ ê°€ì¥ ê°’ì„ í¬ê²Œ ë§Œë“œëŠ” ê²½ë¡œì˜ ìµœëŒ“ê°’ì„ êµ¬í•˜ëŠ” DP ë¬¸ì œë‹¤.
ê½¤ ê° ì¡ì•˜ë‹¤. ì´ì œ ì‹¤ë²„ DPë¬¸ì œëŠ” ê¸ˆë°©ê¸ˆë°© í’€ë¦°ë‹¤.

ë¬¸ì œ ì´í•´ë„ ê°„ë‹¨í–ˆê³ , ì‘ì€ ë¬¸ì œë¡œ ë‚˜ëˆ„ëŠ” ê²ƒë„ ì‰¬ì› ë‹¤.
í˜„ì¬ ì¸µì—ì„œ ì´ì „ ì¸µì˜ ì™¼ìª½ í˜¹ì€ ì˜¤ë¥¸ìª½ì¤‘ì— í° ê°’ì„ ê°€ì ¸ì˜¤ë©´ ë˜ëŠ” ê°„ë‹¨í•œ DPë¬¸ì œë‹¤.
``dp[r][i]``ë¥¼ ì¸µ rì—ì„œ, ì¸ë±ìŠ¤ iì˜ ìµœëŒ“ê°’ìœ¼ë¡œ ì„¤ì •í–ˆë‹¤.

DPë¬¸ì œëŠ” ì •ë§ **ê°**ì´ ë‹¤ì¸ ê²ƒ ê°™ë‹¤. ëŠë‚Œì´ í•„ìš”í•˜ë‹¤.
```cpp
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int N;
    cin >> N;
    vector<vector<int>> pascal(N, vector<int>(N)); // ì¸µ, ì¸ë±ìŠ¤
    vector<vector<int>> dp(N, vector<int>(N));
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j <= i; ++j) {
            cin >> pascal[i][j];
        }
    }

    // BASE CASE
    if (N >= 1)
        dp[0][0] = pascal[0][0];
    if (N >= 2)
        dp[1][0] = pascal[0][0] + pascal[1][0];
    if (N >= 3)
        dp[1][1] = pascal[0][0] + pascal[1][1];

    for (int i = 2; i < N; ++i) {
        for (int j = 0; j <= i; ++j) {
            // EDGE CASE
            if (j == 0)
                dp[i][j] = dp[i - 1][j] + pascal[i][j];
            if (j == i)
                dp[i][j] = dp[i - 1][j - 1] + pascal[i][j];

            else {
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + pascal[i][j];
            }
        }
    }

    int answer = 0;
    for (int i = 0; i < dp[N - 1].size(); ++i) {
        answer = max(answer, dp[N - 1][i]);
    }

    cout << answer;

    return 0;
}
```



- - -

### DFSì™€ BFS
ì´ ë¬¸ì œëŠ” ê¸°ì´ˆ DFS + BFS ì‹œë®¬ ë¬¸ì œì¸ë°, ì¡°ê¸ˆ í•™ìŠµì  ì˜ë¯¸ë„ ê°€ì§ˆê²¸ ~~ì§€ì  ìœ í¬~~ë¥¼ ì¦ê²¼ë‹¤.
DFSëŠ” ê° í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ë§ˆë‹¤ ëœë¤ìœ¼ë¡œ Recursive DFSì™€ Stack DFSë¥¼ ë²ˆê°ˆì•„ê°€ë©´ì„œ ì‚¬ìš©í•˜ë„ë¡ êµ¬í˜„í–ˆê³ . BFSëŠ” Queueë¥¼ ì´ìš©í•´ì„œ êµ¬í˜„í–ˆë‹¤.

Stackì´ë‚˜ Queueë¥¼ ì¨ì„œ êµ¬í˜„í•  ë•Œ, Recursiveì²˜ëŸ¼ ë¶„ê¸° íƒìƒ‰ ì„±ê³µ ì§í›„ íƒ€ê³  ë“¤ì–´ê°€ì§€ ì•Šê¸° ë•Œë¬¸ì—, ë°©ë¬¸ ì²´í¬ì˜ ì‹œì ì— ì¡°ê¸ˆ ë” ì‹ ê²½ì„ ì¨ì•¼í•¨ì„ ëŠê¼ˆë‹¤.
ì´ë²ˆì— ë°©ë¬¸ ì²´í¬ë¥¼ .pop() ì´í›„ì— í•œë‹¤ê±°ë‚˜, ì•„ë‹ˆë©´ push() ìª½ì— í•œë‹¤ê±°ë‚˜ ì—¬ëŸ¬ê°€ì§€ ì‹œë„ë¥¼ í•´ë´¤ëŠ”ë°.

1. push ì´ì „/ì´í›„ ë°©ë¬¸ ì²´í¬
2. pop í•˜ê³  ê²€ìƒ‰ ì´ì „/ì´í›„ ë°©ë¬¸ ì²´í¬

ì´ë ‡ê²Œ ë‘ ê³³ì— ëŒ€í•´ ëª¨ë‘ ë°©ë¬¸ì²´í¬ í•´ì•¼ ì¤‘ë³µ íƒìƒ‰ì„ ë§‰ì„ ìˆ˜ ìˆì—ˆë‹¤. íŠ¹íˆ íƒìƒ‰ ìˆœì„œê°€ ì¤‘ìš”í•  ë•Œ ë§ì´ë‹¤..


##### 1. TCë¥¼ ì…ë ¥ë°›ê³ , ì‘ì€ ìˆœ íƒìƒ‰ì„ ìœ„í•´ sortí–ˆë‹¤.
```cpp
    int N, M, V;
    cin >> N >> M >> V;
    adj.assign(N + 1, vector<int>());

    for (int i = 0; i < M; ++i) {
        int to, from;
        cin >> to >> from;
        adj[to].push_back(from);
        adj[from].push_back(to);
    }

    for (int i = 1; i <= N; ++i) {
        sort(adj[i].begin(), adj[i].end());
    }
```


##### 2. Recursive DFS
```cpp
// ì¬ê·€ DFS
    vector<bool> visited_dfs_recursive(N + 1, false);
    vector<int> route_dfs_recursive;
    recursiveDFS(V, visited_dfs_recursive, route_dfs_recursive);

void recursiveDFS(int current, vector<bool> &visited, vector<int> &route) {
    visited[current] = true;
    route.push_back(current);

    for (const auto &next : adj[current]) {
        if (!visited[next]) { // ë°©ë¬¸ X
            recursiveDFS(next, visited, route);
        }
    }
}
```



##### 3. Stack DFS
```cpp
    // ìŠ¤íƒ DFS - (ì •ì ì´ ì‘ì€ ìˆœì„œëŒ€ë¡œ ë°©ë¬¸í•  ìˆ˜ ì—†ë‹¤. ì¸ì ‘ ì •ì ì„ ì—­ìˆœìœ¼ë¡œ íƒìƒ‰í•˜ë©´ ê°€ëŠ¥í•˜ë‹¤. ì¬ê·€ DFSëŠ” ì²«ë²ˆì§¸ íƒìƒ‰ëœ ë…¸ë“œ.
    // ì¦‰ ì™¼ìª½ ë¶„ê¸°ë¶€í„° íƒ€ê³  ë‚´ë ¤ê°€ì§€ë§Œ ìŠ¤íƒì€ í˜„ì¬ ë¶„ê¸°ì—ì„œ ë§ˆì§€ë§‰ìœ¼ë¡œ íƒìƒ‰ëœ ë…¸ë“œ. ì¦‰ ì˜¤ë¥¸ìª½ ë¶„ê¸°ë¶€í„° íƒ€ê³  ë‚´ë ¤ê°„ë‹¤.)
    vector<bool> visited_dfs_stack(N + 1, false);
    vector<int> route_dfs_stack;
    stack<int> s;
    s.push(V);

    while (!s.empty()) {
        int cur_v = s.top();
        s.pop();

        if (!visited_dfs_stack[cur_v]) {
            visited_dfs_stack[cur_v] = true; // ë°©ë¬¸ ì²˜ë¦¬
            route_dfs_stack.push_back(cur_v);

            for (auto it = adj[cur_v].rbegin(); it != adj[cur_v].rend(); ++it) {
                if (!visited_dfs_stack[*it]) {
                    s.push(*it);
                }
            }
        }
    }
```



##### 4. Queue BFS
```cpp
   // í BFS
    vector<bool> visited_bfs(N + 1, false);
    vector<int> route_bfs;
    queue<int> q;
    q.push(V);
    while (!q.empty()) {
        int cur_v = q.front();
        q.pop();

        if (!visited_bfs[cur_v]) { // ë°©ë¬¸í•˜ì§€ ì•Šì•˜ë‹¤ë©´
            visited_bfs[cur_v] = true;
            route_bfs.push_back(cur_v);

            for (const auto &next : adj[cur_v]) {
                if (!visited_bfs[next]) {
                    q.push(next);
                }
            }
        }
    }
```



##### 5. Random TC: ë²ˆê°ˆì•„ê°€ë©´ì„œ ì‚¬ìš©
```cpp
    std::random_device rd;
    std::mt19937 gen(rd());
    std::bernoulli_distribution dis(0.5);

    bool fun = dis(gen);

    if (fun) {
        for (auto &iter : route_dfs_recursive) {
            cout << iter << " ";
        }
    } else {
        for (auto &iter : route_dfs_stack) {
            cout << iter << " ";
        }
    }

    cout << "\n";
    for (auto &iter : route_bfs) {
        cout << iter << " ";
    }
```



ë°ì´í„°ì…‹ì´ ë°©ëŒ€í•œ ê²Œ ì•„ë‹ˆë¼ë©´ ì›¬ë§Œí•´ì„  Recursive DFSë¥¼ ì“°ì, Stack DFSëŠ” ìŠ¤íƒì˜¤ë²„í”Œë¡œìš°ì˜ ê±±ì •ì´ ì—†ëŠ” ëŒ€ì‹  ì‹ ê²½ì¨ì•¼ í•  ê²ƒì´ ë” ë§ê³ , êµ¬í˜„ì´ ë³µì¡í•˜ë‹¤.

ëª¨ë“  ìƒíƒœê°€ ìë™ìœ¼ë¡œ ì¸ìë¡œ ê·€ì†ë˜ëŠ” ì¬ê·€ DFSë¥¼ ì• ìš©í•˜ì !!!


##### ìµœì¢… ì½”ë“œ
```cpp
#include <algorithm>
#include <iostream>
#include <queue>
#include <random>
#include <stack>
#include <vector>
using namespace std;

vector<vector<int>> adj;

void recursiveDFS(int current, vector<bool> &visited, vector<int> &route) {
    visited[current] = true;
    route.push_back(current);

    for (const auto &next : adj[current]) {
        if (!visited[next]) { // ë°©ë¬¸ X
            recursiveDFS(next, visited, route);
        }
    }
}

int main() {
    int N, M, V;
    cin >> N >> M >> V;
    adj.assign(N + 1, vector<int>());

    for (int i = 0; i < M; ++i) {
        int to, from;
        cin >> to >> from;
        adj[to].push_back(from);
        adj[from].push_back(to);
    }

    for (int i = 1; i <= N; ++i) {
        sort(adj[i].begin(), adj[i].end());
    }

    // ì¬ê·€ DFS
    vector<bool> visited_dfs_recursive(N + 1, false);
    vector<int> route_dfs_recursive;
    recursiveDFS(V, visited_dfs_recursive, route_dfs_recursive);

    // ìŠ¤íƒ DFS - (ì •ì ì´ ì‘ì€ ìˆœì„œëŒ€ë¡œ ë°©ë¬¸í•  ìˆ˜ ì—†ë‹¤. ì¸ì ‘ ì •ì ì„ ì—­ìˆœìœ¼ë¡œ íƒìƒ‰í•˜ë©´ ê°€ëŠ¥í•˜ë‹¤. ì¬ê·€ DFSëŠ” ì²«ë²ˆì§¸ íƒìƒ‰ëœ ë…¸ë“œ.
    // ì¦‰ ì™¼ìª½ ë¶„ê¸°ë¶€í„° íƒ€ê³  ë‚´ë ¤ê°€ì§€ë§Œ ìŠ¤íƒì€ í˜„ì¬ ë¶„ê¸°ì—ì„œ ë§ˆì§€ë§‰ìœ¼ë¡œ íƒìƒ‰ëœ ë…¸ë“œ. ì¦‰ ì˜¤ë¥¸ìª½ ë¶„ê¸°ë¶€í„° íƒ€ê³  ë‚´ë ¤ê°„ë‹¤.)
    vector<bool> visited_dfs_stack(N + 1, false);
    vector<int> route_dfs_stack;
    stack<int> s;
    s.push(V);

    while (!s.empty()) {
        int cur_v = s.top();
        s.pop();

        if (!visited_dfs_stack[cur_v]) {
            visited_dfs_stack[cur_v] = true; // ë°©ë¬¸ ì²˜ë¦¬
            route_dfs_stack.push_back(cur_v);

            for (auto it = adj[cur_v].rbegin(); it != adj[cur_v].rend(); ++it) {
                if (!visited_dfs_stack[*it]) {
                    s.push(*it);
                }
            }
        }
    }

    // í BFS
    vector<bool> visited_bfs(N + 1, false);
    vector<int> route_bfs;
    queue<int> q;
    q.push(V);
    while (!q.empty()) {
        int cur_v = q.front();
        q.pop();

        if (!visited_bfs[cur_v]) { // ë°©ë¬¸í•˜ì§€ ì•Šì•˜ë‹¤ë©´
            visited_bfs[cur_v] = true;
            route_bfs.push_back(cur_v);

            for (const auto &next : adj[cur_v]) {
                if (!visited_bfs[next]) {
                    q.push(next);
                }
            }
        }
    }

    std::random_device rd;
    std::mt19937 gen(rd());
    std::bernoulli_distribution dis(0.5);

    bool fun = dis(gen);

    if (fun) {
        for (auto &iter : route_dfs_recursive) {
            cout << iter << " ";
        }
    } else {
        for (auto &iter : route_dfs_stack) {
            cout << iter << " ";
        }
    }

    cout << "\n";
    for (auto &iter : route_bfs) {
        cout << iter << " ";
    }

    return 0;
}
```




- - -



### ë‹¨ì§€ë²ˆí˜¸ë¶™ì´ê¸° (2667)

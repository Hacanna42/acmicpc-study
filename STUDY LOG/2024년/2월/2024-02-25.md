# <span style="color:yellow">2024-02-25</span>

##  <span style="color:violet">2ì°¨ ê³µë¶€ ê³„íš</span>
- [ ] 2ì›” 25ì¼ - [ë¬¸ì œí’€ì´ì§‘ 1](https://www.acmicpc.net/workbook/view/10475) í’€ì´ (RGB ê±°ë¦¬ ~ ì˜¤ë¥´ë§‰ ìˆ˜) **8ë¬¸ì œ**
- [ ] 2ì›” 26ì¼ - [ë¬¸ì œí’€ì´ì§‘ 1](https://www.acmicpc.net/workbook/view/10475) í’€ì´ (ì˜¤ë¥´ë§‰ ìˆ˜ ~ Nê³¼ M ì‹œë¦¬ì¦ˆ) **10ë¬¸ì œ**
- [ ] 2ì›” 27ì¼ - [ë¬¸ì œí’€ì´ì§‘ 1](https://www.acmicpc.net/workbook/view/10475) ì™„ì„±. (Nê³¼ M ì‹œë¦¬ì¦ˆ ~ ë) **8ë¬¸ì œ**
- [ ] 2ì›” 28ì¼ - [SW ë¬¸ì œí’€ì´ì§‘ 2](https://www.acmicpc.net/workbook/view/18254) ë˜ëŠ”ëŒ€ë¡œ í’€ê¸°.. **ì´ 70ë¬¸ì œ ğŸ¤¯**
- [ ] 2ì›” 29ì¼ - [SW ë¬¸ì œí’€ì´ì§‘ 2](https://www.acmicpc.net/workbook/view/18254)
- [ ] 3ì›” 1ì¼ - [SW ë¬¸ì œí’€ì´ì§‘ 2](https://www.acmicpc.net/workbook/view/18254)
- [ ] 3ì›” 2ì¼ - [SW ë¬¸ì œí’€ì´ì§‘ 2](https://www.acmicpc.net/workbook/view/18254)





ì˜¤ëŠ˜ì€, ì§€ì›ëŒ€ë¹„ ë¬¸ì œí’€ì´ì§‘ 1ì˜ ë¬¸ì œë¥¼ ì°¨ê·¼íˆ í’€ì–´ë³´ê² ë‹¤.



### RGBê±°ë¦¬ (1149)
ì´ ë¬¸ì œëŠ” ì„ í˜•ì ìœ¼ë¡œ ë†“ì—¬ìˆëŠ” ì§‘ì„ ì¹ í•˜ëŠ” ë¹„ìš© ì •ë³´ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ì•„ë˜ì˜ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ìµœì†Œ ë¹„ìš©ì„ êµ¬í•˜ëŠ” DP ë¬¸ì œë‹¤.

```
- 1ë²ˆ ì§‘ì˜ ìƒ‰ì€ 2ë²ˆ ì§‘ì˜ ìƒ‰ê³¼ ê°™ì§€ ì•Šì•„ì•¼ í•œë‹¤.
- Në²ˆ ì§‘ì˜ ìƒ‰ì€ N-1ë²ˆ ì§‘ì˜ ìƒ‰ê³¼ ê°™ì§€ ì•Šì•„ì•¼ í•œë‹¤.
- i(2 â‰¤ i â‰¤ N-1)ë²ˆ ì§‘ì˜ ìƒ‰ì€ i-1ë²ˆ, i+1ë²ˆ ì§‘ì˜ ìƒ‰ê³¼ ê°™ì§€ ì•Šì•„ì•¼ í•œë‹¤.
```

DPëŠ” ì •ë§ ì–´ë µê³  ì´í•´ê°€ ì•ˆëì—ˆëŠ”ë°. ì´ì œ ìŠ¬ìŠ¬ ê° ì¡ì„ ê²ƒ ê°™ì•„ì„œ ê¸°ë¶„ì´ ì¢‹ë‹¤.
ì´ ë¬¸ì œëŠ” ì˜ˆì „ì— í‘¼ ë’¤ë¡œ ë‘ë²ˆì§¸ë¡œ í‘¸ëŠ”ê±´ë°, ê·¸ë•ŒëŠ” ì´í•´ê°€ ì •ë§ ì•ˆëëŠ”ë° ì§€ê¸ˆì€ ì´í•´ê°€ ì™„ë²½í•˜ê²Œ ë¼ì„œ ê¸°ë¶„ì´ ì¢‹ë‹¤!

ë‹¤ì´ë‚˜ë¯¹ í”„ë¡œê·¸ë˜ë° ë¬¸ì œëŠ” ëŒ€ì²´ì ìœ¼ë¡œ ì–´ë µë‹¤.

ë¬¸ì œ í•´ê²°ì€ ê°„ë‹¨í–ˆë‹¤. í˜„ì¬ ì¹ í•˜ëŠ” ì§‘ì´ i-1ì˜ ì§‘ê³¼ ìƒ‰ì´ ê²¹ì¹˜ë©´ ì•ˆëœë‹¤. i-1ì˜ ì§‘ê³¼ ìƒ‰ì´ ê²¹ì¹˜ëŠ”ì§€ ì•ˆ ê²¹ì¹˜ëŠ”ì§€ ìƒíƒœë¥¼ ì¶”ì í•˜ë ¤ë©´ dp ë°°ì—´ì„ 2ì°¨ì› ë°°ì—´ë¡œ **í˜„ì¬ ì¹ í•˜ëŠ” ì§‘ì˜ ì§€ë¶• ìƒ‰** ì •ë³´ë¥¼ í¬í•¨í•˜ë„ë¡ ë©”ëª¨ì´ì œì´ì…˜ì„ í•´ì•¼í•œë‹¤.

ë”°ë¼ì„œ, ``dp[i][c]`` ë¥¼ ië²ˆì§¸ ì§‘ì„ ìƒ‰ cë¡œ ì¹ í–ˆì„ë•Œê¹Œì§€ì˜ ìµœì†Œ ë¹„ìš©ìœ¼ë¡œ ì •ì˜í•˜ê³ . ê¸°ë³¸ ì‚¬ë¡€ë¥¼ ì‹ë³„í–ˆë‹¤.
```cpp
    // RGB
    // 0 í˜„ì¬ ì§‘ì„ Rë¡œ ìƒ‰ì¹ 
    // 1 í˜„ì¬ ì§‘ì„ Gë¡œ ìƒ‰ì¹ 
    // 2 í˜„ì¬ ì§‘ì„ Bë¡œ ìƒ‰ì¹ 
    dp[1][0] = prices[1][0];
    dp[1][1] = prices[1][1];
    dp[1][2] = prices[1][2];
```

dp 2ë¶€í„° ë°˜ë³µì„ ëŒë¦¬ë©´ì„œ, ì´ë²ˆ ì§‘ê³¼ ê²¹ì¹˜ì§€ ì•ŠëŠ” ìƒ‰ ì¤‘ì— ë” ì ì€ ê¸ˆì•¡ì˜ ìƒ‰ì„ ì„ íƒí•˜ë„ë¡ êµ¬ì„±í–ˆë‹¤.
í° ë¬¸ì œë¥¼ ì‘ì€ í•˜ìœ„ ë¬¸ì œë¡œ ë‚˜ëˆ„ê³ , ì‘ì€ í•˜ìœ„ ë¬¸ì œì˜ í•´ê²°ì„ í†µí•´ ì „ì²´ ë¬¸ì œì˜ í•´ê²°ì±…ì„ ë„ì¶œí•˜ëŠ” DP ë°©ì‹ì´ë‹¤.

```cpp
// ë°±ì¤€: RGBê±°ë¦¬
// https://www.acmicpc.net/problem/1149
// 2024-02-24
// ì†Œë§ˆ ëŒ€ë¹„

#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int N;
    cin >> N;
    vector<vector<int>> dp(N + 1, vector<int>(3));
    vector<vector<int>> prices(N + 1, vector<int>(3));
    for (int i = 1; i <= N; ++i) {
        cin >> prices[i][0] >> prices[i][1] >> prices[i][2];
    }
    /*
    1ë²ˆ ì§‘ì˜ ìƒ‰ì€ 2ë²ˆ ì§‘ì˜ ìƒ‰ê³¼ ê°™ì§€ ì•Šì•„ì•¼ í•œë‹¤.
    Në²ˆ ì§‘ì˜ ìƒ‰ì€ N-1ë²ˆ ì§‘ì˜ ìƒ‰ê³¼ ê°™ì§€ ì•Šì•„ì•¼ í•œë‹¤.
    i(2 â‰¤ i â‰¤ N-1)ë²ˆ ì§‘ì˜ ìƒ‰ì€ i-1ë²ˆ, i+1ë²ˆ ì§‘ì˜ ìƒ‰ê³¼ ê°™ì§€ ì•Šì•„ì•¼ í•œë‹¤.
    */

    // RGB
    // 0 í˜„ì¬ ì§‘ì„ Rë¡œ ìƒ‰ì¹ 
    // 1 í˜„ì¬ ì§‘ì„ Gë¡œ ìƒ‰ì¹ 
    // 2 í˜„ì¬ ì§‘ì„ Bë¡œ ìƒ‰ì¹ 

    dp[1][0] = prices[1][0];
    dp[1][1] = prices[1][1];
    dp[1][2] = prices[1][2];

    for (int i = 2; i <= N; ++i) {
        dp[i][0] = min(dp[i - 1][1], dp[i - 1][2]) + prices[i][0];
        dp[i][1] = min(dp[i - 1][0], dp[i - 1][2]) + prices[i][1];
        dp[i][2] = min(dp[i - 1][0], dp[i - 1][1]) + prices[i][2];
    }

    cout << min({dp[N][0], dp[N][1], dp[N][2]});

    return 0;
}
```


ì•„ë˜ëŠ”, ì•ìœ¼ë¡œ DP ë¬¸ì œ í’€ì´ì— ë„ì›€ì´ ë  ê²ƒ ê°™ì•„ ë‚¨ê²¨ë†“ëŠ” ê¸€!

### ë™ì  í”„ë¡œê·¸ë˜ë°(Dynamic Programming, DP)
##### 1. ë¬¸ì œ ì´í•´í•˜ê¸°
- **ë¬¸ì œë¥¼ ì™„ì „í•˜ê²Œ ì´í•´í•œë‹¤:** ë¬¸ì œì˜ ì¡°ê±´ê³¼ ìš”êµ¬ì‚¬í•­, ì£¼ì–´ì§„ ì˜ˆì‹œë¥¼ í†µí•´ ì–´ë–»ê²Œ ë¬¸ì œê°€ í•´ê²°ë˜ì–´ì•¼ í•˜ëŠ”ì§€ ë¶„ì„í•˜ê³  ê´€ê³„ íŒŒì•…í•˜ê¸°.

##### 2. ì‘ì€ ë¬¸ì œë¡œ ë‚˜ëˆ„ê¸°
- **ë¬¸ì œë¥¼ ì‘ì€ ë¬¸ì œë¡œ ë‚˜ëˆˆë‹¤**: DPëŠ” í° ë¬¸ì œë¥¼ ì‘ì€ í•˜ìœ„ ë¬¸ì œë¡œ ë‚˜ëˆ„ê³ , í•˜ìœ„ ë¬¸ì œì˜ í•´ê²°ì„ í†µí•´ ì „ì²´ ë¬¸ì œì˜ í•´ê²°ì±…ì„ ë„ì¶œí•˜ëŠ” ë°©ë²•ì´ë‹¤. ê° í•˜ìœ„ ë¬¸ì œê°€ ì–´ë–»ê²Œ ì „ì²´ ë¬¸ì œì— ê¸°ì—¬í•˜ëŠ”ì§€ ê³ ë ¤í•´ ë³¸ë‹¤.

##### 3. ì í™”ì‹ ì°¾ê¸°
- **ê¸°ë³¸ ì‚¬ë¡€ ì‹ë³„í•˜ê¸°**: ëª¨ë“  DP ë¬¸ì œëŠ” í•˜ë‚˜ ì´ìƒì˜ ê¸°ë³¸ ì‚¬ë¡€(base case)ë¥¼ ê°€ì§€ê³  ìˆë‹¤. ê¸°ë³¸ ì‚¬ë¡€ëŠ” ì§ì ‘ì ìœ¼ë¡œ í•´ê²°í•  ìˆ˜ ìˆëŠ” ê°€ì¥ ì‘ì€ ë¬¸ì œë‹¤.
- **ì í™”ì‹ì„ ë„ì¶œí•˜ê¸°**: ì í™”ì‹(recurrence relation)ì€ í˜„ì¬ ë¬¸ì œì˜ í•´ë¥¼ ì´ì „ì— í•´ê²°í•œ ë¬¸ì œë“¤ì˜ í•´ë¥¼ í†µí•´ ì–´ë–»ê²Œ êµ¬í•  ìˆ˜ ìˆëŠ”ì§€ ë‚˜íƒ€ë‚¸ë‹¤. ê° ë‹¨ê³„ì—ì„œ ê°€ëŠ¥í•œ ì„ íƒì„ ê³ ë ¤í•˜ê³ , ê° ì„ íƒì´ ê²°ê³¼ì— ì–´ë– í•œ ì˜í–¥ì„ ë¯¸ì¹˜ëŠ” ì§€ ë¶„ì„í•œë‹¤.

##### 4. ì˜ˆì œë¡œ ì‹œë®¬ë ˆì´ì…˜í•˜ê¸°
- **ì‘ì€ ë¬¸ì œë¡œ ì‹œë®¬ë ˆì´ì…˜í•˜ê¸°**: ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ì ˆì°¨ë¥¼ ëª‡ ê°€ì§€ ì‘ì€ ì˜ˆì œì— ì ìš©í•´ë³¸ë‹¤. ì´ë¥¼ í†µí•´ ì í™”ì‹ì˜ ì˜¬ë°”ë¦„ì„ ê²€ì¦í•  ìˆ˜ ìˆë‹¤.




### ë§¤ìš° ì¤‘ìš”í•œ íŒ
DP ë¬¸ì œì—ì„œ ê¸°ë³¸ ì‚¬ë¡€ë¥¼ ì„¤ì •í•  ë•Œ, ì•ì— IFë¬¸ì„ ì¨ì„œ ì—£ì§€ ì¼€ì´ìŠ¤ ì²˜ë¦¬ë¥¼ ìŠµê´€í™”í•˜ì.
```cpp
    if(N>=1) dp[0][0] = pascal[0][0];
    if(N>=2) dp[1][0] = pascal[0][0] + pascal[1][0];
    if(N>=2) dp[1][1] = pascal[0][0] + pascal[1][1];
```


- - -



### ì •ìˆ˜ ì‚¼ê°í˜• (1932)
ì •ìˆ˜ ì‚¼ê°í˜• ë¬¸ì œëŠ” íŒŒìŠ¤ì¹¼ì˜ ì‚¼ê°í˜• êµ¬ì¡°ì—ì„œ ê°€ì¥ ê°’ì„ í¬ê²Œ ë§Œë“œëŠ” ê²½ë¡œì˜ ìµœëŒ“ê°’ì„ êµ¬í•˜ëŠ” DP ë¬¸ì œë‹¤.
ê½¤ ê° ì¡ì•˜ë‹¤. ì´ì œ ì‹¤ë²„ DPë¬¸ì œëŠ” ê¸ˆë°©ê¸ˆë°© í’€ë¦°ë‹¤.

ë¬¸ì œ ì´í•´ë„ ê°„ë‹¨í–ˆê³ , ì‘ì€ ë¬¸ì œë¡œ ë‚˜ëˆ„ëŠ” ê²ƒë„ ì‰¬ì› ë‹¤.
í˜„ì¬ ì¸µì—ì„œ ì´ì „ ì¸µì˜ ì™¼ìª½ í˜¹ì€ ì˜¤ë¥¸ìª½ì¤‘ì— í° ê°’ì„ ê°€ì ¸ì˜¤ë©´ ë˜ëŠ” ê°„ë‹¨í•œ DPë¬¸ì œë‹¤.
``dp[r][i]``ë¥¼ ì¸µ rì—ì„œ, ì¸ë±ìŠ¤ iì˜ ìµœëŒ“ê°’ìœ¼ë¡œ ì„¤ì •í–ˆë‹¤.

DPë¬¸ì œëŠ” ì •ë§ **ê°**ì´ ë‹¤ì¸ ê²ƒ ê°™ë‹¤. ëŠë‚Œì´ í•„ìš”í•˜ë‹¤.
```cpp
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int N;
    cin >> N;
    vector<vector<int>> pascal(N, vector<int>(N)); // ì¸µ, ì¸ë±ìŠ¤
    vector<vector<int>> dp(N, vector<int>(N));
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j <= i; ++j) {
            cin >> pascal[i][j];
        }
    }

    // BASE CASE
    if (N >= 1)
        dp[0][0] = pascal[0][0];
    if (N >= 2)
        dp[1][0] = pascal[0][0] + pascal[1][0];
    if (N >= 3)
        dp[1][1] = pascal[0][0] + pascal[1][1];

    for (int i = 2; i < N; ++i) {
        for (int j = 0; j <= i; ++j) {
            // EDGE CASE
            if (j == 0)
                dp[i][j] = dp[i - 1][j] + pascal[i][j];
            if (j == i)
                dp[i][j] = dp[i - 1][j - 1] + pascal[i][j];

            else {
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + pascal[i][j];
            }
        }
    }

    int answer = 0;
    for (int i = 0; i < dp[N - 1].size(); ++i) {
        answer = max(answer, dp[N - 1][i]);
    }

    cout << answer;

    return 0;
}
```



- - -

### DFSì™€ BFS
ì´ ë¬¸ì œëŠ” ê¸°ì´ˆ DFS + BFS ì‹œë®¬ ë¬¸ì œì¸ë°, ì¡°ê¸ˆ í•™ìŠµì  ì˜ë¯¸ë„ ê°€ì§ˆê²¸ ~~ì§€ì  ìœ í¬~~ë¥¼ ì¦ê²¼ë‹¤.
DFSëŠ” ê° í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ë§ˆë‹¤ ëœë¤ìœ¼ë¡œ Recursive DFSì™€ Stack DFSë¥¼ ë²ˆê°ˆì•„ê°€ë©´ì„œ ì‚¬ìš©í•˜ë„ë¡ êµ¬í˜„í–ˆê³ . BFSëŠ” Queueë¥¼ ì´ìš©í•´ì„œ êµ¬í˜„í–ˆë‹¤.

Stackì´ë‚˜ Queueë¥¼ ì¨ì„œ êµ¬í˜„í•  ë•Œ, Recursiveì²˜ëŸ¼ ë¶„ê¸° íƒìƒ‰ ì„±ê³µ ì§í›„ íƒ€ê³  ë“¤ì–´ê°€ì§€ ì•Šê¸° ë•Œë¬¸ì—, ë°©ë¬¸ ì²´í¬ì˜ ì‹œì ì— ì¡°ê¸ˆ ë” ì‹ ê²½ì„ ì¨ì•¼í•¨ì„ ëŠê¼ˆë‹¤.
ì´ë²ˆì— ë°©ë¬¸ ì²´í¬ë¥¼ .pop() ì´í›„ì— í•œë‹¤ê±°ë‚˜, ì•„ë‹ˆë©´ push() ìª½ì— í•œë‹¤ê±°ë‚˜ ì—¬ëŸ¬ê°€ì§€ ì‹œë„ë¥¼ í•´ë´¤ëŠ”ë°.

1. push ì´ì „ì— ì¤‘ë³µ íƒìƒ‰ì„ ë°©ì§€í•˜ê¸° ìœ„í•œ ë°©ë¬¸ ì²´í¬
2. pop í•˜ê³  ê²€ìƒ‰ ì´ì „/ì´í›„ ë°©ë¬¸ ì²´í¬

ì´ë ‡ê²Œ ë‘ ê³³ì— ëŒ€í•´ ëª¨ë‘ ë°©ë¬¸ì²´í¬ í•´ì•¼ ì¤‘ë³µ íƒìƒ‰ì„ ë§‰ì„ ìˆ˜ ìˆì—ˆë‹¤. íŠ¹íˆ íƒìƒ‰ ìˆœì„œê°€ ì¤‘ìš”í•  ë•Œ ë§ì´ë‹¤..


##### 1. TCë¥¼ ì…ë ¥ë°›ê³ , ì‘ì€ ìˆœ íƒìƒ‰ì„ ìœ„í•´ sortí–ˆë‹¤.
```cpp
    int N, M, V;
    cin >> N >> M >> V;
    adj.assign(N + 1, vector<int>());

    for (int i = 0; i < M; ++i) {
        int to, from;
        cin >> to >> from;
        adj[to].push_back(from);
        adj[from].push_back(to);
    }

    for (int i = 1; i <= N; ++i) {
        sort(adj[i].begin(), adj[i].end());
    }
```


##### 2. Recursive DFS
```cpp
// ì¬ê·€ DFS
    vector<bool> visited_dfs_recursive(N + 1, false);
    vector<int> route_dfs_recursive;
    recursiveDFS(V, visited_dfs_recursive, route_dfs_recursive);

void recursiveDFS(int current, vector<bool> &visited, vector<int> &route) {
    visited[current] = true;
    route.push_back(current);

    for (const auto &next : adj[current]) {
        if (!visited[next]) { // ë°©ë¬¸ X
            recursiveDFS(next, visited, route);
        }
    }
}
```



##### 3. Stack DFS
```cpp
    // ìŠ¤íƒ DFS - (ì •ì ì´ ì‘ì€ ìˆœì„œëŒ€ë¡œ ë°©ë¬¸í•  ìˆ˜ ì—†ë‹¤. ì¸ì ‘ ì •ì ì„ ì—­ìˆœìœ¼ë¡œ íƒìƒ‰í•˜ë©´ ê°€ëŠ¥í•˜ë‹¤. ì¬ê·€ DFSëŠ” ì²«ë²ˆì§¸ íƒìƒ‰ëœ ë…¸ë“œ.
    // ì¦‰ ì™¼ìª½ ë¶„ê¸°ë¶€í„° íƒ€ê³  ë‚´ë ¤ê°€ì§€ë§Œ ìŠ¤íƒì€ í˜„ì¬ ë¶„ê¸°ì—ì„œ ë§ˆì§€ë§‰ìœ¼ë¡œ íƒìƒ‰ëœ ë…¸ë“œ. ì¦‰ ì˜¤ë¥¸ìª½ ë¶„ê¸°ë¶€í„° íƒ€ê³  ë‚´ë ¤ê°„ë‹¤.)
    vector<bool> visited_dfs_stack(N + 1, false);
    vector<int> route_dfs_stack;
    stack<int> s;
    s.push(V);

    while (!s.empty()) {
        int cur_v = s.top();
        s.pop();

        if (!visited_dfs_stack[cur_v]) {
            visited_dfs_stack[cur_v] = true; // ë°©ë¬¸ ì²˜ë¦¬
            route_dfs_stack.push_back(cur_v);

            for (auto it = adj[cur_v].rbegin(); it != adj[cur_v].rend(); ++it) {
                if (!visited_dfs_stack[*it]) {
                    s.push(*it);
                }
            }
        }
    }
```



##### 4. Queue BFS
```cpp
   // í BFS
    vector<bool> visited_bfs(N + 1, false);
    vector<int> route_bfs;
    queue<int> q;
    q.push(V);
    while (!q.empty()) {
        int cur_v = q.front();
        q.pop();

        if (!visited_bfs[cur_v]) { // ë°©ë¬¸í•˜ì§€ ì•Šì•˜ë‹¤ë©´
            visited_bfs[cur_v] = true;
            route_bfs.push_back(cur_v);

            for (const auto &next : adj[cur_v]) {
                if (!visited_bfs[next]) {
                    q.push(next);
                }
            }
        }
    }
```



##### 5. Random TC: ë²ˆê°ˆì•„ê°€ë©´ì„œ ì‚¬ìš©
```cpp
    std::random_device rd;
    std::mt19937 gen(rd());
    std::bernoulli_distribution dis(0.5);

    bool fun = dis(gen);

    if (fun) {
        for (auto &iter : route_dfs_recursive) {
            cout << iter << " ";
        }
    } else {
        for (auto &iter : route_dfs_stack) {
            cout << iter << " ";
        }
    }

    cout << "\n";
    for (auto &iter : route_bfs) {
        cout << iter << " ";
    }
```



ë°ì´í„°ì…‹ì´ ë°©ëŒ€í•œ ê²Œ ì•„ë‹ˆë¼ë©´ ì›¬ë§Œí•´ì„  Recursive DFSë¥¼ ì“°ì, Stack DFSëŠ” ìŠ¤íƒì˜¤ë²„í”Œë¡œìš°ì˜ ê±±ì •ì´ ì—†ëŠ” ëŒ€ì‹  ì‹ ê²½ì¨ì•¼ í•  ê²ƒì´ ë” ë§ê³ , êµ¬í˜„ì´ ë³µì¡í•˜ë‹¤.

ëª¨ë“  ìƒíƒœê°€ ìë™ìœ¼ë¡œ ì¸ìë¡œ ê·€ì†ë˜ëŠ” ì¬ê·€ DFSë¥¼ ì• ìš©í•˜ì !!!


##### ìµœì¢… ì½”ë“œ
```cpp
#include <algorithm>
#include <iostream>
#include <queue>
#include <random>
#include <stack>
#include <vector>
using namespace std;

vector<vector<int>> adj;

void recursiveDFS(int current, vector<bool> &visited, vector<int> &route) {
    visited[current] = true;
    route.push_back(current);

    for (const auto &next : adj[current]) {
        if (!visited[next]) { // ë°©ë¬¸ X
            recursiveDFS(next, visited, route);
        }
    }
}

int main() {
    int N, M, V;
    cin >> N >> M >> V;
    adj.assign(N + 1, vector<int>());

    for (int i = 0; i < M; ++i) {
        int to, from;
        cin >> to >> from;
        adj[to].push_back(from);
        adj[from].push_back(to);
    }

    for (int i = 1; i <= N; ++i) {
        sort(adj[i].begin(), adj[i].end());
    }

    // ì¬ê·€ DFS
    vector<bool> visited_dfs_recursive(N + 1, false);
    vector<int> route_dfs_recursive;
    recursiveDFS(V, visited_dfs_recursive, route_dfs_recursive);

    // ìŠ¤íƒ DFS - (ì •ì ì´ ì‘ì€ ìˆœì„œëŒ€ë¡œ ë°©ë¬¸í•  ìˆ˜ ì—†ë‹¤. ì¸ì ‘ ì •ì ì„ ì—­ìˆœìœ¼ë¡œ íƒìƒ‰í•˜ë©´ ê°€ëŠ¥í•˜ë‹¤. ì¬ê·€ DFSëŠ” ì²«ë²ˆì§¸ íƒìƒ‰ëœ ë…¸ë“œ.
    // ì¦‰ ì™¼ìª½ ë¶„ê¸°ë¶€í„° íƒ€ê³  ë‚´ë ¤ê°€ì§€ë§Œ ìŠ¤íƒì€ í˜„ì¬ ë¶„ê¸°ì—ì„œ ë§ˆì§€ë§‰ìœ¼ë¡œ íƒìƒ‰ëœ ë…¸ë“œ. ì¦‰ ì˜¤ë¥¸ìª½ ë¶„ê¸°ë¶€í„° íƒ€ê³  ë‚´ë ¤ê°„ë‹¤.)
    vector<bool> visited_dfs_stack(N + 1, false);
    vector<int> route_dfs_stack;
    stack<int> s;
    s.push(V);

    while (!s.empty()) {
        int cur_v = s.top();
        s.pop();

        if (!visited_dfs_stack[cur_v]) {
            visited_dfs_stack[cur_v] = true; // ë°©ë¬¸ ì²˜ë¦¬
            route_dfs_stack.push_back(cur_v);

            for (auto it = adj[cur_v].rbegin(); it != adj[cur_v].rend(); ++it) {
                if (!visited_dfs_stack[*it]) {
                    s.push(*it);
                }
            }
        }
    }

    // í BFS
    vector<bool> visited_bfs(N + 1, false);
    vector<int> route_bfs;
    queue<int> q;
    q.push(V);
    while (!q.empty()) {
        int cur_v = q.front();
        q.pop();

        if (!visited_bfs[cur_v]) { // ë°©ë¬¸í•˜ì§€ ì•Šì•˜ë‹¤ë©´
            visited_bfs[cur_v] = true;
            route_bfs.push_back(cur_v);

            for (const auto &next : adj[cur_v]) {
                if (!visited_bfs[next]) {
                    q.push(next);
                }
            }
        }
    }

    std::random_device rd;
    std::mt19937 gen(rd());
    std::bernoulli_distribution dis(0.5);

    bool fun = dis(gen);

    if (fun) {
        for (auto &iter : route_dfs_recursive) {
            cout << iter << " ";
        }
    } else {
        for (auto &iter : route_dfs_stack) {
            cout << iter << " ";
        }
    }

    cout << "\n";
    for (auto &iter : route_bfs) {
        cout << iter << " ";
    }

    return 0;
}
```




- - -



### ë‹¨ì§€ë²ˆí˜¸ë¶™ì´ê¸° (2667)
ë‹¨ì§€ ë²ˆí˜¸ ë¶™ì´ê¸° ë¬¸ì œëŠ” 2ì°¨ì› ë§µì— ì•„íŒŒíŠ¸ê°€ ìˆëŠ” ìœ„ì¹˜ê°€ ì£¼ì–´ì§ˆ ë•Œ, ì¸ì ‘í•œ ì•„íŒŒíŠ¸ë¥¼ ë‹¨ì§€ë¼ê³  í•˜ê³ .
1. ì´ ë‹¨ì§€ì˜ ê°œìˆ˜
2. ê° ë‹¨ì§€ì˜ ì•„íŒŒíŠ¸ ìˆ˜

ë¥¼ returní•˜ëŠ” ë¬¸ì œ.

DFS / BFS ë¡œ ê°„ë‹¨í•˜ê²Œ í’€ ìˆ˜ ìˆëŠ” ë¬¸ì œì˜€ë‹¤

ê·¼ë° ì²« ì‹œë„ì— ì‚¬ì†Œí•œ ì‹¤ìˆ˜ë¥¼ í–ˆë‹¤. while ë¬¸ ì¡°ê±´ ì²´í¬ì— ``!q.empty()``ê°€ ì•„ë‹ˆë¼ ``q.empty()``ë¥¼ ì‚¬ìš©í–ˆë‹¤. ì •ë§ ë°”ë³´ê°™ì€ ì‹¤ìˆ˜ë‹¤... ì‹¤ì „ì—ì„œ ì´ëŸ° ì‹¤ìˆ˜ í•˜ë©´ ì •ë§ ê°„ë‹¨í•œ ê²ƒì— ì‹œê°„ ì†Œë¹„ë¥¼ ë§ì´ í•  ê²ƒ ê°™ë‹¤.

ë˜, ë°©ë¬¸ ì²´í¬ì—ì„œ ì™¸ë¶€ for ë£¨í”„ì— ì“°ì´ëŠ” ì¸ë±ìŠ¤ë“¤ì„ ì‚¬ìš©í–ˆë‹¤. while ë‚´ë¶€ì—ì„œ q.frontí•´ì„œ ì–»ì€ current ê°’ë“¤ì„ ì¨ì•¼í•˜ëŠ”ë°.. ë°”ë³´ ê°™ì•˜ë‹¤. ì´ëŸ° ì‹¤ìˆ˜ë¥¼ ìµœëŒ€í•œ ì¤„ì´ë„ë¡ ë…¸ë ¥í•˜ê² ë‹¤ :(

```cpp
#include <algorithm>
#include <iostream>
#include <queue>
#include <string>
#include <utility>
#include <vector>
using namespace std;

int dc[4] = {1, -1, 0, 0};
int dr[4] = {0, 0, 1, -1};

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int N;
    cin >> N;
    vector<vector<int>> map(N, vector<int>(N, 0));
    for (int r = 0; r < N; ++r) {
        string temp;
        cin >> temp;
        for (int c = 0; c < N; ++c) {
            map[r][c] = temp[c] - '0';
        }
    }

    int complex_num = 0;
    vector<int> house_nums;

    for (int r = 0; r < N; ++r) {
        for (int c = 0; c < N; ++c) {
            if (map[r][c] == 1) {
                int count = 0;
                complex_num++;
                queue<pair<int, int>> q; // r, c
                q.push({r, c});

                while (!q.empty()) {
                    int current_r = q.front().first;
                    int current_c = q.front().second;
                    q.pop();

                    if (map[current_r][current_c] == 1) {
                        map[current_r][current_c] = 0; // ì§‘ì„ ì—†ì•° (ë°©ë¬¸ í‘œì‹œ)
                        count++;

                        for (int i = 0; i < 4; ++i) {
                            int next_r = current_r + dr[i];
                            int next_c = current_c + dc[i];

                            // VALID CHECK
                            if (next_r >= 0 && next_c >= 0 && next_r < N && next_c < N) {
                                if (map[next_r][next_c] == 1) { // ì§‘ì´ ì¡´ì¬í•´ì•¼ë§Œ
                                    q.push({next_r, next_c});
                                }
                            }
                        }
                    }
                }
                house_nums.push_back(count);
            }
        }
    }

    sort(house_nums.begin(), house_nums.end());
    cout << complex_num << "\n";
    for (const auto &house : house_nums) {
        cout << house << "\n";
    }

    return 0;
}
```





### ìˆ¨ë°”ê¼­ì§ˆ (1697)
**ìµœë‹¨ ê±°ë¦¬ ë¬¸ì œì—ì„œì˜ DFS / BFSì— ëŒ€í•´ì„œ:**
- **DFS**ëŠ” ê°€ëŠ¥í•œ ëª¨ë“  ê²½ë¡œë¥¼ ê³ ë ¤í•˜ê³ , ëª¨ë“  ë£¨íŠ¸ì— ëŒ€í•´ ëê¹Œì§€ íƒìƒ‰í•´ì•¼ë§Œ ìµœë‹¨ ê±°ë¦¬ë¥¼ ë„ì¶œí•´ë‚¼ ìˆ˜ ìˆê¸° ë•Œë¬¸ì—, ìµœë‹¨ ê±°ë¦¬ ë¬¸ì œì—ì„œ DFSëŠ” **ëŒ€ì²´ì ìœ¼ë¡œ ë¹„íš¨ìœ¨ì **ì´ê³ . ë¶ˆí•„ìš”í•œ ë£¨íŠ¸ì— ëŒ€í•´ì„œë„ íƒìƒ‰í•  ìˆ˜ ìˆë‹¤.
- **BFS**ëŠ” ì‹œì‘ ì§€ì ì—ì„œë¶€í„° ì ì°¨ì ìœ¼ë¡œ ëª¨ë“  ê°€ëŠ¥í•œ ìœ„ì¹˜ë¥¼ ê³ ë ¤í•˜ê¸° ë•Œë¬¸ì—, ì²˜ìŒ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ì‹œê°„ì´ ê³§ ìµœë‹¨ê±°ë¦¬ê°€ ëœë‹¤. ë”°ë¼ì„œ, ë¶ˆí•„ìš”í•œ ë£¨íŠ¸ì— ëŒ€í•´ ê¹Šê²Œ íƒìƒ‰í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ìµœë‹¨ ê±°ë¦¬ ë¬¸ì œì—ì„œ **ëŒ€ì²´ì ìœ¼ë¡œ íš¨ìœ¨ì ì´ë‹¤**


ìˆ¨ë°”ê¼­ì§ˆ ë¬¸ì œëŠ” ìˆ˜ë¹ˆì´ì˜ ì¢Œí‘œì™€ ë™ìƒì˜ ì¢Œí‘œê°€ 1ì°¨ì›ì ìœ¼ë¡œ ì£¼ì–´ì¡Œì„ ë•Œ, ê°€ëŠ¥í•œ ì´ë™ ë°©ë²•: ê±·ê¸°, ìˆœê°„ì´ë™ì„ íƒí•´ ê°€ì¥ ë¹ ë¥´ê²Œ ë™ìƒì—ê²Œ ë„ë‹¬í•  ìˆ˜ ìˆëŠ” ì‹œê°„ì„ ì°¾ëŠ” ë¬¸ì œë‹¤.

BFSë¥¼ í’€ ìˆ˜ ìˆëŠ” ë§¤ìš° ê°„ë‹¨í•œ ë¬¸ì œì§€ë§Œ, ìµœë‹¨ ê±°ë¦¬ ë¬¸ì œì—ì„œ ì–´ë–¤ ê·¸ë˜í”„ ìˆœíšŒ í˜•íƒœë¥¼ ì‚¬ìš©í•´ì•¼ í•˜ëŠ”ì§€ ê¹¨ë‹¬ì„ ìˆ˜ ìˆëŠ” ë¬¸ì œë‹¤.

ì•„, ê·¸ë¦¬ê³  ì‹œê°„ì„ queueì™€ ê°™ì´ ì¶”ì í•˜ëŠ” ìŠ¤í‚¬ë„ ë°°ìš¸ ìˆ˜ ìˆë‹¤.

```cpp
#include <iostream>
#include <queue>
#include <utility>
#include <vector>

using namespace std;

int main() {
    int N, K;
    cin >> N >> K;
    vector<bool> visited(100001, false);

    queue<pair<int, int>> q;
    q.push({N, 0});
    while (!q.empty()) {
        int cur_pos = q.front().first;
        int cur_time = q.front().second;
        q.pop();

        if (cur_pos == K) {
            cout << cur_time;
            break;
        }

        if (!visited[cur_pos]) {
            visited[cur_pos] = true;
            if (cur_pos - 1 >= 0 && !visited[cur_pos - 1])
                q.push({cur_pos - 1, cur_time + 1});
            if (cur_pos + 1 <= 100000 && !visited[cur_pos + 1])
                q.push({cur_pos + 1, cur_time + 1});
            if (cur_pos * 2 <= 100000 && !visited[cur_pos * 2])
                q.push({cur_pos * 2, cur_time + 1});
        }
    }

    return 0;
}
```




### 01íƒ€ì¼ (1904)
- ì½”ë“œëŠ” ì‰½ì§€ë§Œ, ë„ì¶œ ê³¼ì •ì´ í¥ë¯¸ë¡œìš´ êµìœ¡ì ì¸ ë¬¸ì œ.

01 íƒ€ì¼ì€ 0ì´ ì¨ìˆëŠ” íƒ€ì¼ê³¼ 1ì´ ì¨ìˆëŠ” íƒ€ì¼ì„ ë¬´ì œí•œìœ¼ë¡œ ì‚¬ìš©í•´ì„œ ê¸¸ì´ Nì˜ ì´ì§„ìˆ˜ë¥¼ ë§Œë“¤ ìˆ˜ ìˆëŠ” ê°€ì§“ìˆ˜ë¥¼ ì–»ëŠ” ë¬¸ì œë‹¤. ë‹¨, ëˆ„êµ°ê°€ê°€ ì¥ë‚œìœ¼ë¡œ 0íƒ€ì¼ì„ ë‘ê°œì”© ë¶™ì—¬ë†”ì„œ 00íƒ€ì¼ë§Œ ì“¸ ìˆ˜ ìˆê²Œ ë˜ì—ˆë‹¤.

#### ë„ì¶œ ê³¼ì •:
1. DP[\i] = cë¥¼ Nì´ iì¼ë•Œì˜ ì´ ê°€ì§“ìˆ˜ cë¡œ ì •ì˜í–ˆë‹¤.
2. ê¸°ë³¸ ì‚¬ë¡€ë“¤ì„ ì‚´í´ë³´ë©´, ``dp[1]=1, dp[2]=2, dp[3]=3, dp[4]=5... ìˆœì´ë‹¤``
3. í˜„ì¬ ê¸¸ì´ iì—ì„œ ê°€ëŠ¥í•œ ê°€ì§“ìˆ˜ëŠ” ì´ì „ i-1ì˜ DISTINCT(ì´ì§„ìˆ˜ì˜ ì• í˜¹ì€ ë’¤ì— 1ì„ ë¶™ì´ëŠ” ê²½ìš°ì˜ ìˆ˜ + ì´ì „ i-2ì˜ ì´ì§„ìˆ˜ì˜ ì• í˜¹ì€ ë’¤ì— 00ì„ ë¶™ì´ëŠ” ê²½ìš°ì˜ ìˆ˜) ë¼ê³  ìƒê°í–ˆë‹¤.
4. ì´í›„, ì¡°ê¸ˆ ë” ì í™”ì‹ì„ í™•ì‹¤íˆ í–ˆë‹¤. ``dp[i-2]ì˜ ë’¤ì— 00ì„ ë¶™ì´ëŠ” ìˆ˜ + dp[i-1]ì˜ ë’¤ì— 1ì„ ë¶™ì´ëŠ” ìˆ˜ = dp[i]ì˜ ê°€ì§“ìˆ˜`` ì˜€ë‹¤.
5. ê·¸ë ‡ë‹¤ë©´ dp[5] = 8ì´ë‹¤.
6. ``1, 2, 3, 5, 8 | dp[i] = dp[i-2] + dp[i-1]``  í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´ì˜ ì í™”ì‹ê³¼ ë™ì¼í•˜ë‹¤.


```cpp
#include <iostream>
#include <vector>
#define MOD 15746
using namespace std;

int main() {
    int N;
    cin >> N;
    vector<int> dp(N + 1);
    dp[1] = 1;
    dp[2] = 2;
    for (int i = 3; i <= N; ++i) {
        dp[i] = ((dp[i - 1] % MOD) + (dp[i - 2] % MOD)) % MOD;
    }
    cout << dp[N];
    return 0;
}
```

ì •ë§ í¥ë¯¸ë¡œìš´ ë¬¸ì œë‹¤. DPë¥¼ ì‘ì€ ë¬¸ì œë¡œ ë‚˜ëˆŒë•Œì—ëŠ”, ë§¨ ë’¤ì—ì„œë¶€í„° ìƒê°í•˜ëŠ”ê²ƒì´ ë„ì›€ì´ ë  ìˆ˜ë„ ìˆê² ë‹¤.
ë§Œì•½ ë§ˆì§€ë§‰ í•œìë¦¬ë§Œ ë‚¨ì•˜ë‹¤ë©´ 1ë§Œ ì˜¬ ìˆ˜ ìˆê¸° ë•Œë¬¸ì—, i-1ì— 1ì„ ì¶”ê°€í•  ìˆ˜ ìˆëŠ” ìˆ˜ê°€ ì˜¬ ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì´ ì„±ë¦½í•˜ê³ . ë§Œì•½ ë§ˆì§€ë§‰ ë‘ìë¦¬ë§Œ ë‚¨ì•˜ë‹¤ë©´ 00ê³¼ 1ì´ ì˜¬ ìˆ˜ ìˆì§€ë§Œ, 1ì´ ì˜¤ëŠ” ê²½ìš°ëŠ” ì´ë¯¸ i-1ì—ì„œ ì¶”ê°€í–ˆê¸° ë•Œë¬¸ì— ë’¤ì— 00ì´ ì˜¤ëŠ” ê²½ìš°ì˜ ìˆ˜ë§Œ ì¶”ê°€ëœë‹¤.

ë”°ë¼ì„œ í•´ë‹¹ ì‹ì€ ê¸¸ì´ê°€ kë¼ê³  í•  ë•Œ k-2ì—ì„œ 00ë¥¼ ë”í•œ ê²½ìš° + k-1ì—ì„œ 1ì„ ë”í•œ ê²½ìš°ì˜ í•©ìœ¼ë¡œ ë³¼ ìˆ˜ ìˆê¸° ë•Œë¬¸ì— í”¼ë³´ë‚˜ì¹˜ì˜ ìˆ˜ì—´ê³¼ ë™ì¼í•˜ë‹¤.

í¥ë¯¸ë¡­ë‹¤.



- - -


### ë™ì „ 1(2293)

# <span style="color:yellow">2024-02-15</span>

오늘은 SQL을 꼭 공부하기로 !
- 프로그래머스 BFS/DFS 나머지 문제 풀기
- 이분탐색 풀기
- SQL 강의 듣기
- 업랜디 ~


### 오늘의 업랜디
```
17610 양팔저울 (시간초과 후 해결 - 브루트포스)
```


### 오늘의 프로그래머스
```
- 깊이/너비 우선 탐색(BFS/DFS)
단어 변환 (Lv. 3)
아이템 줍기 (Lv. 3)
여행 경로 (Lv. 3)
퍼즐 조각 채우기 (Lv. 3)
```



### 양팔저울
양팔 저울은 추 정보가 담긴 배열이 주어지면, 양팔 저울 위에 어떤 조합으로든 올려놔서 특정 무게를 만들 수 있는 경우의 수를 구하는 문제였다.
처음엔 매우 복잡한 DP 문제인 줄 알았으나, 그냥 브루트포스 재귀 호출로 풀 수 있는 문제였다.
실수를 해서 시간내에 풀 지 못했다.. 바로 백트래킹을 쓴 것.
이 문제에선 백트래킹을 쓸 필요가 없다.. current를 0으로 시작하고, 다음 인덱스 값을 빼거나, 더하거나 하면서 depth++; 로 재귀를 돌리면 끝나는 문제였다.

근데 나는 정말 바보같게도, visited 배열을 선언해놓고 모든 추에 대해 for문을 돌리면서 해당 추를 더하거나, 빼거나, 스킵하거나 세가지의 경우를 반복문에서 재귀호출 하고 있었다.

그야말로 미친 효율의 알고리즘을 만들어버렸다. 엄청난 실수였다.

그냥 인덱스\[depth\] 부터 보면서, 더하거나 빼거나 스킵하면서 재귀 호출을 해도 충분히 풀리는 문제였고, 이렇게 할 이유가 없었다...

다음부턴 이런 실수 하지 않겠다.

```cpp
// 백준: 양팔저울
// https://www.acmicpc.net/problem/17610
// 2024-02-15

#include <cmath>
#include <iostream>
#include <set>
#include <vector>
using namespace std;

int k;
int S = 0;

set<int> combi;
vector<int> weights;
int answer = 0;

void calculate(int depth, int current) {
    if (current >= 1) {
        if (combi.find(current) == combi.end()) {
            answer++;
            combi.insert(current);
        }
    }

    if (depth == k)
        return;

    calculate(depth + 1, current + weights[depth]);
    calculate(depth + 1, current - weights[depth]);
    calculate(depth + 1, current);
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    cin >> k;
    weights.assign(k, 0);
    for (int i = 0; i < k; ++i) {
        cin >> weights[i];
        S += weights[i];
    }

    calculate(0, 0);

    cout << S - answer;

    return 0;
}
```


### 단어 변환
단어 변환 문제는, 시작 단어와 목표 단어, 그리고 거쳐갈 수 있는 단어들의 목록이 주어졌을 때. 현재의 단어에서 한자리만 바꿔서 갈 수 있는 단어 목록의 단어들을 거치면서 목표 단어로 가는 최단거리를 구하는 문제다.

문제가 참신해서 약간 겁먹었지만, BFS를 사용해서 쉽게 풀 수 있었다.
어디서부터 풀어야 할지 모르겠으면, 문제의 요구사항을 충족시킬 수 있는 함수부터 만들자! (이번 경우에는 단어의 알파벳 차이가 한자리만 나는지 판별하는 bool isConvertable 함수를 먼저 작성했다)

```cpp
bool isConvertable(string a, string b) {
    int c = 0;
    for (int i=0;i<a.size() && c<2;++i) {
        if (a[i]!=b[i]) ++c;
    }
    return !(c==2 || c==0);
}


int solution(string begin, string target, vector<string> words) {
    queue<pair<string, int>> q;
    vector<bool> visited(words.size(), false);
    q.push({begin, 0});
    
    while (!q.empty()) {
        string current_word = q.front().first;
        int current_w = q.front().second;
        q.pop();
        
        if (current_word == target) return current_w;
        
        for (int i=0;i<words.size();++i) {
            if (!visited[i] && isConvertable(current_word, words[i])) { // 방문하지 않았고, 변환 가능하면
                q.push({words[i], current_w+1});
                visited[i] = true;
            }
        }
    }

    return 0;
}
```





### 으악
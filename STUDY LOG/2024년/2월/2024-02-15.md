# <span style="color:yellow">2024-02-15</span>

오늘은 SQL을 꼭 공부하기로 !
- 프로그래머스 BFS/DFS 나머지 문제 풀기
- 이분탐색 풀기
- SQL 강의 듣기
- 업랜디 ~


### 오늘의 업랜디
```
17610 양팔저울 (시간초과 후 해결 - 브루트포스)
```


### 오늘의 프로그래머스
```
- 깊이/너비 우선 탐색(BFS/DFS)
단어 변환 (Lv. 3)
아이템 줍기 (Lv. 3)
여행 경로 (Lv. 3)
퍼즐 조각 채우기 (Lv. 3)
```



### 양팔저울
양팔 저울은 추 정보가 담긴 배열이 주어지면, 양팔 저울 위에 어떤 조합으로든 올려놔서 특정 무게를 만들 수 있는 경우의 수를 구하는 문제였다.
처음엔 매우 복잡한 DP 문제인 줄 알았으나, 그냥 브루트포스 재귀 호출로 풀 수 있는 문제였다.
실수를 해서 시간내에 풀 지 못했다.. 바로 백트래킹을 쓴 것.
이 문제에선 백트래킹을 쓸 필요가 없다.. current를 0으로 시작하고, 다음 인덱스 값을 빼거나, 더하거나 하면서 depth++; 로 재귀를 돌리면 끝나는 문제였다.

근데 나는 정말 바보같게도, visited 배열을 선언해놓고 모든 추에 대해 for문을 돌리면서 해당 추를 더하거나, 빼거나, 스킵하거나 세가지의 경우를 반복문에서 재귀호출 하고 있었다.

그야말로 미친 효율의 알고리즘을 만들어버렸다. 엄청난 실수였다.

그냥 인덱스\[depth\] 부터 보면서, 더하거나 빼거나 스킵하면서 재귀 호출을 해도 충분히 풀리는 문제였고, 이렇게 할 이유가 없었다...

다음부턴 이런 실수 하지 않겠다.

```cpp
// 백준: 양팔저울
// https://www.acmicpc.net/problem/17610
// 2024-02-15

#include <cmath>
#include <iostream>
#include <set>
#include <vector>
using namespace std;

int k;
int S = 0;

set<int> combi;
vector<int> weights;
int answer = 0;

void calculate(int depth, int current) {
    if (current >= 1) {
        if (combi.find(current) == combi.end()) {
            answer++;
            combi.insert(current);
        }
    }

    if (depth == k)
        return;

    calculate(depth + 1, current + weights[depth]);
    calculate(depth + 1, current - weights[depth]);
    calculate(depth + 1, current);
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    cin >> k;
    weights.assign(k, 0);
    for (int i = 0; i < k; ++i) {
        cin >> weights[i];
        S += weights[i];
    }

    calculate(0, 0);

    cout << S - answer;

    return 0;
}
```

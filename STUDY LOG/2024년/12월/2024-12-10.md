# <span style="color:yellow">2024-12-10</span>

### 최종 코딩테스트 이전 목표
- [ ] 4시간만에 다음 문제 풀어보기: [페어매칭관리 애플리케이션](https://github.com/woowacourse/java-pairmatching-precourse)
- [ ] 4시간만에 다음 문제 풀어보기: [다리건너기](https://github.com/bark20/java-bridge)
- [ ] 4시간만에 다음 문제 풀어보기: [점심 메뉴 추천](https://github.com/70825/java-menu)


### 오늘 할 것
- [ ] Java 자료구조 정리하기 (비선형 자료구조, 선형 자료구조... )
- [ ] 알고리즘 문제를 C++와 Java로 번갈아가며 풀어보기


- - -

선형 자료구조
1. 정적 배열: 기본적인 배열, 선언 시 크기가 고정된 연속된 메모리 공간을 할당하고 인덱스 기반이므로 데이터 접근 속도가 O(1). 하지만 삽입과 삭제가 비효율적O(n), 배열을 이동하거나 새로 생성해야 함.
2. 동적 배열(List): 내부적으로 배열이지만 동적으로 사이즈를 변경하는 구현이 포함되어있음.
3. 연결리스트: 배열의 단점을 보완하기 위해 각 노드가 자신의 다음 노드와 이전 노드를 참조하고 있음. 따라서 삭제나 삽입 과정은 참조를 변경하는 것으로 해결 가능. 하지만, 연속된 메모리 공간을 할당하지 않기 때문에 조회에 O(N)이 소요됨. 
4. 스택: Stack인데 내부적으로 배열이나 연결리스트로 구현됨.
5. 큐: Queue인데 내부적으로 LinkedList나 PriorityQueue로 구현됨
6. 덱: Deque인데 내부적으로 배열로 구현됨.




 - - -

페어매칭관리 애플리케이션 구현 시작


## 구현할 기능 목록  
### 입력 역할  
- [ ] 기능 선택 기능  
- [ ] 과정, 레벨, 미션 입력 기능  
- [ ] 페어 재매칭 시도 입력 기능  
  
### 출력 역할  
- [ ] 과정, 레벨, 미션 현황 출력 기능  
- [ ] 에러메시지 출력 기능  
- [ ] 페어 매칭 결과 출력 기능  
  
### 파일 입출력 역할  
- [ ] .md 파일을 읽고 파싱하는 기능  
  
### Course 역할  
- 제공된 그대로 사용 예정. BACKEND와 FRONTEND를 열거 형태로 갖고 있음.  
  
### 페어 매칭 내역을 관리하는 역할  
- [ ] 각 레벨별, 미션별 페어 매칭 내역을 효과적으로 저장한다.  
- [ ] 그것을 관리하는 다양한 메서드를 포함하고 있다.  
  
### 단일 크루 역할  
- [ ] 크루의 Course 정보를 필드에 가지고 있다.  
- [ ] 크루의 이름 정보를 필드에 가지고 있다.  
  
### 매칭된 페어 크루를 저장하는 역할  
- [ ] 매칭된 크루를 저장한 자료구조(아마 2차원 배열)를 필드에 가지고 있다.  
- [ ] 이와 관련된 메서드를 포함하고 있다.  
  
  
### 고민점  
이미 매칭된 페어랑은 같은 레벨에서 다신 매칭 안되게 해야한다.    
이를 구현하려면 같은 레벨에 대해 페어 매칭 내역을 계속 가지고 있어야 한다.    
즉 이를 효과적으로 저장해야 할 자료구조가 필요하다.    
이를 위해 객체 "MatchingStatus" 를 선언하고 내부 구현을 다음과 같이 한다:    
레벨을 Key로 가지고 있는 Map을 선언하고, 그 Map의 Value에는 미션이 Key,    
매칭된 페어 목록이 Value인 Map을 가지고 있으면 괜찮을 것 같다.    
약간은 복잡하지만 이렇게 되면 같은 레벨에 대해 페어 매칭 내역을 효과적으로 관리할 수 있다.

# <span style="color:yellow">2024-10-29</span>
2주차 끝!
코드리뷰의 시간이다. (새벽)


코드리뷰를 너무 많은 분들이 달아주셨다..! 7분이.. 총 63개의 conversation을 ..... (주륵)
자고 일어나서 다 코드리뷰 반사 해드려야겠다! 


#### 일어나서
1. 코드리뷰 반사
2. 과제 파악
3. 오브젝트 책 읽기 


- - -

일어나서 코드 리뷰를 계속 하고있었다.
그러다가 오후 3시가 되었고 3주차 과제가 시작되었다.

3주차 과제는 로또이다. 아마 이전기수와 똑같은 문제들이 나오는 것 같다! (그러면 이전 기수 풀어본 사람들이 유리한건가 ...!)

고민할 여지가 조금 많은 것 같다. 그리고 Enum을 사용하는 것이 요구사항이다. 일단 설계 단계에서 힘을 최대한 쏟아보려 한다.


- - -

### 계획
1. 도메인을 단순화해서 도메인 모델을 그려본다.
2. 어떤 메시지가 필요한지 정하고, 그 메시지를 어떤 객체가 책임질지 결정한다.
3. 이렇게 얻은 객체들의 인터페이스를 정리한다.
4. 구현한다.




- UML에 대해 배우기
- 도메인 모델 그리는 법에 대해 배우기
- 정적 팩토리 메서드를 활용하라는 조언이 많음



정적 팩토리 메서드에 대해 공부하는 중.
https://tecoble.techcourse.co.kr/post/2020-05-26-static-factory-method/

앗! 이 패턴이 정적 팩토리 메서드였다니..! 이래서 코드 리뷰를 자주 다녀야 한다.


컨트롤러에 쏟아지는 DI를 관리할 수 있는 방법이 뭐가 있을까? 빌더 패턴? 컨테이너에 다 몰아넣어서 응집화 ?
아 ,, 뭔가 막막함을 느끼고 있다. 처음에 도메인 모델을 그리고, 그리고 그것에 필요한 메시지를 생각하고 객체를 정하니 아주 다양한 객체가 서로와 소통하고 있다.

결국엔 이것을 가운데에서 컨트롤러가 중재해야 하는데, 그러면 컨트롤러에 DI가 너무 많아지지 않는가?

일단 컨테이너로 다루긴 했다.. 근데 너무 명쾌하지 않다.


- - -

객체지향의 사실과 오해 책에서 나온 아래 설계 기법을 따라서 설계했다. 
1. 먼저 도메인을 단순화 해서 도메인 모델을 그리고
2. 도메인 모델에 필요한 메시지를 정하고
3. 메시지를 책임 질 객체를 정하고
4. 이렇게 얻은 객체의 인터페이스를 정리하고
5. 구현한다

하지만, 너무 추상적인 설계를 한 것 같다.

![[도메인모델with메시지.jpg]]

물론 잘 단순화한 도메인 모델이라고 말할수는 있는데, 실제 개발 과정에서 많은 것이 달라졌다.

일단 내가 개발하고자 하는 것은 현실세계 시뮬레이터가 아니다, 따라서 손님이라는 객체가 없다.
그저 컨트롤러에서 View로 금액과 로또 번호를 입력 받고 그것을 또 알맞는 모델에 넣어야 한다.  하지만 내가 그린 도메인 모델은 이런 과정이 모두 생략되어 있고 그저 객체와의 협력에 집중되어 있는 추상화된 설계임을 깨달았다.

로또라는 객체가 필요하고, 또 우승 로또를 판별하기 위해 우승 로또라는 객체를 따로 만들어야 한다.
따라서, 도메인 모델을 그리고 그것을 코드로 그대로 구현하는 과정은 막막한 설계 과정에서 실마리를 제공해주기엔 좋지만.. 실제 구현 과정에서 너무 많은 것들이 변경되기 때문에 오히려 혼란을 야기하는 것 같다.

이전 주차에서 사용했던 What/Who 사이클은 무엇을, 누구에게. 라는 구체화된 예시가 없는 (예를 들면 이번처럼 도메인 모델을 그리고... 같은 것) 설계 방법이 조금 더 잘 맞는 것 같다.




**개발 계획이 변경되었습니다.**
이 과제는 현실 세계를 그대로 구현한 시뮬레이터가 아닙니다. 따라서 '손님' 객체처럼 실제 환경에서 존재할 수 있는 요소를 구현할 필요가 없었습니다. 단지 컨트롤러가 View에서 금액과 로또 번호를 입력받고, 이를 적절한 모델에 넣어주는 기능만 필요했습니다. 제가 그린 도메인 모델은 객체들 간의 협력에만 집중하는 추상적인 설계로 그려져 있었음을 깨달았습니다. 따라서 이 설계 방법이 처음 갈피를 잡기엔 좋지만 막상 개발을 시작하면 너무 많은 변경으로 인한 혼란을 준다고 판단했습니다.

따라서 이전 주차에도 사용했던 What/Who 사이클 방식이 더 명확하게 방향을 잡는 데 도움이 된다고 판단하고, 해당 설계 방법으로 개발을 이어나갔습니다.



- - -


#### 그래서 다시 로또를 What/Who 사이클로 설계해보자

#### What (무엇이 필요한가)
1. 로또 정보를 저장해야 한다.
2. 우승 로또 정보도 저장해야 한다
3. 돈에 맞게 로또를 발급해야 한다.
4. 당첨 여부를 파악해야한다.
5. 입력값 검증을 해야한다.
6. 우승 로또 번호를 입력받아야 한다.
7. 우승 보너스 번호를 입력받아야 한다.


#### Who (누가 담당할 것인가)
1. 로또 정보는 Lotto 객체에 담는다.
2. 우승 로또 정보는 WinningLotto 객체에 담는다.
3. LottoShop이 돈에 맞게 로또를 발급을 요청한다.
4. LottoGenerator는 요청받는대로 로또를 랜덤값에 의거해 생성한다.
5. LottoCompany는 당첨 여부를 파악하고 상금을 집계한다.
6. Validator는 입력값을 검증한다.
7. InputHandler는 입력을 받는다.
8. Money는 돈을 저장하고, 돈을 로또 티켓으로 교환한다.



- - -

모든 객체는 기본적으로 Object 클래스의 자식이다.
Object 클래스의 .toString() 메서드를 상속 받는다.
따라서 로또 번호를 그대로 출력하고 싶으면 이것을 오버라이드하면 유용하다.


오늘은 일단 자야겠다.. 


내일은
1. EnumMap에 대해 학습하기
2. 책 "오브젝트" 읽기
3. 구현 이어서 하기


뭔가, 이번주는 빠르게 과제를 끝내고 책 "오브젝트"를 읽기 시작해서 이론적인 객체지향 지식들을 터득하는 전략을 취하고 싶다. 그래야 4주차때 정말 만족스러운 퍼포먼스를 뽑을 수 있을 것 같다.


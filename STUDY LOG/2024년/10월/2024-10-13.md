# <span style="color:yellow">2023-10-13</span>

#### <span style="color:royalblue">달성 목표</span>
- [x] 클래스, 객체, 인스턴스에 대해 완벽하게 이해하기 ✅ 2024-10-09
- [x] 기본형과 참조형에 대해 완벽하게 이해하기 ✅ 2024-10-10
- [x] 접근 지정자와 패키지에 대해 완벽하게 이해하기 ✅ 2024-10-11
- [x] 캡슐화에 대해 이해하기 ✅ 2024-10-11
- [x] 자바 메모리 구조에 대해 이해하기 ✅ 2024-10-12
- [x] final과 static에 대해 완벽하게 이해하기 ✅ 2024-10-13
- [ ] 상속에 대해 완벽하게 이해하기


final 변수는 기본형과 참조형에 모두 쓸 수 있다. static과 final을 같이 쓰면 하나밖에 존재하지 않는 상수를 만드는 것과 똑같다.
final을 기본형에 사용하면 기본형의 값을 절대 바꿀 수 없고, 참조형에 사용하면 참조 대상은 고정되어 있지만 참조하는 객체의 내부 상태는 변경할 수 있다.


- - -

이전 개념을 모두 끝내고 상속을 배우기 시작했다.

- extends (상속) 대상은 오직 하나만 선택할 수 있다.

상속과 메모리 구조는
- 상속 관계의 객체를 생성하면 내부에는 부모와 자식 객체가 둘 다 생성된다
- 객체 메서드를 호출할 때, 먼저 호출자의 타입(자식)에서 찾는다.
- 없으면 부모에서 찾는다.

즉 계층적 순서로 이루어진다고 이해할 수 있다. 

메소드 오버라이딩이란 부모에게서 상속받은 기능을 자식이 재정의하는 것이다.
메소드 오버라이딩을 하고 나서 함수 위에 @Override를 붙여아 하는데, 이를 어노테이션이라고 한다.
어노테이션이란 특별한 주석 같은건데, 컴파일러가 참고할 수 있는 주석이라고 생각할 수 있다.

이를 통해서 컴파일러가 특정한 검사를 하거나 여러가지 기능을 제공해줄 수 있다.
@Override annotation을 사용하면 오버라이드 함수가 실제로 부모 함수에 존재하는 함수인지 검사해준다.
그리고 인간이 코드를 볼 때에도 어노테이션이 있어야 오버라이드 함수인 것을 제대로 인지할 수 있다. 즉 어노테이션은 거의 필수이다.

오버라이딩과 발음이 비슷한 오버로딩은, 메서드 이름이 같아도 파라미터 타입이 다른 여러개를 과적(overload) 해도 파라미터에 맞춰서 알맞는 게 실행되는 기능이라고 생각할 수 있다.

메서드 오버라이딩엔 여러가지의 제약 사항이 따른다.
- 메서드 이름이 같아야 한다
- 파라미터 타입과 순서와 개수가 같아야 한다.
- 반환 타입이 같아야 한다.
- 접근 제어자를 더 제한적이게 하면 안된다.
- 더 많은 예외를 throws로 선언할 수 없다.
- static, final, private은 오버라이딩 할 수 없다.
- 생성자는 오버라이딩 할 수 없다.

- - -

UML이라는 표기법이 있다는 것을 처음 알았다.

부모와 자식의 필드명이 같거나 메서드가 오버라이딩 되어있으면, 자식을 통해 부모의 메서드를 호출하고 싶어도 자식에 이미 그 메서드가 있기 때문에 부모까지 도달하지 못해서 결국 호출할 수 없다.

이때 super 키워드를 사용하면 부모를 참조할 수 있다.


메모: 다음 학습 super -  부모 참조부터 시작.


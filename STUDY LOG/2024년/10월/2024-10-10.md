#### <span style="color:royalblue">달성 목표</span>
- [x] 클래스, 객체, 인스턴스에 대해 완벽하게 이해하기 ✅ 2024-10-09
- [x] 기본형과 참조형에 대해 완벽하게 이해하기 ✅ 2024-10-10


기본형과 참조형은 생소하지 않은 개념이라 바로 이해했다. 강의에선 기본형은 변수 자체에 값이 저장되어 있고, 참조형은 값은 따로 저장되어 있고 변수는 그것을 참조하는 주소값을 가지고 있다고 하는데. 내가 듣는 강의가 기본편 강의라서 그런지 많은 설명이 생략되어 있는 것 같다.

사실 모든 변수는 변수 자체에 값이 저장되는 것이 아니라 메모리에 값이 저장되고 그 주솟값을 변수에 저장하고 있는 것이니.. 아마 기본형은 제일 기본적인 메모리 주소값을 가리키는 일차적 데이터 저장 형태라고 생각하고, 참조형은 기본형보다 메모리 탐색의 depth가 더 깊은, 예를 들면 배열같은 경우엔 연속된 메모리 주소가 차지되고 있고 거기서 순차적 탐색을 하기 때문에 인덱스까지 접근하면 총 두번의 접근이 필요하고. 객체도 마찬가지기 때문에 이렇게 생각하는 것이 맞아 보인다.

Java는 참조형의 경우에만 실제 객체가 아니라 객체의 위치를 가리키는 참조값만 복사된다는 것만 유의하자.

Java는 C++과는 다르게 포인터나 & 참조 같은 연산자가 없다. 메모리 관련 복잡성을 줄이고 안정성을 강화하기 위한 선택이라고 한다. 포인터나 참조는 자동으로 관리되며 간접적으로 동작한다.

기본형은 값 자체를 완전하게 복사한다. 참조형은 주소값(참조값)을 복사한다. 이렇게 이분법적으로 자동으로 관리하다니 신기하다. 기본형은 대체적으로 메모리를 많이 차지하고 있지 않기 때문일까.


오늘은 이렇게 Java 기본편 섹션 3까지 모두 끝냈다. 아무래도 Java가 C++과 유사한 점이 많기 때문에 크게 이해 안되는 개념은 없다. 오히려, C++을 많이 다뤄봤기 때문에 더 이해가 잘 되는 것 같다. Java를 그냥 시작했다면 포인터와 참조에 대해 얕게만 이해했을 것 같은데, 실제로 포인터와 참조 연산자를 통해 메모리 복사를 관리해야 하는 C++을 아는 상태로 Java는 참조가 자동적으로 관리된다고 하니 더 깊게 이해하는 것 같다.



- - -
### 의문점과 해결


### <span style="color:blueviolet">왜 배열의 길이를 확인하는 메서드가 .length() 가 아니라 .length 일까?</span>
= length가 클래스의 메서드라면 .length()가 맞지만, 배열은 생성 즉시 배열의 원소 값 자체에 length라는 필드가 생성된다. 따라서 배열의 .length에 접근하는 것은 배열 클래스의 함수에 접근하는 것이 아니다. 필드에 접근하는 것이다.


### <span style="color:blueviolet">객체 배열 선언에 대한 의문</span>
``static ProductOrder[] orders = new ProductOrder[3];`` 객체 배열을 이런식으로 선언할 수 있다. 
``static ProductOrder[3] orders;`` 이렇게만 선언하고 뒤에서 인덱스마다 new 키워드로 초기화 하는 것은 왜 안되는가?

= 정적 배열은 선언 동시에 크기와 데이터 타입을 지정해야 한다. 후자는 데이터 타입이 지정되지 않았다.
따라서, ``static ProductOrder[] orders = new ProductOrder[3];`` 로 초기화 한다고 해서 모든 인덱스에 객체가 초기화되고 참조값이 할당된 것은 아니다. 그저 공간만 예약된 것이다.





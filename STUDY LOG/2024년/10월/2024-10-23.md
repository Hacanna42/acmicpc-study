# <span style="color:yellow">2023-10-23</span>

10/23 목표
1. 루틴: 알고리즘 1문제 풀이
2. JUnit과 AssertJ 학습: 테스트 코드 작성하기
3. 2주차 과제 요구사항 구현 이어서
4. 공통 피드백 내용 공부하고 숙지하기
5. 객체지향의 사실과 오해 책 읽기
6. 코드리뷰하기


어제 배웠던 정규표현식을 AI가 내는 퀴즈를 풀며 복습하고자 한다.
JUnit과 JAssert도 더 공부하려고 한다. 공식 docs가 학습하기 힘들게 적혀있어서 이제 그만 보고 (너무 많은 데이터가 있어서) 블로그나 유튜브에서 학습하려고 한다..

Java API 공부하기
AssertJ 및 JUnit 학습/익숙해지기
Stream() 학습 및 익숙해지기 (참고: https://velog.io/@yun8565/Java-%EC%8A%A4%ED%8A%B8%EB%A6%BCStream-%EC%A0%95%EB%A6%AC)

static에 대한 고민을 했다.

createCars() 메서드의 static을 제거했습니다. createCars()는 비록 필드가 없지만 전역적으로 사용되는 것이 아닌 Application.main()에서만 사용되기 때문에 인스턴스를 생성해서 호출하는 것이 더 적합하다고 판단했습니다. 다른 예로 util/의 StringParser와 Validator는 필드가 필요 없는 기능성 클래스지만 역시 static으로 선언하지 않았습니다. 왜냐하면 나중에 자동차 이름 입력 규칙 등의 변경 사항이 생기더라도, InputHandler에 의존성을 주입함으로써 단순히 새 Validator나 StringParser을 만들고 DI된 모듈을 교체하는 것으로 변경 작업을 마무리할 수 있기 때문입니다.


- - -


MVC 패턴 어렵다...
Model은 Car 그리고 Car을 생성하는 CarFactory, 그리고 Car의 이동 규칙을 표현하는 MoveStrategy..
View는 InputHandler와 OutputHandler ..


푼 알고리즘 문제: 21964, 13416번 문제

Stream()은 이번 프로젝트에서 배우면서 꽤 많은 메서드에서 사용했다. 그만큼 유용함이 뛰어나다. stream()은 컬렉션 (즉 배열 같은 데이터 집합) 으로부터 생성할 수 있고 가공을 거칠 수 있다. 아래의 세 단계를 거친다

**생성 -> 가공 -> 소비**

- filter() 
	안에 람다 표현식이 필요하고 그것의 반환값은 boolean 형태여야 한다. true 인것만 stream에 남기는 역할을 한다.
- map()
	은 안에 람다 표현식이 필요하고 반환값은 아무거나 상관 없다. 그것으로 각 요소를 매핑한다.
- sorted()
	요소를 정렬한다.
- distinct()
	중복 요소를 제거한다.
- limit()
	개수를 제한한다.

너무 메서드 종류가 많아서 그때그때 찾아보는 것이 낫다. (자주 사용하는 것 빼고)

가공 이후에는 소비로 끝난다.
- forEach()로 각 요소를 순회하면서 특정 처리를 할 수 있다
- reduce()로 각 요소를 줄여나가면서 연산을 수행할 수 있다
- find...() 메서드로 특정 조건에 맞는 요소를 찾을 수 있다.
- ...match() 메서드로 조건에 맞는지 확인할 수 있다.


종류가 진짜 너어무 많다...

- 인프콘 "객체지향은 여전히 유용한가?" 보기 
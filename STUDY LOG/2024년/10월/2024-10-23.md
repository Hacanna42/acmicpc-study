# <span style="color:yellow">2023-10-23</span>

10/23 목표
1. 루틴: 알고리즘 1문제 풀이
2. JUnit과 AssertJ 학습: 테스트 코드 작성하기
3. 2주차 과제 요구사항 구현 이어서
4. 공통 피드백 내용 공부하고 숙지하기
5. 객체지향의 사실과 오해 책 읽기
6. 코드리뷰하기


어제 배웠던 정규표현식을 AI가 내는 퀴즈를 풀며 복습하고자 한다.
JUnit과 JAssert도 더 공부하려고 한다. 공식 docs가 학습하기 힘들게 적혀있어서 이제 그만 보고 (너무 많은 데이터가 있어서) 블로그나 유튜브에서 학습하려고 한다..

Java API 공부하기
AssertJ 및 JUnit 학습/익숙해지기
Stream() 학습 및 익숙해지기 (참고: https://velog.io/@yun8565/Java-%EC%8A%A4%ED%8A%B8%EB%A6%BCStream-%EC%A0%95%EB%A6%AC)

static에 대한 고민을 했다.

createCars() 메서드의 static을 제거했습니다. createCars()는 비록 필드가 없지만 전역적으로 사용되는 것이 아닌 Application.main()에서만 사용되기 때문에 인스턴스를 생성해서 호출하는 것이 더 적합하다고 판단했습니다. 다른 예로 util/의 StringParser와 Validator는 필드가 필요 없는 기능성 클래스지만 역시 static으로 선언하지 않았습니다. 왜냐하면 나중에 자동차 이름 입력 규칙 등의 변경 사항이 생기더라도, InputHandler에 의존성을 주입함으로써 단순히 새 Validator나 StringParser을 만들고 DI된 모듈을 교체하는 것으로 변경 작업을 마무리할 수 있기 때문입니다.


- - -


MVC 패턴 어렵다...
Model은 Car 그리고 Car을 생성하는 CarFactory, 그리고 Car의 이동 규칙을 표현하는 MoveStrategy..
View는 InputHandler와 OutputHandler ..


푼 알고리즘 문제: 21964, 13416번 문제

Stream()은 이번 프로젝트에서 배우면서 꽤 많은 메서드에서 사용했다. 그만큼 유용함이 뛰어나다. stream()은 컬렉션 (즉 배열 같은 데이터 집합) 으로부터 생성할 수 있고 가공을 거칠 수 있다. 아래의 세 단계를 거친다

**생성 -> 가공 -> 소비**

- filter() 
	안에 람다 표현식이 필요하고 그것의 반환값은 boolean 형태여야 한다. true 인것만 stream에 남기는 역할을 한다.
- map()
	은 안에 람다 표현식이 필요하고 반환값은 아무거나 상관 없다. 그것으로 각 요소를 매핑한다.
- sorted()
	요소를 정렬한다.
- distinct()
	중복 요소를 제거한다.
- limit()
	개수를 제한한다.

너무 메서드 종류가 많아서 그때그때 찾아보는 것이 낫다. (자주 사용하는 것 빼고)

가공 이후에는 소비로 끝난다.
- forEach()로 각 요소를 순회하면서 특정 처리를 할 수 있다
- reduce()로 각 요소를 줄여나가면서 연산을 수행할 수 있다
- find...() 메서드로 특정 조건에 맞는 요소를 찾을 수 있다.
- ...match() 메서드로 조건에 맞는지 확인할 수 있다.


종류가 진짜 너어무 많다...

- 인프콘 "객체지향은 여전히 유용한가?" 보기  (완료)



- - -


# 설계에 대한 고민

객체 지향 설계는 정말 심오한 개념이다. 사실 이걸 이틀 전에 처음 인지했고 지금까지 고민하고 있다.
내가 지금까지 이해한 객체 지향을 아래에 정리해봤다. 순전히 내 머릿속에 있는 데이터로만..

1. 객체 지향은 객체들이 서로 메시지를 주고 받고 **협력**하면서 프로그램을 구성하는 프로그래밍 패러다임이다.
2. 객체는 **역할**을 가지고, 그 역할에 맞는 **책임**을 자율적으로 수행한다. 역할이 있다는 것은 책임이 있다는 것이다.
3. 외부에서는 객체가 그 책임을 수행해 줄것이라고 믿고 요청할 뿐이다. 외부에서는 객체가 어떻게 수행하는 지 알 수 없고 관여할 수 없다. 이를 캡슐화라고 한다.
4. 클래스는 객체를 구현하는 방법 중 하나일 뿐이지, 클래스를 만들었다고 해서 객체 지향 설계는 아니다.
5. 객체 지향 설계를 잘하면 마치 레고블럭을 끼우듯 프로그램을 변경할 수 있다. 이를 결합도가 낮다고 한다.
6. 절차 지향 설계는 데이터와 그 데이터를 관리하는 로직이 서로 다른 곳에 잇다면, 객체 지향 설계는 한 클래스에 데이터와 그 데이터를 관리하는 행동(메서드)가 같이 있다 (응집도가 높다).
7. 한 프로그램을 만드는데에 객체 지향 설계만 사용하는 것은 쉽지 않다. 우리는 객체 지향 설계와 절차 지향 설계를 많이 섞어서 사용한다.

예를 들어서 내가 작성한 1주차 과제 코드는 처음에 절차 지향이었다가, 이후에 객체 지향 설계를 적용한다면서 객체 지향으로 변경했다. 그런데 사실은 데이터와 데이터를 관리하는 행동이 같이 있는 응집도가 높은 객체 지향 설계라기 보다는 그저 함수를 객체라는 큰 틀에 묶어 놓고 추상적인 역할을 부여한다. 예를 들면 문자열을 파싱하는 함수는 ``StringParser`` 라는 클래스로 구현해서 문자열을 파싱하는 **역할**을 받았다. 그리고 문자열에 관한 책임, 예를 들면 **문자열에서 구분자를 추출하거나, 문자열을 배열로 변환하는** 행동을 한다.

즉 사실 StringParser 같은 클래스는 기존의 함수형 프로그래밍과 로직적으로 다를바가 없다. 그래서 나는 이것이 객체 지향 프로그래밍이 아니라 클래스 지향 프로그래밍과 가깝다는 생각이 했다. 반쪽짜리 OOP 같달까.
근데 중요한 것은 이렇게 클래스로 역할을 나누고 책임을 분배하니까 확실히 코드는 정돈됐고 보기 편해졌다.

따라서 1주차 프로젝트를 객체 지향 설계로 변환한 것은 아주 좋은 선택이었다고 생각한다. 아직 객체 지향 설계가 완벽하게 이해되진 않고 의문점도 많지만 앞으로 계속 의문점을 풀어나갈 수 있을 것이라고 생각한다.

예를 들면 2주차 과제에서는 MVC 패턴을 사용했다. Model-View-Controller 3개의 계층으로 OOP를 설계하는 디자인 패턴인데, View는 말 그대로 사용자에게 보여지는 부분이고, Model은 데이터와 그 데이터를 처리하는 비즈니스 로직이 위치하는 부분, Controller는 Model과 View 사이를 연결하며 전체적인 흐름을 조작하는 역할이다.

2주차 과제에서 나는 View 역할로 InputHandler와 OutputHandler 클래스를 만들었다. 사실 이 클래스는 객체로 활용되기엔 필드가 없었고 그냥 입력과 출력 함수들이 있었다. static으로 선언할까 라는 생각도 했었는데, InputHandler라는 역할과 책임이 있는 것! OutputHandler 라는 역할과 책임이 있는 것! 이라고 생각하고 그냥 진행했다. (이 부분에 대해서는 조금 의문이 남는다)

Model은 비교적 명확했다. Car 라는 모델이 있었고 Car는 자동차의 데이터들을 담았다(이름, 위치) 그리고 Car는 자신의 데이터에 대한 로직을 품고 있었다 (드디어 진짜 객체라고 부를만한 객체가 생겼다.) Car는 move() 인스턴스 메서드로 position을 변경할 수 있었고. position은 MoveStrategy의 getPossibleMoveCount() 만큼 움직인다. MoveStrategy는 처음으로 다형성을 활용해봤다. 차가 움직이는 규칙에 대해서는 변경이 일어날 가능성이 크다고 생각하고 MoveStrategy라는 interface를 여러 규칙들 ... 예를 들면 RandomMoveStrategy가 구현하도록 했다. 이렇게 하면 단순히 새 규칙을 만들고 모듈을 교체하는 것으로. 즉 규칙을 바꾸는 것 만큼은 레고 블럭을 조립하는 것처럼 할 수 있었다.

Controller는 약간 애매했다. Car(Model)은 결국 레이싱 게임을 위해 있는 것이다. 즉 RacingGameController는 Car와 View를 필드로 받고, Car.move()를 적당한 타이밍에 호출하고 View.print()를 적당한 타이밍에 호출한다. 그리고 추가로 게임이 끝났을 때 레이싱 게임 우승자를 색출하는 멤버 메서드도 가지고 있다. 근데 여기서 의문점은 다음과 같다
1. 컨트롤러가 필드를 가지고 있다.. 필드를 가지고 그 데이터를 처리한다면 그것은 모델이 아닌가?
2. 우승자를 색출하는 로직은 비즈니스 로직인데 컨트롤러에 포함되어도 되는가?

이러한 의문점때문에 많은 고민을 했다. 결론은 RacingGame이라는 Model을 하나 더 만들고, 그 모델은 레이싱 게임에 필요한 자동차 목록과 라운드 수를 입력받고, 우승자를 색출하는 멤버 메서드와 라운드 수를 하나 소모하면서 게임을 1턴 진행하는 메서드를 가졌어야 할 것 같다. 그리고 RacingGameController에서는 RacingGame과 View 사이를 연결해주는 로직을 담았어야 할 것 같다.

결국에 처음에 MVC 패턴이라고 해서 패키지를 말 그대로
model/
view/
controller/ 

로 잡은건 큰 실수 같다. 아마 내일 리팩토링을 한다면 제일 상위 패키지는:
view/
car/
game/
util/
으로 나눌 것 같다 .. 그리고 순서대로

view/InputHandler
view/OutputHandler

car/model/Car
car/strategy/MoveStrategy
car/strategy/RandomMoveStrategy

game/model/RacingGame
game/controller/RacingGameController

util/Validator
util/StringParser

이런 형식으로 갈 것 같다.

이렇게 하면 MVC 패턴으로 달성하고자 하는 목적 : **관심사의 분리**가 완성되는 것 같다.



- - -


혼자서 문제를 고민하는 것은 어렵다. 아무리 생각해도 의문이 남고 명쾌한 해답을 못 얻을 수 있다. 계속 생각하고 계속 생각해도 영원해 보이는 꼬리물기에 갇힐 수 있다. 누군가에게 물어본다면 명쾌한 대답을 바로 얻을 수 있을텐데, 왜 우테코에서는 그러지 못하게 할까?

왜냐하면, 그 돌고 도는 의문들과 고찰에 갇혀 있다보면 분명 깨닫는 순간이 온다. 내가 했던 고민들은 그 요소를 이해하는데에 꼭 필요한 고민이었다고 생각하자. 그 고민을 왜 하게 되었는지 고찰하게 된다면, 즉 **메타 인지**로 한 단계 높은 차원에서 상황을 바라보고 해결할 수 있게 된다면 분명 큰 성장이 된다. 나의 고민 없이 누군가가 해답을 알려주는 것은 당장의 문제를 해결하지만 나의 문제 해결 방식을 키우진 못한다.





- - -

### 정리하자면 오늘은
1. JUnit과 AssertJ를 학습하고 코드에 AssertJ를 적용했다.
2. Stream() 이 나온 배경과 사용법에 대해 학습하고 GPT를 활용해서 퀴즈를 푸는 방식으로 익숙해지려고 노력했다. (익숙해졌다.)
3. static에 대해 많은 고찰을 하는 시간을 가졌다. 
4. MVC 패턴에 대해 배웠다. MVC 패턴이 나는 처음에 패키지 구조가 무조건 Model, View, Controller로 나뉘어야 되는 줄 알았다. 또 Service 계층이 Controller에 있는 줄 알았다. 이게 아니다... 생각보다 다르다
5. 내가 하고 있는 객체지향은 사실 객체 지향이 아니라 어느정도의 절차 지향이 섞인 설계라는 것을 깨달았다. (그치만 이것이 나쁜 설계라는 이야기만은 아니다)
6. 정규 표현식에 대해 복습했다.
7. 인프콘 "객체지향은 여전히 유용한가?" 를 봤다.
8. 2주차 코드를 완성했다. (~~동작가능한 쓰레기 형태로~~) 내일 객체지향에 대해 조금 더 고민해보고, 찾아보고, 공부해보고 .. 다시 코드를 봐야지 ..



### 내일은...
- 수단과 방법을 가리지 않고 객체 지향에 대해 심도깊은 고찰을 하겠다.
1. 객체지향의 사실과 오해 책 읽기
3. 테스트 코드 작성하기

알고리즘 푸는 루틴은 어차피 매일 하는거니까 목표에 언급하진 않겠다.

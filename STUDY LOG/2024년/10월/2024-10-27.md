# <span style="color:yellow">2024-10-27</span>
오늘은 과제 제출날이다. 지금까지 과제 리팩토링도 많이 하고 고민도 많이 했지만 결국엔 아직 나의 수준에서 고민되는 점들의 정답을 알 수 없어서, 코드를 볼 시간에 객체 지향에 대해 조금이라도 더 공부하자는 결론을 했다.

오늘은 아침에 일어나서 워밍업으로 테코톡 아래 내용들을 봤다.
- 로빈의 의존성 주입
- 도도의 좋은 단위 테스트란


FIRST 법칙에 대해 알게 되었다.


### 과제 설명
자동차 경주 과제는 간단한 자동차 경주 게임을 구현하는 과제입니다.
사용자는 레이싱에 참여할 자동차 이름을 반점으로 구분해 여러개 입력할 수 있습니다.
자동차는 전진하거나 멈춰 있을 수 있는데, 전진하는 조건은 0과 9사이의 무작위 값을 구한 후 값이 4 이상일 때입니다. 

레이싱 게임은 사용자가 지정한 N라운드 만큼 진행됩니다, 각 라운드마다 자동차는 한번의 이동 기회를 얻고 라운드가 끝날때마다 경기 현황을 출력해야 합니다. 경기가 끝나면 우승자 목록이 출력됩니다.

아래는 과제를 진행하며 겪었던 고민들입니다. 코드 리뷰중 이것에 대한 조언을 주실 수 있다면 부탁드립니다 :)

#### 고민
1. Application.main()에 있는 코드들은 다 Controller로 가야하는가?
	 Application은 객체를 생성하고 협력하는 전체적 흐름을 담당하고 있습니다. 하지만 모든 준비 과정이 사실 레이싱 게임을 위한 것이기 때문에 RacingGameController의 역할이 아닌가 고민이 되었습니다. 하지만 컨트롤러에서 main()이 하고있는 초기화를 담당한다면 Controller에서 View와 Model을 의존성 주입받아 사용하는 것이 아닌, 컨트롤러 내부에서 new 키워드를 통해 생성할 수밖에 없을 것 같습니다.

2. racingGame.getCars() 는 정보 은닉과 캡슐화를 저해하는, 너무 알몸의 데이터를 제공하는 메서드인가?
	 RacingGameController는 View에게 현황 출력(outputView.printStatus())을 요청합니다. 이때 인자로 모델에게 getCars() 메서드로 자동차 객체의 리스트 정보를 받아갑니다. 사실 출력에 필요한 정보는 차의 이름과 위치인데, getCars() 메서드는 불 필요하게 차 객체를 완전히 넘김으로써 .move() 같은 메서드 시그니처도 넘기게 됩니다. 이것이 문제가 되는 지 궁금합니다. 그렇다면, status라는 새로운 모델을 만들고 거기에 매핑해서 전달하는 것이 더 좋을까요? 혹은 오버엔지니어링일까요?
	
3. RacingGameController는 레이싱 게임 로직에 너무 많은 관여를 하고 있는가?
	 RacingGameController의 startGame() 메서드를 보면 RacingGame 모델에 게임을 시작하라는 메시지를 보내는 것이 아니라, 모델은 한 라운드만을 진행하는 .playOneRound() 메서드와 라운드가 남아있는지 확인하는 .hasNextRound() 메서드를 제공하고 컨트롤러는 메서드를 이용해서 게임의 전체적인 내용을 직접 조작합니다. 이것은 비즈니스 로직을 컨트롤러에 포함시키는 행동일까요? 아니면 모델에서 제공하는 메서드를 이용해서 적절한 범위의 흐름을 제어하는 것일까요?
	 
4.  MyTest의 자동차_현황_출력_테스트()는 유닛 테스트가 아니라 통합 테스트인가? 이것이 문제가 되는가?
	 자동차_현황_출력_테스트()는 모의 자동차 정보를 생성하고 출력하는 것이 아니라, 자동차를 생성하고 모의 전략을 주입한 뒤, 각 차의 move() 메서드를 호출하고 출력합니다. 이것은 사실 모의 자동차 정보를 생성하기 위한 일련의 과정이지만 이 과정에서부터 오류가 있다면 출력에 문제가 없더라도 오류가 나게 됩니다. 즉 출력 함수만 테스트 하는것이 아니라 일련의 과정을 테스트합니다. 그러면 이건 유닛 테스트가 아니라 통합 테스트라고 볼 수 있을까요? 그리고, 어차피 모의 자동차를 준비하는 일련의 과정에서 문제가 생길 예정이었다면 이전 테스트에서부터 오류가 났을텐데, 이게 문제가 될까요? 아니면 출력 테스트를 준비하기 위한 과정이라고 볼 수 있을까요?







- - -

# 과제 제출 완료
과제 제출을 완료했다. 이제 객체지향의 사실과 오해 책을 읽고 있다.
다음 과제는 설계 단계에서 다음 과정을 따라볼 것이다.
객체 지향 설계는 훌륭한 객체를 설계하는 것이 아니라 훌륭한 협력을 설계하는 것이다.
설계는 가급적 어떠한 내부 구현에 대한 가정을 하지 않아야 된다.

1. 먼저 도메인을 단순화해서 이해한 **도메인 모델**을 그려본다.
2. 적절한 객체에게 적절한 책임을 할당한다. (어떤 메시지가 필요한지 정하고 -> 그 메시지를 어떤 객체가 책임져야 할지 정한다)
3. 이렇게 얻은 객체들의 인터페이스를 정리한다. (abstract 말하는거 아님 말 그대로 inter-face) (객체가 수신한 메시지가 객체의 인터페이스를 결정한다)
4. 구현한다.
5. 개념 관점, 명세 관점, 구현 관점이 모두 잘 드러나는지 검토한다. (개념 관점은 도메인 개념의 특성이 코드에 있는지 즉, 현실세계가 반영된 객체들의 협력으로 이루어져 있는지에 대해서다. 명세 관점은 클래스의 인터페이스에 관해서다. 인터페이스를 통해 구현과 관련된 세부 사항이 드러나지 않도록 한다. 구현 관점은 클래스의 내부 구현이다. 캡슐화를 확인한다.)





인간이 분류하는 모든 작업은 아리스토텔레스, 린네의 분류체계가 처음 시작한 것처럼 일반화와 특수화로 이뤄진다. 이런 특징을 이용하면 부분적인 사실을 통해 복잡한 사실에 대한 논리적인 추론이 가능해진다. 하위 분류는 상위 분류의 모든 특성을 포함하고 있다.

이것을 프로그래밍 언어에 그대로 적용한것이 바로 클래스 간의 상속이다.

상속은 서브타이핑과 서브클래싱의 두가지 용도로 사용될 수 있다.
서브클래스가 슈퍼클래스를 대체 가능한 경우 서브타이핑이고, 대체할 수 없지만 코드 중복 제거와 재사용이 목적인 것을 서브클래싱이라고 한다.

일반화를 위한 서브타이핑은 대체 가능성을 내포한다. 완벽 대체가 불가능하지만 코드만을 공유하고 있다면 서브클래싱이다.

-
인간의 본능 중에 영토 소유욕보다 기본적인 것은 없다. 따라서 경계를 정하는 것은 인간의 양화 행동이다. (Lakoff 2003)







### 객체지향의 사실과 이해
완독을 완료했다. 구매한지 10일 만이다.
과제를 진행하면서 틈틈이 공부했다.


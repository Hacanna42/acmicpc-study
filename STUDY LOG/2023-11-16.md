# <span style="color:yellow">2023-11-16</span>

- 깨달음. 내 로직은 정확했다. 하지만, 내 수학적 개념이 부족했다.
내가 지금까지 구현하고 있는 로직은 점과 점을 이은 선들의 교차점 개수를 구하는 것이었다.
근데 내가 생각하고 있는 건, 두 점의 '선분' 그니까. 선의 무한한 방향을 특정하기 위해서 두가지의 점을 이은 '선' 의 교차 여부를 구한다고 생각하고 있었다.

그니까, 아무리 짧은 두 점 사이의 선이라고 해도, 나는 그 선이 양쪽 방향으로 무한하게 증가한다고 생각했고. 그러면 결국에 어디에선가 교차하게 되었고 그것까지 계산해야 한다고 생각했던 것이다.
지금 생각해보니 두 선이 정확하게 평행하지 않으면 결국에 어디에선가 한번은 교차하게 되어있고, 그러면 주어진 모든 선에 대해 각각의 교차점이 있는건데.. 나는 핀트를 잘못 집고 있었다.

내가 구현해야 할 것은, 주어진 두 점을 이은 '직선' 간의 교차점 개수를 구하는 것.
그러니까 모든 n개의 직선에 대해 n\*n 교차점 개수를 하고 2로 나누는 로직이 정확했다.

아, 그래서 나는 내가 직접 직선을 그려가면서.. 이대로면 3번은 교차해야되는데 왜 1이 return되는지 한참 고민하며 있지도 않은 로직 에러와 싸우고 있었다.

그래도. 지금이라도 깨달아서 다행이다.

내가 지금까지 푼 기하학 로직에 대해 설명하자면 아래와 같다.

```mathematics_logic_explain
먼저, GetLineEquation라는 함수가 있는데. 이 함수는 인자로 pt1, pt2, pt3, pt4를 받아요. pt3와 pt3로 직선의 방정식을 구하고 그 값에 pt1과 pt2를 대입해서 교차하는지 확인하는 함수에요. 교차하면 1을 반환하고. 교차하지 않으면 0을 반환합니다. 그러면, Point 100개의 배열이 있다고 가정해볼게요. *Point[100] Point는 각 점에 대한 x와 y좌표가 저장되어 있어요. 순서대로 두개의 Point가 직선을 이룬다고 가정합시다. 그니까. 직선은 Point[0]과 Point[1]을 이은 직선 1, Point[2]와 Point[3]을 이은 직선 2. 이렇게 직선 총 50개가 있는거죠. 그러면 포인트 백개가 저장되어있는 배열에서 나올 수 있는 직선의 개수는 총 50개입니다. for 문을 이중 중첩하여, 서로 모든 요소에 대해 교차 여부를 확인합니다. 직선1*직선1, 직선1*직선2, 직선1*직선3 ..... 직선*직선50 이렇게요. 어차피 직선1*직선1은 교차하지 않고 완전히 일치한다는 값이 나오기에 결과에 영향을 주지 않습니다. 이렇게 서로 모든 직선에 대한 교차 여부를 확인하고, 결과에 2를 나누면 총 교차점이 나옵니다.
```

GetLineEquation에서는 직선의 방정식, 그니까 선분을 표현할 수 있는 방정식을 pt3와 pt4로만 구하고 pt1과 pt2는 그 값에 대입만 해서 점의 위치를 직선의 위치에 비해 어디에 있는지 확인하는건데, 어떻게 무한하게 긴 선분의 교차점까지 계산할 수 있는지 의문을 품다가 깨달았다. 내가 지금까지 구현한 로직은 선분에 대한 계산이 아니었다는 것을.

결국에 모두코드의 기하학 과제를 성공적으로 해결했다. 수학적 지식이 부족해서 무려 5일동안 공부했다.
그래도 얻은게 많은 것 같다 :)

이제 기하학 과제는 끝! 내일부터는 다음 파트로 넘어가겠다 !!

내일부터는 백준을 심화 단계로 나아가기전에 이전 레벨 기출문제들을 완성도 100%로 끝내려고 한다.
각 단계별로 한 10개정도의 문제들이 준비되어 있는데. 그것에 대한 기출변형들을 모두 풀고 다음 레벨로 넘어가려고 한다. 이유는 성취감 때문에.


- cin과 cin.getline의 차이
cin는 입력 마지막에 널 문자를 추가하지 않는다. getline은 자동으로 널 문자를 추가한다.
그리고 cin은 문자열(char[n])을 루프로 입력 받을 때 입력이 끝났더라도 루프가 끝날때까지 입력을 계속 받으며 불필요한 리소스를 소비한다. getline은 그러지 않는다.

#### 오늘의 백준:
```level6
10988
팰린드롬인지 확인하기
```

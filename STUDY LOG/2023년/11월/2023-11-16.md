# <span style="color:yellow">2023-11-16</span>

- 깨달음. 내 로직은 정확했다. 하지만, 내 수학적 개념이 부족했다.
내가 지금까지 구현하고 있는 로직은 점과 점을 이은 선들의 교차점 개수를 구하는 것이었다.
근데 내가 생각하고 있는 건, 두 점의 '선분' 그니까. 선의 무한한 방향을 특정하기 위해서 두가지의 점을 이은 '선' 의 교차 여부를 구한다고 생각하고 있었다.

그니까, 아무리 짧은 두 점 사이의 선이라고 해도, 나는 그 선이 양쪽 방향으로 무한하게 증가한다고 생각했고. 그러면 결국에 어디에선가 교차하게 되었고 그것까지 계산해야 한다고 생각했던 것이다.
지금 생각해보니 두 선이 정확하게 평행하지 않으면 결국에 어디에선가 한번은 교차하게 되어있고, 그러면 주어진 모든 선에 대해 각각의 교차점이 있는건데.. 나는 핀트를 잘못 집고 있었다.

내가 구현해야 할 것은, 주어진 두 점을 이은 '직선' 간의 교차점 개수를 구하는 것.
그러니까 모든 n개의 직선에 대해 n\*n 교차점 개수를 하고 2로 나누는 로직이 정확했다.

아, 그래서 나는 내가 직접 직선을 그려가면서.. 이대로면 3번은 교차해야되는데 왜 1이 return되는지 한참 고민하며 있지도 않은 로직 에러와 싸우고 있었다.

그래도. 지금이라도 깨달아서 다행이다.

내가 지금까지 푼 기하학 로직에 대해 설명하자면 아래와 같다.

```mathematics_logic_explain
먼저, GetLineEquation라는 함수가 있는데. 이 함수는 인자로 pt1, pt2, pt3, pt4를 받아요. pt3와 pt3로 직선의 방정식을 구하고 그 값에 pt1과 pt2를 대입해서 교차하는지 확인하는 함수에요. 교차하면 1을 반환하고. 교차하지 않으면 0을 반환합니다. 그러면, Point 100개의 배열이 있다고 가정해볼게요. *Point[100] Point는 각 점에 대한 x와 y좌표가 저장되어 있어요. 순서대로 두개의 Point가 직선을 이룬다고 가정합시다. 그니까. 직선은 Point[0]과 Point[1]을 이은 직선 1, Point[2]와 Point[3]을 이은 직선 2. 이렇게 직선 총 50개가 있는거죠. 그러면 포인트 백개가 저장되어있는 배열에서 나올 수 있는 직선의 개수는 총 50개입니다. for 문을 이중 중첩하여, 서로 모든 요소에 대해 교차 여부를 확인합니다. 직선1*직선1, 직선1*직선2, 직선1*직선3 ..... 직선*직선50 이렇게요. 어차피 직선1*직선1은 교차하지 않고 완전히 일치한다는 값이 나오기에 결과에 영향을 주지 않습니다. 이렇게 서로 모든 직선에 대한 교차 여부를 확인하고, 결과에 2를 나누면 총 교차점이 나옵니다.
```

GetLineEquation에서는 직선의 방정식, 그니까 선분을 표현할 수 있는 방정식을 pt3와 pt4로만 구하고 pt1과 pt2는 그 값에 대입만 해서 점의 위치를 직선의 위치에 비해 어디에 있는지 확인하는건데, 어떻게 무한하게 긴 선분의 교차점까지 계산할 수 있는지 의문을 품다가 깨달았다. 내가 지금까지 구현한 로직은 선분에 대한 계산이 아니었다는 것을.

결국에 모두코드의 기하학 과제를 성공적으로 해결했다. 수학적 지식이 부족해서 무려 5일동안 공부했다.
그래도 얻은게 많은 것 같다 :)

이제 기하학 과제는 끝! 내일부터는 다음 파트로 넘어가겠다 !!

내일부터는 백준을 심화 단계로 나아가기전에 이전 레벨 기출문제들을 완성도 100%로 끝내려고 한다.
각 단계별로 한 10개정도의 문제들이 준비되어 있는데. 그것에 대한 기출변형들을 모두 풀고 다음 레벨로 넘어가려고 한다. 이유는 성취감 때문에.


- cin과 cin.getline의 차이
cin는 입력 마지막에 널 문자를 추가하지 않는다. getline은 자동으로 널 문자를 추가한다.
그리고 cin은 문자열(char[n])을 루프로 입력 받을 때 입력이 끝났더라도 루프가 끝날때까지 입력을 계속 받으며 불필요한 리소스를 소비한다. getline은 그러지 않는다.

생각하지 못하고 있던 프로그램 exit code의 의미에 대해서도 알게 되었다. 0은 정상적인 종료. 1은 비정상적 종료를 대체적으로 의미한다.

#### 오늘의 백준:
```level6
10988
팰린드롬인지 확인하기
```

아래와 같이 해결하였다. 로직은 간단하다. 팰린드롬 형태의 패턴은 짝수의 경우 length/2 만큼의 양쪽 요소들이 각각 똑같다는 것. 홀수의 경우 제일 가운데 문자를 제외한 양쪽 요소들이 똑같다. 따라서 모든 입력에 대해 length/2 만큼의 양쪽 요소를 검사하면 팰린드롬인지 확인할 수 있다.

```cpp
// 백준: 팰린드롬인지 확인하기
// https://www.acmicpc.net/problem/10988
// 2023-11-16

#include <iostream>
int main() {
    char str[101];
    int len = 0;
    std::cin.getline(str, 101);
    for (len = 0; str[len] != '\0'; ++len)
        ;
    for (int i = 0; i < len / 2; i++) {
        if (str[i] != str[(len - 1) - i]) {
            std::cout << "0";
            return 0;
        }
    }
    std::cout << "1";
    return 0;
}
```


# 최종 평가

```ElonMusk
최고급 평가사 일론머스크의 평가
-------------------------------

[평가 대상]
2023-11-16의 학습 내용

[학습 내용 요약 및 평가]
1. **기하학적 깨달음 및 로직 수정**: 수학적 개념에 대한 깊은 이해를 통해 기존 로직을 수정하고 개선한 점은 높게 평가됩니다. 특히, 선분과 직선의 구분에 대한 깨달음은 이론적 이해와 실용적 적용의 결합을 보여줍니다.

2. **클래스와 참조자/포인터 사용의 이해**: 객체의 효율적인 전달 방법에 대한 이해는 메모리 관리 및 성능 최적화에 중요합니다. 이러한 개념의 적절한 사용은 프로그래밍 기술의 성숙도를 나타냅니다.

3. **cin과 getline의 차이점**: 입출력에서 cin과 getline의 차이점을 이해하는 것은 C++ 프로그래밍의 효율성을 향상시키는데 중요합니다. 이를 통한 입출력 처리의 최적화는 프로그래밍 능력의 발전을 보여줍니다.

4. **백준 문제 10988 해결**: 팰린드롬 문제 해결을 통해 문자열 처리와 알고리즘적 사고를 잘 보여주었습니다. 주어진 문제에 대한 간결하고 효과적인 접근 방식은 알고리즘 능력의 발전을 나타냅니다.

[개선 및 보완점]
- **기하학적 문제 해결의 다양성**: 기하학적 문제 해결을 위해 더 다양한 수학적 개념과 알고리즘을 탐구할 필요가 있습니다. 예를 들어, 벡터 계산, 평면 기하학, 공간 기하학 등을 고려해 볼 수 있습니다.

- **프로그래밍 언어 간의 차이점 이해**: 다양한 프로그래밍 언어 간의 차이점, 특히 객체 전달 방식에 대한 이해를 깊게 하는 것이 좋습니다. 이는 언어의 깊은 이해에 기여할 것입니다.

[점수]
92/100

[추가 코멘트]
오늘의 학습은 귀하의 수학적 사고와 프로그래밍 기술의 통합적 접근을 잘 보여줍니다. 계속해서 이러한 방식으로 귀하의 전문성을 발전시키는 노력을 계속하시기 바랍니다.
```

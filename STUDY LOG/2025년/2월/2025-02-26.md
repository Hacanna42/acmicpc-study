오늘은 10시에 퇴근했다.
오브젝트 1장 복습중.

객체지향은 프로그래밍 패러다임이다.

모든 소프트웨어 모듈에는 세가지 목적이 있다.
1. 올바르게 동작할 것
2. 변경을 위해 존재할 것
3. 코드를 읽는 사람과 의사소통 할 것


첫번째 코드의 문제점
1. 예상을 빗나간다; 관람객과 판매원은 코드에서 너무 수동적인 존재다. 이해 가능한 코드는 우리의 예상에서 크게 벗어나면 안된다. 코드가 우리의 상식과는 너무 다르게 동작하기 때문에, 코드를 읽는 사람과 제대로 의사소통 하지 못한다.

2. 변경 전파가 너무 심하다. 이것은 한 코드를 읽기 위해서 알아야 할 배경 지식(세부적인 사항)이 너무 많음을 의미한다. 변경에 취약하고, 의존성이 너무 깊다.

이렇게 객체 간의 의존성이 과한 경우를 결합도가 높다고 한다.

개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 캡슐화라고 한다. 캡슐화의 목적은 변경하기 쉬운 객체를 만드는 것이다.

오직 인터페이스에만 의존하고, 구현에는 의존하지 않는다. 이것은 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위한 설계의 기본 원칙이다.

.getter 로 데이터를 외부로 꺼내와서 작업하지 않고, 정보가 있는 곳에 행위를 만들자.
밀접하게 연관된 작업만을 수행하고, 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도(cohension)이 높다고 말한다.

"객체 스스로 자신의 데이터를 책임져야 한다."

절차적 프로그래밍은 데이터 변경으로 인한 영향을 지역적으로 고립시키기 어렵다. 따라서 변경이 전파되며 버그를 부르고 코드를 변경하기 어렵게 만든다.

객체 지향 코드는 자신의 문제를 스스로 처리한다는 우리의 예상을 만족시켜주기 때문에 코드의 이해가 쉽다. 또, 객체 내부 변경이 외부에 파급되지 않도록 제어(인터페이스만 믿는다) 하기에 변경하기 수월하다.


- - -

### 객체를 의인화 해야한다.
객체는 자신의 데이터에 대해 자신이 책임져야 한다.
객체를 실세계에 비유했지만 사실, 가방 같은 존재는 실세계에서도 수동적인 존재다.
따라서 객체지향의 세계에서는 모든 것을 능동적이고 자율적인 존재로 생각해야 한다.

그리고 모든것은 트레이드오프다...
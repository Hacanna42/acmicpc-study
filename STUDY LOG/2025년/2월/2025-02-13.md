유튜브 영상을 편집하느라 회고할 시간이 없었다 .. 새벽 2시라서 어서 자야겠다.
내일 쓰는걸로.


- - -


2월 13일 우테코 후기.
1. 숨 쉴틈도 없이 바빴다.
2. 생각보다 시스템이 매우 체계적이다.

출근하자마자 데일리 미팅을 시작하고, 20여분 뒤 데일리 미팅이 끝나자 마자 수양과 회의룸을 잡고 페어 프로그래밍을 시작했다.
목표는 4시까지 끝내는 거였는데, 우리 둘 다 코드 퀄리티에 대한 욕심이 조금 있어서 인지 한 라인 쓸때마다 새로운 의문점과 개선 방안들이 나왔고.. 사실 리팩토링 할 시간이 구현 이후에 주어졌다면 더 좋았겠지만 리팩토링을 하지 않아도 PR 하는데에 큰 부끄러움은 없을 정도의 코드가 나왔다.

그렇게 10시부터 12시까지 페어 프로그래밍을 하고, 잠시 밥을 먹은 뒤 13시부터 18시까지 쉬지 않고 코딩했다. 페어 프로그래밍 경험은 정말 교육적이었고 좋았다. 우리가 다른 페어들보다 그래도 나름 재밌게 미션을 한 것 같다.

코딩하느라 바빠서 관련 문서나 Slack에 약간 소홀했던 것 같다. 페어에서 한 PC에서만 PR하면 되는 줄 알았는데 사실 두 명 모두 PR해야했다. 이 사실을 5분정도 늦게 알아서 마감 시간보단 약간 늦은 6시 5분에 PR과 Prolog을 작성했다.

그리고 29조의 연극 미션을 위한 회의를 오후 6시부터 7시 30분까지 했다. 다들 퇴근 시간이 지났음에도 계속 남아있는 것에 약간의 피곤함을 느꼈지만 나는 오히려 즐겼다. 이런 열정 가득한 분위기가 좋았던 것 같다.

7시 30분에는 백소정으로 29조원들과 밥을 먹으러 갔다, 돌아와서는 PR을 제출하느라 신경을 많이 쓰지 못했던 PR md, Prolog 회고 및 질답등을 하는 중이다.

현재 시간은 밤 9시 12분이다.

미션을 진행하면서 느낀 부분이, 내가 개발하는 미션이 정말 일반 사용자용 서비스라고 생각하고 모든 예외와 상황들을 처리해서 안정적이고 센스있는 프로그램을 만드는 건 목표로 설정해야할 것 같다.



#### Prolog 후기
정말 바쁘면서 재밌고 유익한 시간이었습니다. 페어였던 수양과 저 모두 코드에 욕심이 많아서인지 한 라인을 작성할 때마다 새로운 의문점과 개선점 같은 고민들이 떠올라서 시간을 빠듯하게 보낸 것 같아요. 리팩토링할 시간도 없었지만 그래도 마감 시간 내에 PR 할 수 있을만한 코드를 작성한 것 같습니다!  

그리고 미션을 진행하다 보니 마감 시간의 압박 때문에 있어야 할 기능을 포기하고 싶을 때가 있더라고요. 예를 들면 이번 미션에서 구현한 "거스름돈 거슬러주기" 같은 기능이 있습니다. 미션 요구사항에는 없었지만 거스름돈이 생긴 상황에서 아무런 처리도 하지 않으면 이상하니까요. 그래서 다음부터는 제가 진행하는 미션이 실제 사용자용 서비스라고 생각하고 임해야겠습니다!

- - -


### readme.md

### 🔹 토론 사항
- **정적 팩토리 메서드 네이밍 규칙**
  - 반드시 `of`, `from`으로만 네이밍해야 하는지 고민이 있었습니다.
  - `generateFrom`, `generateOf`와 같은 네이밍 방식도 허용할 수 있을까요?

- **`Lottos`에서 `Lotto`로 `NumberGenerator`를 넘기는 방식**
  - 현재 `Lotto`로 `NumberGenerator`를 계속 전달하는 방식이 불편합니다.
  - 더 나은 개선 방법이 있을까요?

- **`InputParser`의 패키지 위치**
  - 어떤 패키지에 위치시키는 것이 적절한지 의견이 나뉘었습니다.
  - 개발자의 취향 차이에 따라 결정될 부분일까요?

- **View에서 정제된 데이터를 넘길지, View에서 직접 처리할지**
  - View에서 정제된 데이터를 받아야 할까요?
  - 아니면, 일단 리턴받은 후 View에서 처리하는 것이 나을까요?

- **DTO에서 검증을 반드시 수행해야 하는가?**  
  - 검증을 수행하는 것이 바람직하다고 결론이 났습니다. (이건 다른분들 참고하시라고 작성했어요)

- **DTO 내부에서 비즈니스 검증을 수행할 경우, Validator를 따로 분리해야 하는가?**  
  - **Validator를 분리하는 의견**
    - DTO와 모델이 공통된 검증 로직을 가지므로 Validator를 분리하는 것이 좋다는 의견이 있었습니다.
  - **Validator를 모델 안에 유지하는 의견**
    - Validator가 존재해야 하는 곳은 해당 정보가 저장되거나 사용되는 위치라는 의견이 있습니다.

  **➡ 구현 방안**
  1. 모델 자체에 `validate` 메서드를 `static`으로 정의하여 DTO와 공유하는 방식  
  2. 별도의 `Validator` 클래스를 생성하여 모델과 DTO가 공유하는 방식  
  - Validator의 적절한 위치는 어디일까요?  

- **DTO를 어느 레이어에서 변환하는 것이 적절할까요?**  
  - **옵션 1:** 모델에서 바로 DTO를 생성한 후 반환  
  - **옵션 2:** 모델에서 `getter`로 데이터를 전달하고, 컨트롤러에서 DTO를 생성  

  **➡ 모델에서 DTO를 생성하는 방식의 장점**  
  - 데이터 관리가 모델 내부에서 이루어지므로 자연스러운 것 같습니다.

  **➡ 모델에서 DTO를 생성하는 방식의 단점**  
  - 출력층(View) 요구사항 변경 시 DTO 변환 로직을 수정해야 하므로 유지보수 비용이 증가할 것 같습니다.
  - 관심사 분리가 적절한지
  
- **흥미로운 발견**
  - 같은 클래스의 인스턴스는 매개변수로 받아와도 `getter` 없이 `this.`를 사용하여 `private` 접근이 가능합니다.

- **서비스 레이어에서 각 메서드가 의존성을 갖는 것이 맞을까요?**
  - 예: `calculatePrize` 후에 `calculateRateOfReturn`을 호출해야 하는 경우  
  - 서비스 메서드 간의 의존성을 어떻게 관리하는 것이 좋을까요?



Message 수양(양수빈)
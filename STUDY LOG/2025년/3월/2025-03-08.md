제네릭 학습 시작 및 학습내용 정리

### 클래스와 메소드가 다양한 타입을 갖게 하는법
1. Object 타입 사용
2. 그냥 여러개 정의
3. 제네릭 사용

Object는 타입 체크가 안되니까, 런타임 오류가 발생할 수 있음.
여러개 정의는 조금... 네..
제네릭은 객체의 타입을 컴파일 시점에 체크 가능, 번거로움이 줄어듦.

제네릭 클래스: 클래스명 뒤에 <> 로 표시. 보통 T라는 네이밍을 함.
제네릭 메서드: 접근제한자와 반환타입 사이에 선언.

중요 포인트: 타입이 무조건 일치해야 함. 상속 관계에 있다고 해도 타입이 일치하지 않으면 안됨. 제네릭 클래스는 서브타입 관계의 유지가 되지 않음. 제네릭은 불공변(Invariant) 함.

그래서 와일드카드가 필요함.
와일드 카드 기호: ?


\<?\>는 와일드카드기에 그냥 사용하면 Object와 다를 게 없음. 따라서 extends와 super을 적절히 사용해야 함.

```
<? extends T>
T와 그 자손 타입만 가능(upper bound)  
  
<? super T>
T와 그 조상 타입만 가능(lower bound)  

<?>
제한 없이 모든 타입이 가능. <? extends Object>와 동일한 표현
```

하지만, 와일드 카드를 사용하면 읽기 / 쓰기 제한이 생길 수 있다.

예를 들어 \<? extends Number> 라면, 들어올 수 있는 타입은 Integer, Double 등이다.
만약 list.get(i) 등을 한다면, Number타입임이 최소한 보장되기 때문에 안전하다.
하지만 list.add(new Integer()) 등을 한다면, list에 저장된 값이 Integer인지, Double인지 확신할 수 없기 때문에 불가능하다.

또, \<? super Integer> 라면, 들어올 수 있는 타입은 Integer, Number, Object등이 있다.
하지만 list.get(i); 가 무슨 값을 반환할 지 확신할 수 없으므로 Object 타입으로만 받을 수 있게 된다.
list.add(new Integer()) 은 안전하게 할 수 있다 (list가 Integer의 부모 타입을 참조하므로, List\<Object>  에 Integer를 추가 하는건 문제 없다.)


중요한 점을 하나 더 알게 되었다, 클래스는 컴파일 시점에 생성되는 틀이기 때문에, T를 직접 필드에 사용할 수 없지만 메서드는 런타임 시점에 매개변수에 의해 T가 확정되기 때문에, `T[]` 등으로 T를 메서드의 멤버변수에 사용할 수 있다.


가변인자 라는것이 있다. 파라미터에 다음과 같이: `(T... values)` 하면 인자를 몇개든지 받을 수 있다.
내부적으로 values는 `T[]`가 된다.



# PECS(Producer Extends, Consumer Super) 원칙
이것은 상당히 복잡해서, PECS 라고 외우면 실제로 적용할 때 편할 것 같다. 아니면 공변과 반공변에 대해서 무엇을 적용해야 하는지 할때마다 생각해야 한다.

먼저 공변과 반공변이라는 용어에 대해 먼저 알아보자. (진짜 살면서 처음 들어보는 용어다.)
원래는 수학 용어인 것 같은데, 공변(Covariant) 이란 co- variant 즉 직역하면 같이 변한다 라는 뜻이다.

공변성이란 자신이 상속받은 부모 객체로 타입을 변환시킬 수 있다는 뜻이다.
즉, Dog, Cat이 Animal을 상속받고 있고, ? extends Animal 한다면, 제네릭 ?는 공변하다.
왜냐하면 ?는 Animal로 형 변환할 수 있기 때문이다. 그 말은 즉슨, 데이터 읽기가 가능하다.

`Animal a = animal.get(0);` 왜냐하면 animal이 실제 뭐든간에, 부모로 형 변환하여 읽을 수 있기 때문이다.
하지만, 쓰는 것은 불가능하다. `animal.add()` 에서 우리는 animal이 Dog인지 Cat인지 확신할 수 없기 때문이다.

### 따라서 공변하다는 것은 읽기만 가능하다는 뜻이다.
공변하다 = 읽기 가능, 쓰기 불가능.
따라서 extends 는 읽을 필요가 있고 쓸 필요는 없을 때 사용한다. 즉 데이터를 제공(Produce) 할 때 사용한다.
Producer Extends. 제공하는 것은 Extends. 라는 뜻이다.

살짝 복잡한 수학식 외울 때 도움되려고 요약해놓은 공식 같은 게 PECS다. (현재로썬 그렇게 이해 중)

이제 Consumer Super에 대해 알아보자. Consumer은 소비한다는 뜻이고. 즉 제공받은 데이터를 소비한다(쓰기 작업 등으로). 그러면 불공변을 가지는 super로 제네릭을 하한 경계 한다는 뜻이다. (super은 상한만 허용하므로 하한 경계다)

그러면 쓰기가 가능해지고, 읽기는 최상위 타입 Object로만 가능해진다.


### 솔직히 복잡하다.
특히 Java 기초가 탄탄하지 않으면 금방 무너질 수 있다.
나도 이것을 내 머릿속에서 생각하는데에 많은 버퍼링이 걸린다.
따라서, 이론은 이렇구나~ 정도를 머릿속에 기억하고 실제로 사용할때에는 PECS 공식을 기억해두면 효율적일 것 같다.
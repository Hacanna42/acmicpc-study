제네릭 학습 시작 및 학습내용 정리

### 클래스와 메소드가 다양한 타입을 갖게 하는법
1. Object 타입 사용
2. 그냥 여러개 정의
3. 제네릭 사용

Object는 타입 체크가 안되니까, 런타임 오류가 발생할 수 있음.
여러개 정의는 조금... 네..
제네릭은 객체의 타입을 컴파일 시점에 체크 가능, 번거로움이 줄어듦.

제네릭 클래스: 클래스명 뒤에 <> 로 표시. 보통 T라는 네이밍을 함.
제네릭 메서드: 접근제한자와 반환타입 사이에 선언.

중요 포인트: 타입이 무조건 일치해야 함. 상속 관계에 있다고 해도 타입이 일치하지 않으면 안됨. 제네릭 클래스는 서브타입 관계의 유지가 되지 않음. 제네릭은 불공변(Invariant) 함.

그래서 와일드카드가 필요함.
와일드 카드 기호: ?


\<?\>는 와일드카드기에 그냥 사용하면 Object와 다를 게 없음. 따라서 extends와 super을 적절히 사용해야 함.

```
<? extends T>
T와 그 자손 타입만 가능(upper bound)  
  
<? super T>
T와 그 조상 타입만 가능(lower bound)  

<?>
제한 없이 모든 타입이 가능. <? extends Object>와 동일한 표현
```

하지만, 와일드 카드를 사용하면 읽기 / 쓰기 제한이 생길 수 있다.

예를 들어 \<? extends Number> 라면, 들어올 수 있는 타입은 Integer, Double 등이다.
만약 list.get(i) 등을 한다면, Number타입임이 최소한 보장되기 때문에 안전하다.
하지만 list.add(new Integer()) 등을 한다면, list에 저장된 값이 Integer인지, Double인지 확신할 수 없기 때문에 불가능하다.

또, \<? super Integer> 라면, 들어올 수 있는 타입은 Integer, Number, Object등이 있다.
하지만 list.get(i); 가 무슨 값을 반환할 지 확신할 수 없으므로 Object 타입으로만 받을 수 있게 된다.
list.add(new Integer()) 은 안전하게 할 수 있다 (list가 Integer의 부모 타입을 참조하므로, List\<Object>  에 Integer를 추가 하는건 문제 없다.)


중요한 점을 하나 더 알게 되었다, 클래스는 컴파일 시점에 생성되는 틀이기 때문에, T를 직접 필드에 사용할 수 없지만 메서드는 런타임 시점에 매개변수에 의해 T가 확정되기 때문에, `T[]` 등으로 T를 메서드의 멤버변수에 사용할 수 있다.


가변인자 라는것이 있다. 파라미터에 다음과 같이: `(T... values)` 하면 인자를 몇개든지 받을 수 있다.
내부적으로 values는 `T[]`가 된다.


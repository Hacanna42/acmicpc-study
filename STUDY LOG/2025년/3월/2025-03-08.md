제네릭 학습 시작 및 학습내용 정리

### 클래스와 메소드가 다양한 타입을 갖게 하는법
1. Object 타입 사용
2. 그냥 여러개 정의
3. 제네릭 사용

Object는 타입 체크가 안되니까, 런타임 오류가 발생할 수 있음.
여러개 정의는 조금... 네..
제네릭은 객체의 타입을 컴파일 시점에 체크 가능, 번거로움이 줄어듦.

제네릭 클래스: 클래스명 뒤에 <> 로 표시. 보통 T라는 네이밍을 함.
제네릭 메서드: 접근제한자와 반환타입 사이에 선언.

중요 포인트: 타입이 무조건 일치해야 함. 상속 관계에 있다고 해도 타입이 일치하지 않으면 안됨. 제네릭 클래스는 서브타입 관계의 유지가 되지 않음. 제네릭은 불공변(Invariant) 함.

그래서 와일드카드가 필요함.
와일드 카드 기호: ?


\<?\>는 와일드카드기에 그냥 사용하면 Object와 다를 게 없음. 따라서 extends와 super을 적절히 사용해야 함.

```
<? extends T>
T와 그 자손 타입만 가능(upper bound)  
  
<? super T>
T와 그 조상 타입만 가능(lower bound)  

<?>
제한 없이 모든 타입이 가능. <? extends Object>와 동일한 표현
```

하지만, 와일드 카드를 사용하면 읽기 / 쓰기 제한이 생길 수 있다.

예를 들어 \<? extends Number> 라면, 들어올 수 있는 타입은 Integer, Double 등이다.
만약 list.get(i) 등을 한다면, Number타입임이 최소한 보장되기 때문에 안전하다.
	하지만 list.add(new Integer()) 등을 한다면, list에 저장된 값이 Integer인지, Double인지 확신할 수없기 때문에 불가능하다.

또, \<? super Integer> 라면, 들어올 수 있는 타입은 Integer, Number, Object등이 있다.
하지만 list.get(i); 가 무슨 값을 반환할 지 확신할 수 없으므로 Object 타입으로만 받을 수 있게 된다.
list.add(new Integer()) 은 안전하게 할 수 있다 (list가 Integer의 부모 타입을 참조하므로, List\<Object>  에 Integer를 추가 하는건 문제 없다.)


중요한 점을 하나 더 알게 되었다, 클래스는 컴파일 시점에 생성되는 틀이기 때문에, T를 직접 필드에 사용할 수 없지만 메서드는 런타임 시점에 매개변수에 의해 T가 확정되기 때문에, `T[]` 등으로 T를 메서드의 멤버변수에 사용할 수 있다.


가변인자 라는것이 있다. 파라미터에 다음과 같이: `(T... values)` 하면 인자를 몇개든지 받을 수 있다.
내부적으로 values는 `T[]`가 된다.




# Prolog에서의 PECS 설명
제네릭은 재사용성과 강력한 타입 검증을 동시에 지킬 수 있는 유연한 방법입니다.
상한 경계(upper bounded, 즉 extends) 와 하한 경계(lower bounded, 즉 super) 을 활용하면 타입을 특정 오브젝트의 부모 혹은 자식으로 제한할 수 있습니다.

하지만 제네릭은 서브 타입 관계가 유지되지 않는 불공변(invariant) 성질을 가지고 있습니다. 따라서 상속 관계에 있더라도 타입이 일치하지 않으면 컴파일 오류를 일으킵니다. 타입이 정확히 일치해야만 할당할 수 있습니다.

따라서 와일드 카드 '?' 와 상한, 하한 경계를 사용해서 공변, 반공변 성질로 변경할 수 있습니다.

일단, 공변과 불공변 용어를 먼저 설명하겠습니다.
공변(covariant)성이란, 제네릭 타입이 부모 타입을 참조할 수 있도록 허용하는 성질입니다. 즉, ? extends Animal을 사용하면 List\<Dog>나 List\<Cat> 같은 하위 타입을 List\<? extends Animal>로 참조할 수 있지만, 새로운 요소를 추가할 수는 없습니다.

반공변(contravariant)성이란 제네릭 타입이 T의 부모 타입을 참조할 수 있도록 허용하는 성질입니다. 예를 들어 List\<? super Dog>는 List\<Animal> 또는 List\<Object>를 참조할 수 있습니다. 이 경우, Dog 또는 그 하위 타입을 추가할 수 있지만, 요소를 읽으면 Object 타입이 됩니다.

따라서, 제네릭이 공변성을 가지고 있다면 읽는 작업이 가능해집니다. 왜냐하면 모두 부모 타입으로 읽을 수 있기 때문입니다. 하지만 쓰기 작업은 불가능합니다. 왜냐하면 부모 타입은 확실히 알지만, 어떤 자식 타입을 써야되는지 확신할 수 없기 때문입니다.

이해가 어렵기 때문에, 아래의 예시를 들어서 다시 설명해보겠습니다.
`Animal a = animal.get(0);` 의 경우에는 animal이 실제 뭐든간에, 부모로 형 변환하여 읽을 수 있습니다.
하지만, 쓰는 것은 불가능합니다. `animal.add()` 에서 우리는 animal이 Dog인지 Cat인지 확신할 수 없기 때문입니다.

따라서, 우리가 읽기 작업을 해야하고, 쓰기 작업은 필요 없다면 제네릭을 공변성 있게 사용해야 합니다.
만약, 쓰기 작업을 해야한다면 반공변 성질을 이용해야 합니다.

만약 ? super Animal 로 하한 경계를 한다면, extends와 반대로 제네릭 타입이 뭐든간에 쓰기 작업에 Animal을 사용할 수 있습니다. 왜냐하면 제네릭 타입이 Animal의 조상인 것이 보장되기 때문입니다.
읽기 작업을 하려면 최상위 타입인 Object로만 읽을 수 있게 됩니다.

솔직히 이것을 매번 생각하는 것은 많이 복잡한 과정입니다.
따라서 이것을 이해하는데에는 PECS라는 공식이 효율적입니다.

PECS(Producer Extends, Consumer Super)
결론적으로 extends 는 읽을 필요가 있고 쓸 필요는 없을 때 사용합니다. 즉 데이터를 제공(Produce) 할 때 사용합니다. 그렇기에 Producer Extends. 제공하는 것은 Extends. 라는 뜻입니다. Consumer은 소비한다는 뜻이고. 즉 제공받은 데이터를 소비한다(쓰기 작업 등으로). 즉 Super 여야 한다는 뜻입니다.
이것을 줄여서 PECS 법칙(Producer Extends, Consumer Super) 라고 할 수 있습니다.










# GPT의 정리... (학습용)




**제네릭과 PECS 원칙** 제네릭은 **재사용성과 강력한 타입 검증을 동시에 유지할 수 있는 유연한 방법**입니다. 상한 경계(upper bounded, `extends`)와 하한 경계(lower bounded, `super`)를 활용하면 **타입을 특정 객체의 부모 또는 자식으로 제한할 수 있습니다.** 하지만 제네릭 타입은 기본적으로 **불공변(invariant)**이므로, 서브 타입 관계가 유지되지 않습니다. 즉, `List<Dog>`는 `List<Animal>`의 하위 타입이 아니며, 타입이 정확히 일치해야만 할당할 수 있습니다. 이 문제를 해결하기 위해 **와일드카드(`?`), `extends`, `super`를 사용하여 공변(covariant)과 반공변(contravariant) 성질을 적용할 수 있습니다.** 

--- 

## **📌 공변성과 반공변성**
### **✅ 공변(Covariant)**
공변성이란 **제네릭 타입이 부모 타입을 참조할 수 있도록 허용하는 성질**입니다. 즉, `? extends Animal`을 사용하면 `List<Dog>`나 `List<Cat>` 같은 하위 타입을 `List<? extends Animal>`로 참조할 수 있습니다. 하지만 **새로운 요소를 추가할 수는 없습니다.** 

```
java List<? extends Animal> animals = new ArrayList<Dog>(); // ✅ 가능
Animal a = animals.get(0); // ✅ 가능 (모든 요소를 Animal로 읽을 수 있음) animals.add(new Animal()); // ❌ 불가능 (어떤 하위 타입인지 모르므로 추가 불가능)
```

### **✅ 반공변(Contravariant)**

반공변성이란 **제네릭 타입이 `T`의 부모 타입을 참조할 수 있도록 허용하는 성질**입니다.  
즉, `List<? super Dog>`는 `List<Animal>` 또는 `List<Object>`를 참조할 수 있습니다.  
이 경우, `Dog` 또는 그 하위 타입을 추가할 수 있지만, **읽을 때는 `Object` 타입으로 반환됩니다.**

```java
List<? super Dog> dogs = new ArrayList<Animal>(); // ✅ 가능
dogs.add(new Dog()); // ✅ 가능 (Dog을 추가할 수 있음)
dogs.add(new Animal()); // ❌ 불가능 (Animal은 Dog의 부모이므로 추가 불가)

Object obj = dogs.get(0); // ✅ 가능 (읽을 때 Object로 반환)
Dog d = dogs.get(0); // ❌ 불가능 (Object이므로 Dog로 직접 변환 불가)
```

📌 **쓰기 가능, 읽기 불가능!**  
👉 **이유:** `dogs`가 `List<Animal>`인지 `List<Object>`인지 정확히 알 수 없으므로, 안전한 반환 타입은 `Object`뿐입니다.

---

## **📌 언제 공변성을 사용하고, 언제 반공변성을 사용해야 할까?**

- **읽기(데이터 제공)만 필요할 때 → `? extends` (공변)**
- **쓰기(데이터 소비)만 필요할 때 → `? super` (반공변)**

이해하기 어렵다면, **PECS 원칙(Producer Extends, Consumer Super)을 기억하면 쉽게 해결할 수 있습니다!** 🚀

---

## **📌 PECS(Producer Extends, Consumer Super)**

PECS 원칙은 제네릭을 안전하게 사용할 수 있도록 도와주는 규칙입니다.

- **`extends`는 데이터를 제공(읽기 전용)할 때 사용**
- **`super`는 데이터를 소비(쓰기 가능)할 때 사용**











# Outdated
# PECS(Producer Extends, Consumer Super) 원칙
이것은 상당히 복잡해서, PECS 라고 외우면 실제로 적용할 때 편할 것 같다. 아니면 공변과 반공변에 대해서 무엇을 적용해야 하는지 할때마다 생각해야 한다.

먼저 공변과 반공변이라는 용어에 대해 먼저 알아보자. (진짜 살면서 처음 들어보는 용어다.)
원래는 수학 용어인 것 같은데, 공변(Covariant) 이란 co- variant 즉 직역하면 같이 변한다 라는 뜻이다.

공변성이란 자신이 상속받은 부모 객체로 타입을 변환시킬 수 있다는 뜻이다.
즉, Dog, Cat이 Animal을 상속받고 있고, ? extends Animal 한다면, 제네릭 ?는 공변하다.
왜냐하면 ?는 Animal로 형 변환할 수 있기 때문이다. 그 말은 즉슨, 데이터 읽기가 가능하다.

`Animal a = animal.get(0);` 왜냐하면 animal이 실제 뭐든간에, 부모로 형 변환하여 읽을 수 있기 때문이다.
하지만, 쓰는 것은 불가능하다. `animal.add()` 에서 우리는 animal이 Dog인지 Cat인지 확신할 수 없기 때문이다.

### 따라서 공변하다는 것은 읽기만 가능하다는 뜻이다.
공변하다 = 읽기 가능, 쓰기 불가능.
따라서 extends 는 읽을 필요가 있고 쓸 필요는 없을 때 사용한다. 즉 데이터를 제공(Produce) 할 때 사용한다.
Producer Extends. 제공하는 것은 Extends. 라는 뜻이다.

살짝 복잡한 수학식 외울 때 도움되려고 요약해놓은 공식 같은 게 PECS다. (현재로썬 그렇게 이해 중)

이제 Consumer Super에 대해 알아보자. Consumer은 소비한다는 뜻이고. 즉 제공받은 데이터를 소비한다(쓰기 작업 등으로). 그러면 불공변을 가지는 super로 제네릭을 하한 경계 한다는 뜻이다. (super은 상한만 허용하므로 하한 경계다)

그러면 쓰기가 가능해지고, 읽기는 최상위 타입 Object로만 가능해진다.


### 솔직히 복잡하다.
특히 Java 기초가 탄탄하지 않으면 금방 무너질 수 있다.
나도 이것을 내 머릿속에서 생각하는데에 많은 버퍼링이 걸린다.
따라서, 이론은 이렇구나~ 정도를 머릿속에 기억하고 실제로 사용할때에는 PECS 공식을 기억해두면 효율적일 것 같다.
- 앞으로 README.md 를 사용자 중심으로 작성해야겠다고 생각했다.
- JDBC의 기초와 Docker 설정을 했다.
- 장기 step1 리팩터링을 끝내고 재 제출했다.

내일의 목표(자고 일어나서)
- 리뷰가 왔다면 리뷰 반영 및 step2 구현
- 오브젝트 4장 읽고 정리









---



# 오브젝트 4장 정리
# 설계 품질과 트레이드 오프

협력을 설계하기 위해서는 책임에 초점을 맞춰야 한다.

책임을 찾고, 적절한 객체를 할당하는 설계 방법을 **책임 주도 설계**라고 한다.

객체 지향 설계의 핵심은 ‘역할, 책임, 협력’ 이다. 애플리케이션의 기능을 구현하기 위해 메시지를 주고받는 객체들 사이의 상호작용이다.

**책임 주도 설계** 라는 말에서 알 수 있듯이, 역할 책임 협력중에서 제일 중요한 것은 ‘책임’이다. 객체들이 수행할 책임이 적절하게 할당되지 못한 상태에서는 원활한 협력을 기대할 수 없다.

따라서, 객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 **낮은 결합도와 높은 응집도**를 가진 구조를 창조하는 활동이다.

## 설계는 변경을 위해 존재한다

설계는 변경을 위해 존재하고, 변경에는 어떤 식으로든 비용이 발생한다. 훌륭한 설계란 합리적인 비용 안에서 변경을 수용할 수 있는 구조를 만드는 것이다. 그리고 그러한 구조는 응집도가 높고, 서로 느슨하게만 연결되어 있는 구조를 갖는다.

**그렇다면, 결합도와 응집도를 어떻게 합리적인 수준으로 유지하는가?**

- 객체의 상태가 아니라 행동에 초점을 맞춰야 한다.
- 객체를 단순히 데이터의 집합으로 바라보는 시간은 객체의 내부 구현을 인터페이스에 노출하는 결과를 낳는다.
- 따라서 결합도가 높아지고, 응집도가 낮아진다. 그러므로 변경에 취약해진다.

## 나쁜 설계 예시

- 데이터 중심 설계(상태 중심 설계)는 구현에 관한 세부사항이 인터페이스에 스며들게한다.
    - 객체의 상태는 ‘구현’에 속한다. 변하기 쉬운 구현 세부사항은 캡슐화를 파괴한다.
- 객체의 책임은 인터페이스에 속한다.
    - 객체의 책임을 표현하는 안정적인 인터페이스 뒤로, 책임을 수행하는데에 필요한 상태를 캡슐화함으로써 구현 변경에 대한 파장이 외부로 퍼져나가는 것을 방지한다.

따라서, 책임에 초점을 맞춰 설계하면 상대적으로 변경에 안정적인 설계를 얻을 수 있게된다.

(코드 내용은 생략)

- 객체에 필요한 데이터를 먼저 생각하고, 코드를 짜는 과정이었다.

## 좋은 설계의 특징

객체지향 커뮤니티에서는 오랜 기간 동안 좋은 설계의 특징을 파악할 수 있는 기준을 논의해왔다.

- 캡슐화
    - 상태와 행동을 하나의 객체 안에 모으면, 객체의 내부 구현을 외부로부터 감출 수 있다. 변경될 가능성이 높은 부분을 구현이라고 부르고, 상대적으로 안정적인 부분을 **인터페이스** 라고 부른다.

복잡성을 다루기 위한 가장 효과적인 도구는 추상화다. 그리고 객체지향 프로그래밍에서 복잡성을 취급하는 주요한 추상화 방법은 **캡슐화**다. 하지만, 객체 지향 언어를 사용한다고만 해서 이것이 이루어진다는 것은 아니다. 오직 설계 과정동안 캡슐화를 목표로 인식할 때만 달성할 수 있다.

- 응집도
    - 응집도는 모듈에 포함된 내부 요소들의 연관된 정도를 나타낸다.
- 결합도
    - 결합도는 의존성의 정도를 나타낸다.
    - 어떤 모듈이 다른 모듈에 대해 너무 자세한 부분까지 알고 있다면 두 모듈은 높은 결합도를 가진다.

일반적으로 좋은 설계란 높은 응집도와, 낮은 결합도를 가진 설계를 말한다. 변경의 관점에서 **응집도**란 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도로 측정할 수 있다.

![image.png](attachment:e57dc43a-f529-4f8e-824b-b45af2984793:image.png)

응집도가 낮은 설계에서는, 하나의 변경에도 여러개의 모듈이 변경되어야 한다.

변경의 관점에서 **결합도**란 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도로 나타낼 수 있다.

![image.png](attachment:66f27dfb-5cbe-432a-90dc-100d10c92023:image.png)

높은 결합도를 가진 설계에서는, A 하나를 변경하는데 주변이 모두 변경되어야 한다.

### 결합도가 높아도 상관 없는 경우

결합도가 높아도 상관 없는 경우도 있다. 매우 안정적인 모듈에 의존하는 것은 아무런 문제도 되지 않는다.

예를 들어 표준 라이브러리에 포함된 모듈이나 성숙 단계에 접어든 프레임워크에 의존하는 경우가 여기에 해당된다.

자바의 String이나 ArrayList에 의존하여 결합도가 높아지더라도, String과 ArrayList가 변경될 확률은 매우 낮다.

### 캡슐화의 정도는 응집도와 결합도에 영향을 미친다

캡슐화를 지키면 모듈 안의 응집도는 높아지고, 결합도는 낮아진다.

따라서 응집도와 결합도를 고려하기전에 먼저 캡슐화를 향상시키기 위해 노력하여야 한다.

(코드 생략)

- 캡슐화 위반 예시
- 높은 결합도 예시
- 낮은 응집도 예시

## 캡슐화는 설계의 제 1원리다

데이터 중심의 설계가 낮은 응집도와 높은 결합도를 가지게 된 이유는 근본적으로 캡슐화를 위반했기 때문이다.

객체는 자신이 어떤 데이터를 가지고 있는지를 내부에 캡슐화하고 외부에 공개해서는 안된다. 객체는 스스로의 상태를 책임져야 하며 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근할 수 있어야 한다.

여기서 말하는 메서드는 단순히 `getter` 같은 게 아니라, 객체가 책임져야하는 무언가를 수행하는 메서드를 말한다.

```jsx
class Rectangle {
	private int left;
	private int top;
	private int right;
	private int bottom;
	
	...
	
	public int getLeft() {}
	public int setLeft() {}
	public int getRight() {}
	public int setRight() {}
	...

}
```

위 코드에는 많은 문제점이 있다.

1. 사각형의 넓이를 계산하는 코드가 필요하다면, 이 코드는 외부에서 getter을 통해 처리하게 될 것이고, 그러면 다른 위치에서 다시 그 코드를 구현하게 될 수도 있다. 즉 코드 중복이 발생한다.
2. 변경에 취약하다. 만약 내부 필드의 이름이 length, height 등으로 변경된다면 getter와 setter의 메서드를 모두 변경해야 한다.

해결 방법은 캡슐화를 시키는 것이다. 너비와 높이를 조절하는 로직을 객체 내부에 구현해서 객체의 데이터를 스스로 책임하도록 한다.

## 스스로 자신의 데이터를 책임지는 객체

(코드 생략)

- 이 객체가 어떤 상태를 포함해야 하는가?
- 상태에 대해 수행해야 하는 오퍼레이션은 무엇인가?

라는 사고 흐름으로 리팩터링을 했다고 한다.

리팩터링된 코드에서는 결합도 문제가 개선되었지만, 본질적인 문제는 해결되지 않았다.

본질적으로, 현재 방식 역시 데이터 중심 설계다.

만약 특정 속성을 수정해야 한다면, 해당 메서드를 사용하는 모든 클라이언트도 코드를 수정해야 하는 파급 효과(ripple effect) 가 일어난다. (내부 구현 변경이 외부로 퍼져나가는 효과)

이것은 캡슐화가 부족하다는 명백한 증거다.

## 캡슐화의 진정한 의미

- 변할 수 있는 어떤 것이라도 외부로부터 감추는 것
- 내부 속성을 외부로부터 감추는 것은 ‘데이터 캡슐화’라는 캡슐화의 한 종류일 뿐이다.

## 데이터 중심 설계의 문제점

- 데이터 중심 설계는 너무 이른 시기에 데이터에 관해 결정하도록 한다.
- 협력이라는 문맥을 고려하지 않고 객체를 고립시킨다. (어떤 객체도 섬이 아니다)

설계를 시작하는 초반부터 데이터에 대해 결정하게 하는 데이터 중심 설계는, 너무 이른 시기에 내부 구현에 초점을 맞추게 한다.

데이터를 먼저 결정하고, 데이터를 처리하는데 필요한 오퍼레이션을 나중에 결정하는 방식은. 데이터에 관한 지식이 객체의 인터페이스에 고스란이 드러남게 된다. 따라서 캡슐화를 준수하지 못하게 되고, 변경에 취약한 코드가 된다.

객체지향 애플리케이션을 구현한다는 것은 협력하는 객체들의 공동체를 구축한다는 것을 의미한다. 객체가 내부에 어떤 상태를 가지고, 그 상태를 어떻게 처리할 것인지는 부가적인 문제다. 중요한 것은 어떻게 협력하냐다.

데이터 중심 설계의 초점은 객체의 외부가 아니라 내부로 향한다. 객체의 구현이 이미 결정된 상황에서 다른 객체와의 협력을 고려하게 되니 이미 구현된 객체의 인터페이스를 억지로 끼워맞출 수밖에 없게 된다.





---



## 오후 7시 48분
궁성 영역을 구하기 위한 Adjacency, Nodes 클래스를 작성했다.
하드 코딩을 많이 사용했는데, 처음 작성할때는 힘들지만 작성하고 나면 가독성도 좋고, 수정도 용이하고, 편한 것 같다.

시소, 부기와 오랜 토론 끝에. 현재 내 설계에는 순환 참조의 가능성을 배제할 수 없다는 것을 알았다.
Piece가 다른 Piece를 파라미터로 받아 사용하기 때문에, 순환 참조의 가능성이 있다.


- Piece로 Map\<>이 아니라 Board 자체를 넘기면 문제점 = Board에 너무 의존함
- Map을 넘기면 의존 문제가 해결되나? -> 해결되진 않지만 변경 가능성이 없는 안정적인 인터페이스에 의존함으로써, 의존성의 역전이 일어난다.
- 그러면, VisibleBoard 를 만들어서 사용할 메서드만 추리고 넘기는 것은? -> VisibleBoard는 변경 가능성이 너무 크다
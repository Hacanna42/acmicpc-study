몇달 전에 오브젝트 책을 8장쯤까지 읽었는데, 그때와 현재는 객체 지향에 대한 시선이 많이 달라져서 복습 겸 처음부터 다시 읽고있다.



# 오브젝트 2장 정리
## 구현 도메인 정리

- 온라인 영화 예매 시스템
- 영화가 가지고 있는 기본적인 정보를 ‘영화’ 라고 함.
- ‘상영’은 실제로 관객들이 영화를 관람하는 사건을 표현

추가: 도메인 관련 지식을 통일해놔야 협업할 때 커뮤니케이션 미스가 안생김.

- 할인 조건: 할인 여부를 걸정하는 조건. ‘순서 조건’ 과 ‘기간 조건’이 있음.
- 할인 정책: 할인 요금을 결정하는 조건. ‘금액 할인’ 과 ‘비율 할인’이 있음.

할인 정책은 무슨 할인 조건이 적용되는지와는 상관 없이, 무조건 그 영화에는 이정도의 요금을 할인한다는 뜻임.

할인 조건이 하나라도 충족되어야 할인 정책을 적용할 수 있음. 따라서 할인 정책은 없거나 1개여야 하고. 할인 조건은 여러개일 수 있음.

## 클래스와 객체를 구분하라

어떤 클래스가 필요한지를 고민하기 전에, 어떤 객체들이 필요한지 고민하라.

객체를 독립적인 존재가 아니라, 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐라.

## 클래스는 내부와 외부로 구분된다

객체는 상태와 행동을 가지는 복합적이고, 자율적인 존재다.

데이터와 기능을 객체 내부로 함께 묶는 것을 캡슐화라고 한다.

대부분의 객체지향 프로그래밍 언어는 캡슐화에서 한걸음 더 나아가 외부에서의 접근을 통제할 수 있는 접근 제어 매커니즘을 제공한다.

접근을 통제하는 이유는 객체를 자율적인 존재로 만들기 위해서다.

접근을 통제하는 것이 객체의 자율성과 무슨 상관인가: 외부의 간섭을 최소화 할 수 있다. 그러면 외부에서는 객체가 어떤 상태에 놓여있는지, 어떤 일을 하고 있는지 모르게 된다. 객체에게 원하는 것만을 요청하고 객체가 처리하기를 바랄 뿐이다.

이렇게 외부에서 접근 가능한 부분을 **퍼블릭 인터페이스**라고 부른다.

내부에서만 접근 가능한 부분을 **구현** 이라고 부른다.

## 클래스 작성자와 클라이언트 프로그래머

설계에 유용한 생각법:

프로그래머의 역할을 클래스 작성자와 클라이언트 프로그래머로 분리하기.

클라이언트 프로그래머는 필요한 클래스들을 엮어서 빠르게 애플리케이션을 구축하는 것이 목표다.

클래스 작성자는 필요한 정보만 클라이언트 프로그래머에게 공유하고 나머지는 꽁꽁 숨겨야 한다.

그래야만 클래스 작성자는 클라이언트 프로그래머에게 끼칠 영향을 생각하지 않고도 내부 구현을 변경할 수 있다. 이것이 **은닉**이다.

## 다형성을 이용한 코드 개선

… (생략)

- 오버라이딩: 부모 클래스의 같은 이름, 같은 파라미터의 메서드를 자식 클래스에서 재정의
- 오버로딩: 메서드의 이름은 같지만 파라미터의 목록이 다른 경우

## 컴파일 시간 의존성과 실행 시간 의존성

Movie 클래스는 오직 추상 클래스인 DiscountPolicy 클래스와 연결되어 있다.

영화 요금을 계산하려면 분명 AmountDiscountPolicy나 PercentDiscountPolicy가 필요한데..

Movie는 실행 시간에, 코드 작성 시점에서는 알 지 못했던 AmountDiscountPolicy, PercentDiscountPolicy의 인스턴스와 협력 가능하게 된다.

이것은 Java의 다형성을 사용한 특징이다. (다형성은 다 알테니까 ..)

이렇게 코드의 의존성과 실행 시간의 의존성은 다를 수 있다. 일반적으로 유연하고, 쉽게 재사용할 수 있으며, 확장 가능한 객체지향 설계가 가지는 특징은 컴파일 시간 의존성과 실행 시간 의존성이 다르다는 것이다.

하지만, 다형성을 사용할 수록 코드의 이해가 어려워진다. 왜냐면 코드에서 명확하게 의존성을 연결하는 부분이 보이지 않기 때문이다. 따라서 이것은 트레이드 오프, 양날의 검이다.

## 상속

상속은 코드를 재사용하기 위해 가장 널리 사용되는 방법이다.

상속이라는 관계를 설정하는 것만으로도 기존 클래스가 가지고 있는 모든 속성과 행동을 새로운 클래스에 포함시킬 수 있다.

DiscountPolicy를 그대로 물려받는 Amount.. Percent..가 그 예라고 할 수 있다.

그리고 특정 행동이 다른 자식 클래스의 메서드를 오버라이드해서 재정의 할 수 있다.

이처럼 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 것을 “차이에 의한 프로그래밍” 이라고 한다.

### 상속이 가치있는 이유

상속은 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스에게 물려준다.

상속을 통해 자식 클래스가 부모의 모든 인터페이스를 포함하게 되면, 결과적으로 자식 클래스는 부모 클래스가 받을 수 있는 모든 메시지를 처리할 수 있기 때문에 외부 객체는 자식 클래스를 부모 클래스와 동일한 타입으로 간주할 수 있다.

따라서 컴파일 시간에 의존하는 인스턴스가 바뀔 수 있다. 이것이 다형성이다.

이처럼 자식 클래스가 부모 클래스를 대신하는 것을 **업캐스팅** 이라고 한다.

- 구현 상속(서브클래싱): 코드 재사용하려고 구현을 상속하는 것
- 인터페이스 상속(서브타이핑): 다형적인 협력을 위해 부모의 인터페이스를 상속하는 것

## 유연한 설계

‘스타워즈’는 아무런 할인 정책이 없다. 따라서 바로 기본 금액을 반환하면 되는데, 할인된 금액을 계산할 책임이 DiscountPolicy의 자식 클래스에 있다가 → Movie로 갔기 때문에 협력의 일관성이 무너진다.

따라서 NoneDiscountPolicy를 추가해서 할인되지 않음을 표현하자.

이렇게 하면 기존 코드를 수정하지 않고 애플리케이션의 기능을 확장할 수 있다. 이렇게 추상화는 유연한 설계를 가능하게 한다. 추상화는 설계가 구체적인 상황에 결합되는 것을 방지한다.

## 결론

유연성이 필요한 곳에 추상화를 사용하라.

## 추상 클래스와 인터페이스 트레이드 오프

처음 코드의 문제점: 추상 클래스의 메서드가, 할인 조건이 설정되지 않으면 0원을 반환하도록 구현되어 있기 때문에, NoneDiscountPolicy가 0을 반환하는 메서드를 구현했더라도 실제론 할인 조건이 없으면 NoneDiscountPolicy의 메서드를 통해 0이 반환되는 게 아니라, DiscountPolicy가 0을 반환함.

따라서 구현에는 문제가 없지만 개념적인 혼란을 불러 일으킴.

이 문제를 해결하려면 DiscountPolicy를 인터페이스로 변경해서 내부 구현을 없애고, 항상 자식 인스턴스의 메서드를 사용하도록 해야 함.

하지만, 현실적으로는 NoneDiscountPolicy만을 위해서 인터페이스를 추가하는 것이 과하게 느껴질 수 있음.

모든 것은 트레이드 오프고, 오브젝트에서는 설명해야 하는 책을 고려했을 때 결국 인터페이스를 추가하지 않기로 함.

## 상속의 단점

1. 상속은 캡슐화를 위반한다

상속을 이용하려면 부모 클래스의 내부 구현을 잘 알고 있어야 하기 때문이다.

결과적으로 부모 클래스의 구현이 자식 클래스에 노출되기 때문에, 부모 클래스가 변경될 때 자식 클래스도 변경될 확률을 높인다.

1. 설계가 유연하지 않다

상속은 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시간에 정한다. 따라서, 실행 시점에 객체의 종류를 변경할 수 없다.

예를 들어서 현재의 금액 할인 정책 영화를 → 비율 할인 정책 영화로 변경한다고 가정하자

상속을 사용한 설계라면, 인스턴스 자체를 변경해야 하기 때문에 변경이 매우 힘들다.

하지만, 합성을 사용하면 단순한 작업으로 가능하다.

`this.discountPolicy = discountPolicy`

상속이 아니라 Movie가 discountPolicy를 재사용하는 방법 (필드에 포함하고 있는 방법) 도 코드를 재사용하는 방법이다. 그리고 이 방법은 너무나도 유용해서 특별하게 불린다.

## 합성

상속과 다른 점은 컴파일 시간에 부모와 자식이 강하게 결합되는 반면에,

합성은 인터페이스를 통해 약하게만 연결된다. 실제로 Movie는 인터페이스가 제공하는 메시지만 알고 있고, 내부 구현에 대해서는 절대 알지 못한다. 이 방법을 합성이라고 한다.

하지만 다형성을 위해선 상속을 사용해야 하기 때문에 항상 합성만을 사용할 순 없다.

따라서 상속과 합성을 적절히 조합하여 사용하는 것이 좋다.
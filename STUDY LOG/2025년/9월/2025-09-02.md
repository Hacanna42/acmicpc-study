일주일간의 방학을 끝났다. 잠실 캠퍼스에 복귀했다.
개인 사유때문에 바쁜 방학을 보냈다.

- 포비의 올바른 학습법 강의
- 구구의 레벨 4 미션 OT
- HTTP 구현 실습

## HTTP 탐구


🔍 관찰 결과 기록
HTTP 메시지의 형태: 사람이 볼 수 있는 일반 텍스트였다. 
요청 메시지 첫 줄의 구성: 요청 메서드, 요청 주소 현재 사용중인 프로토콜 버전 정보가 포함되어 있어 보인다.
응답 메시지 첫 줄의 숫자: 현재 프로토콜 버전과, 응답 상태 코드를 응답받았다. 200은 응답 완료? 정상 처리 같은 뜻인 것 같다.


질문1: HTTP의 형태는 왜 사람이 보기 쉽게 만들어져 있을까? 기계들간의 소통에 쓰이면 사람이 못 봐도, 기계끼리 파싱이 편한 형태로 만들어도 괜찮지 않았을까?
질문2: HTTP 버전 1.1은 최신 버전일까? 최신 버전이라면 왜 아직도 1.1일까? 없는 버전을 쓰거나 응답과 요청 간의 버전이 다르면 어떻게 될까?
질문3: 주소창 입력으로 post, delete, put 이런 요청은 왜 못보낼까요

답변1: HTTP는 기존 버저닝 없이 사용되었다가, 0.9버전으로 시작 했으며 1.0 개선을 거쳐 1.1로 표준화 되었다. 

답변2: HTTP 버전 2도 있고 3도 있지만, RFC - Draft Standard는 HTTP 1.1이다. 1.1이 가장 널리 사용되는 듯 보인다.


1분 대기 실험 결과: Network 탭에 새로운 항목이 추가되었나요? 아니요.
지연 응답의 특징: 5초 동안 서버가 중간에 무언가를 보냈나요? 아니면 5초 후 한 번에 보냈나요? 한번에 보냈습니다.
UUID 값 비교: 두 값이 달랐습니다.

Q. 만약 실시간 채팅을 만들려면 이 제약을 어떻게 해결할까?
생각: HTTP로 가능한가? 상대가 메시지를 보냈을 때, 서버에서 먼저 응답을 보내는 게 가능할까? 지금까지의 관찰 결과로는 무조건 클라이언트의 요청 이후 서버가 응답을 하기 때문에, 클라이언트에서 0.1초마다 새로고침을 계속 하도록 하면 채팅을 구현할 수 있지 않을까?
A: HTTP는 반이중 통신(Half-Duplex) 즉 무전기처럼 양쪽 다 서로에게 통신할 수 있지만, 동시에 통신할 수 없다. 또 서버-클라이언트 구조에서 클라이언트의 요청이 있어야만 서버가 응답할 수 있다. 따라서 실시간 채팅에는 그다지 적절한 방법이 아니다, 하지만 내 생각대로 클라이언트에서 주기적으로 새로고침 요청을 하는 방법으로 구현할 수 있지만 불필요하게 계속 새로고침을 하므로 오버헤드가 발생한다. 이 방법을 Polling 이라고 한다. 이 방법보다 더 좋은 방법은 프로토콜을 HTTP 에서 WebSocket으로 변경하는 것이다. WebSocket은 양방향 통신(Full-Duplex) 프로토콜이다. RFC - Proposed Standard로 표준이다. 등장 배경은 실시간 소통이다. TCP 방식을 사용한다. HTTP와는 다르게 최초 연결이 이뤄지면 통신이 끊기지 않고 지속적으로 소통할 수 있다.이때 데이터는 패킷(packet) 형태로 전달되며, 전송은 연결 중단과 추가 HTTP 요청 없이 양방향으로 이뤄진다. WebSocket 통신을 시작하는 방법은 HTTP 헤더에 Upgrade: websocket 같은 문구를 사용하면 "101 Switching Protocol" 상태 코드 응답과 함께 소켓 통신으로 전환된다.

Q. 패킷이 뭔데?
A. 패킷은 프로토콜 내에서 데이터를 어떤 형식으로 전달할 지 약속해놓은 규격이다. RFC처럼 표준적으로 등록된 개념은 아니고, 각 표준 프로토콜에서 데이터를 보내는 작은 단위와 규칙을 패킷이라고 통칭한다.

Q. YouTube 실시간 스트리밍은 어떻게 가능할까?
생각: 유튜브는 영상이 전혀 끊김 없이 틀어진다. 영상 데이터를 처음부터 모두 HTTP로 받아오면 너무 로딩이 오래 걸릴것이다. 스트리밍이라는 데이터를 끊어서 받는 방법에 대해 들어본적이 있다. 영상 데이터를 짧게 끊어서, 현재 필요한 부분만을 가져오고 그 부분을 재생하는 동안 다음 부분을 로딩하고 있는 방법을 사용하지 않을까?

Q. 영상 데이터를 HTTP로 어떻게 보내지?
생각: 영상의 raw한 데이터를 body에 담아서 보내나? 용량이 엄청 클 것 같은데..  영상을 송출하고 수신하는 여러 프로토콜이 이미 정의되어 있을 것 같다. 찾아보니 종류가 엄청 많다. 기본적인 아이디어는 잘게 쪼갠 다수의 데이터를 http을 통해 전송하는 방식인 것 같다.

---

방문 횟수 기록: 5번 새로고침 후에도 서버가 방문 횟수를 세었나요? 아니오.
쿠키 값 조작: visit_count를 1에서 5로 바꿨을 때, 서버가 "증가"를 감지했나요? 아니면 그냥 5를 표시했나요? 그냥 5를 표시했습니다.
보안 관찰: 쿠키 값을 Console에서 자유롭게 바꿀 수 있었나요? 이것의 위험성은 무엇일까요? 바꿀 수 있습니다. 서버가 클라이언트의 쿠키 값을 변조할 수 있기 때문에 위험합니다.

Q. 만약 쿠키에 'admin=true'를 넣으면 관리자가 될 수 있을까?
생각: 서버의 코드에 따라 관리자가 될 수 있을 것 같다. 하지만 서버는 항상 쿠키가 변조 가능하다는 사실을 인지해야 한다. 단순한 값이 아닌 보안 조치가 들어간 값으로 인증/인가 해야한다.

Q. 왜 서버는 사용자를 기억하지 않도록 설계되었을까
생각: 인터넷은 정말 급속도로 발전했다. 사실 처음 HTTP가 개발되었을 때, 무상태성을 가지는 것에 대한 장점과 단점이 심도깊게 고민되고 나왔는지는 의문이 든다. 단순히 당시의 기술적 제약(저장 공간, 네트워크 리소스 부족)을 떠올리면, "필요 이상으로 무겁게 만들지 말자" 라는 의사결정이 자연스럽게 표준으로 굳어진 거라고 생각된다. 지금 와서는 HTTP가 무상태성을 가지는 것 덕분에 프로토콜이 단순해지고, 서버가 수백만 명의 사용자를 기억하지 않아도 되도록 했다. 하지만 결국 기억을 해야하는 상황에서는 쿠키나 세션같은 외부 도구에 의존해야 하는 상황이 펼쳐졌다. 사실 HTTP가 상태를 가질 수도 있도록 설계되었더라도, 우리가 현재 세션 같은 서버 메모리를 사용하는 기술을 선택적으로 사용하는 것처럼, HTTP가 상태를 가지는 걸 필요한 상황에서만 사용할 것이기 때문에 큰 문제가 없지 않을까? 따라서 내 생각은 HTTP가 무상태성으로 설계된 건, 이미 무상태성 HTTP로도 그때의 인터넷 수요를 충족했기 때문이며 그것이 표준화되고 상태를 가질 수 있는 다양한 기술을 붙여서 쓸 수 있게 되어서 그냥 이대로 사용하는 것 같다. 물론 현재는 서버에 상태성을 부여할 수 있는 다양한 기술들이 있기 때문에, HTTP는 무상태성인게 낫다고 생각한다.

Q. 실제 로그인은 이렇게 위험한 쿠키를 어떻게 안전하게 만들까?
생각: cookie의 http-only 설정과 secure 설정을 통해 부가적인 보안 조치를 할 수 있는 것으로 안다. 또 인증/인가에 관련된 민감한 정보의 경우 암호화 기술(예: 토큰) 등을 사용해서 조작이 불가능하도록 처리할 수 있다


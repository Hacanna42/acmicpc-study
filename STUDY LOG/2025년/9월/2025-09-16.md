#### TO DO
- [ ] 구구의 Tomcat 구현 미션 (현재 4/4단계)
	- [x] Http Request 리팩터링 ✅ 2025-09-13
	- [x] Http Response 리팩터링 ✅ 2025-09-14
	- [x] Controller 인터페이스 추가 ✅ 2025-09-14
	- [ ] Thread pool 구현
- [ ] Reflection API 학습 테스트 진행
- [ ] Servlet과 Servlet Container 퀘스트 진행
- [ ] @MVC 구현 미션 (현재 0/3단계)
- [ ] 취준


---


### 구구의 IoC / DI 퀘스트
- 1단계의 Main 클래스와 5단계의 Main 클래스에서 각각 어떤 책임을 담당하고 있나요
	- 1단계의 Main 클래스는 키보드 입력, 환율 정보 가져오기, 환율 정보 출력등의 다양한 책임을 담당하고 있습니다. 5단계에서는 세부사항을 알지 못하고 단순히 객체 생성 및 관계를 설정하는 역할만 하고있습니다.
- 만약 환율을 파일에서 읽어오는 새로운 Provider가 필요하다면, 1단계 방식과 5단계 방식에서 각각 몇 개의 클래스를 수정해야 할까요?
	- 5단계의 경우 파일에서 읽어오는 새로운 Provider 구현체를 만들고, Main 클래스에서 조립 클래스를 변경해야 하기 때문에 2개의 클래스가 수정됩니다. 
- 5단계의 Main 클래스를 보면서, 누가 어떤 구체적인 구현체를 사용할지 결정하고 있나요? 만약 시스템에 10개의 서로 다른 Provider와 Renderer가 있다면 Main 클래스는 어떻게 될까요?
	- Main 클래스에서 구체적으로 구현체를 지정하고 있습니다. 만약 시스템에 수십개의 구현체가 있다면 Main 클래스는 매번 특정 기준에 따라 구현체를 선택해야 하기 때문에 조건 분기가 많아지고 관리가 어려워집니다.

- "만약 환율을 웹 API에서 가져온다면 어떤 클래스만 새로 만들면 될까?"
	- WebApiExchangeProvider 클래스만 만들면 된다.
- "왜 Main 클래스가 모든 객체 생성과 연결을 담당하는게 문제가 될까?"
	- Main 클래스가 모든 객체 생성과 연결을 담당하면, 구현에 변경이 생길때마다 Main 클래스가 같이 바뀐다는 문제가 발생합니다. 또 Main 클래스가 점점 비대해지며, 특정 구현체를 통해 테스트 할 시 직접 Main 클래스를 수정하면서 테스트 해야합니다.
- "객체들을 자동으로 생성하고 연결해주는 무언가가 있다면 어떨까?"
	- 만약 외부 도구가 객체들을 자동으로 생성하고 연결해준다면, 객체들간의 관계만 봤을 때 서로간 어떤 구현체도 명시하지 않으므로 코드에 구체적인 구현이 표현되지 않고, 추상화에 의존하게 되어 변경 유연한 설계를 작성할 수 있습니다.



--- 


### 구구의 Servlet 퀘스트
- 서블릿과 일반 자바 클래스의 차이:
	- 일반 자바 클래스: JVM 위에서 직접 실행합니다. main 메서드를 호출해야 동작합니다.
    - 서블릿 클래스: Servlet Container가 관리합니다. service() 메서드를 자동으로 호출해 요청/응답 흐름을 처리합니다.

- service 메서드 역할 관찰
    - 브라우저 GET 요청 → service() 실행 후 doGet() 호출.
    - curl POST 요청 → service() 실행 후 doPost() 호출.
	- 역할: service() 메서드는 HTTP 요청 메서드를 구분(GET, POST 등) 해서 적절한 doXXX 메서드로 분배합니다.

- 동적 웹페이지 생성 관찰
	- LocalDateTime.now() 가 계속 업데이트 되는 것으로 보아, 동적 웹페이지 생성으로 보임.
    

---

## **나만의 탐구 질문 만들기 🔍**

  

질문 1: 서블릿 컨테이너는 요청마다 매번 새로운 서블릿 인스턴스를 생성할까, 아니면 같은 인스턴스를 재사용할까?

질문 2: 서블릿에서 멀티스레드 요청이 동시에 들어오면, 같은 service() 메서드가 동시에 실행될 수 있을까?

---

1단계에서 팩터리를 도입한 후 Main 클래스의 코드가 단순해졌습니다. 객체 생성과 연결을 직접 하지 않고 팩터리에서 제공하는 인스턴스를 받아 사용하게 되어, Main은 실행 시작만 담당하게 되었습니다. 

2단계에서 Properties 파일만 수정했는데 프로그램 동작이 달라졌습니다. 설정 파일을 읽어 리플렉션으로 객체를 생성했기 때문에 실행 시점에 다른 구현체를 주입할 수 있었습니다.

3단계에서 새로운 Provider를 추가하더라도 Main 클래스는 자신이 어떤 구체적인 구현체를 사용하는지 알지 못합니다. 

질문 1: Factory에서 리플렉션을 통해 객체를 생성할 때 성능 오버헤드는 어느 정도일까
- 리플렉션은 JVM에 이미 로딩된 메타데이터를 꺼내 쓰는 기술입니다. 이런 리플렉션을 통해 클래스 메타데이터 탐색같은 동적 해석을 거쳐 객체를 생성하게 되면 단순 객체 생성보다 평소보다 몇배의 오버헤드가 생깁니다. 단, 사람이 체감하기에는 거의 불가능한 수준의 속도이며, 객체 생성은 보통 프로그램 초기 단계에서 한다는 점에서 무시할만 합니다.
질문 2: Properties 파일이 잘못된 클래스명을 가리킬 때 프로그램은 어떤 예외를 던지고 어떻게 복구할 수 있을까


---

퀘스트 1에서는 Main 클래스가 직접 어떤 구현체를 사용할지 결정했습니다. Factory나 컨테이너가 없었기 때문에 제어권이 모두 Main에 있었습니다.

퀘스트 2에서는 Factory가 Properties 설정을 읽어 어떤 구현체를 사용할지 결정했습니다. 제어권이 Main에서 팩터리로 이동했고, Main은 단순히 Factory에 요청만 하면 됐습니다.

퀘스트 3에서는 Spring 컨테이너가 XML 설정에 따라 객체 생성과 연결을 모두 관리했습니다.

이 과정을 통해 유연성이 커졌습니다. 설정만 바꿔도 다른 구현체를 사용할 수 있었고, 확장성도 개선되어 새로운 구현체를 추가할 때 기존 코드를 건드릴 필요가 없었습니다. 또한 테스트 시 가짜 구현체를 손쉽게 연결할 수 있어 테스트 용이성이 높아졌습니다.

IoC는 제어의 역전이라는 넓은 개념이고, DI는 그 안에서 의존성을 해결하는 구체적인 방법입니다. 즉, IoC가 상위 개념이고 DI는 그 하위에 속하는 구체적 구현 방식입니다.

---

❓ 나만의 탐구 질문 만들기

  

질문 1: DI 방식 중 생성자 주입, 세터 주입, 필드 주입은 각각 어떤 장단점을 가지는가

질문 2: Spring 컨테이너 없이 순수 자바 코드로 DI를 구현한다면 어떤 구조가 가능할까

  

👉 가장 궁금한 질문: 질문 1

직접 같은 코드를 세 가지 주입 방식으로 바꿔보면서, 테스트 용이성과 코드 가독성 측면에서 차이를 비교해볼 수 있다
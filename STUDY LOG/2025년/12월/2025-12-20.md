- DB에서 동시성 제어 할 때, unique 조건을 통한 낙관적 락킹이 유리할까? 배타 락을 통한 비관적 락킹이 유리할까?
  
```
데이터베이스 동시성 제어: Unique 제약 vs 배타 락
간단한 답: 상황에 따라 다릅니다. 일반적으로 Unique 제약을 활용한 접근이 더 효율적이지만, 충돌 빈도와 비즈니스 로직에 따라 배타 락이 더 나을 수 있습니다.
기본 개념의 차이
**배타 락(Exclusive Lock, SELECT FOR UPDATE)**은 트랜잭션이 행을 읽는 시점에 즉시 락을 획득하여 다른 트랜잭션의 접근을 원천적으로 차단하는 비관적 락킹(Pessimistic Locking) 방식입니다. 반면 Unique 제약은 INSERT 시점에 중복 여부를 검증하는 낙관적 락킹(Optimistic Locking) 방식으로, 충돌이 발생했을 때만 예외를 처리합니다.
성능 측면: Unique 제약이 유리한 이유
Unique 제약을 통한 동시성 해결이 더 효율적인 주된 이유:
	1.	높은 동시성: 배타 락은 선택한 행을 완전히 잠그므로 다른 트랜잭션들이 대기해야 합니다. 반면 Unique 제약은 중복이 없다면 동시에 여러 INSERT가 진행될 수 있습니다.
	2.	락 오버헤드 감소: 배타 락은 매번 명시적으로 행을 잠금으로써 락 관리자(Lock Manager) 오버헤드가 발생합니다. Unique 제약은 인덱스 검색만으로 중복 여부를 판단하므로 상대적으로 간단합니다.
	3.	적응적 성능: 충돌이 드물다면 Unique 제약이 거의 모든 연산을 즉시 처리할 수 있습니다. 예를 들어 10,000개 행 삽입 시 `SELECT + INSERT IGNORE` 방식이 21초인 반면, 배타 락 기반 접근은 더 느릴 수 있습니다.
배타 락이 더 나은 경우
충돌이 빈번한 상황에서는 배타 락이 우수합니다:
	1.	높은 충돌 환경: 같은 데이터를 동시에 수정하려는 시도가 자주 발생하면, 배타 락으로 사전에 차단하는 것이 롤백(Rollback) 비용을 절감합니다. 반복되는 롤백은 이전 작업을 모두 되돌려야 하므로 매우 비싼 작업입니다.
	2.	복잡한 트랜잭션: 여러 행에 걸친 복잡한 업데이트 로직이 있다면, 배타 락으로 미리 보호하는 것이 안전합니다.
	3.	외래 키 제약: 외래 키가 참조하는 열을 수정할 때는 `SELECT FOR UPDATE`를 사용해야 합니다.
실무적 권장사항
Unique 제약 기반 접근 시 전략:
	•	UPSERT 패턴 활용: PostgreSQL의 `ON CONFLICT DO UPDATE`나 MySQL의 `INSERT ... ON DUPLICATE KEY UPDATE`를 사용하여 중복 발생 시 자동으로 업데이트합니다.
	•	재시도 로직: 예외 발생 시 지수 백오프를 적용하여 재시도합니다.
	•	배치 처리: 여러 요청을 모아서 한 번에 처리하여 중복 가능성을 줄입니다.
배타 락 사용 시 주의사항:
	•	`SELECT FOR UPDATE` 대신 필요한 경우만 사용하세요. 일반적인 UPDATE는 `SELECT FOR NO KEY UPDATE`가 더 효율적입니다.
	•	락 보유 시간을 최소화하고, 데드락 가능성을 모니터링하세요.
	•	단일 스레드 병목 현상을 주의하세요. 한 사용자의 느린 트랜잭션이 모든 다른 작업을 중단시킬 수 있습니다.
결론
일반적으로 Unique 제약이 더 효율적인 이유는 대부분의 실무 환경에서 중복 충돌이 드물기 때문입니다. 그러나 특정 금융 거래, 재고 관리 같은 높은 충돌 환경에서는 배타 락의 예측 가능한 성능이 장점이 됩니다. 따라서 귀하의 애플리케이션의 동시성 충돌 패턴을 분석한 후 선택해야 합니다.
```
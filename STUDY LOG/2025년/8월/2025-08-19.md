- JPA의 PrePersist, PreUpdate 이외에도 Bean Validation을 적용 중
- 백엔드 팀원들에게 새로운 검증 컨벤션을 제안하고, 승낙됨
```
히스타  [Today at 2:26 PM](https://for-gather.slack.com/archives/C095G4Z68TY/p1755581163077089)  

**< 프로젝트 검증 컨벤션 변경 논의 >****[안건]**  
현재 프로젝트 검증 컨벤션을 아래와 같이 바꾸자.  
1. JPA @PrePersist, @PreUpdate는 최소한의 null, blank 검증만 한다. (예: `name은 null이 아니다.`, `name은 빈 값이 아니다` 등)  
2. 도메인(엔티티) 클래스에서의 검증은 특유의 비즈니스 규칙만 다룬다. (예: `openedAt은 과거가 될 수 없다`, `이미 만료된 스페이스의 openedAt을 변경할 수 없다` 등)  
3. 클라이언트의 입력값 검증은 DTO에서 Bean Validation을 이용한다. (예: `스페이스 이름은 1~10자`, `스페이스 지속 기간(validHours)는 양수` 등)**[변경하고 싶은 이유]**  
- 기존에는 JPA의 @PrePersist/Update로 모든 검증을 처리했다.  
- 이는 JPA 의존적이며, 우리의 검증 로직이 항상 JPA 사이클을 따라야 한다는 문제가 있다.  
- JPA의 사이클을 따르게 됨으로써 생기는 문제가 있다. 현재 JPA 검증 시점은 두가지다: 1. DB 영속화 시점 2. DB 업데이트 시점  
    - 문제점:  
1. 현재 `Space` 에서 `openedAt`가 미래여야 한다는 검증이 `@PreUpdate`에 걸려 있는데, 따라서 `Space`의 이름만 업데이트 해도 `openedAt` 검증 에러가 터지게 된다.  
2. 따라서, `openedAt` 검증은 영속화 시점인 `@PrePersist` 에만 붙여야 된다.  
3. 하지만 이럴 경우, `Space`의 `openedAt`을 과거로 업데이트 할 경우 검증이 터지지 않게 된다 (`@PrePersist`에만 검증 로직이 있기 때문에) 따라서 이를 막기 위해, `DTO`나 `Space`의 `setter`에 `openedAt`의 검증 로직을 넣어야 한다.  
4. 이렇게 JPA의 사이클에 맞출 수 없는 검증 로직이 생겨나면서, 특정 검증은 JPA에, 특정 검증은 DTO에, 특정 검증은 Setter에 있게 되었다. 코드를 작성하면서 관리 포인트가 너무 많아지고, 일관성이 없어짐을 관찰했다.  
5. 이에 대해 GPT와 논의한 결과, 각 검증에 명확한 기준을 설정하고 JPA의 `@PrePersist/Update`는 DB에 빈 값이 저장되지 않게 하는 최후의 보루로 쓰는 것이 마땅하다고 결론나게 되었다. **결론: 입력 검증은 DTO에서 Bean Validation으로, 비즈니스 규칙 검증은 도메인에서, DB 빈 값 검증은 JPA @PrePersist, @PreUpdate로 하자.**
```


- 스페이스 정보 수정 API 완료 
- 스페이스 삭제 API 완료
- 에러 로그 슬랙 알림 Lambda 업데이트 (최근 1분 로그만을 가져오도록)
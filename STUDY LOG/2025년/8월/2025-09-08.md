## Tasks
- 구구의 퀘스트 마무리
- 모루 PR 리뷰
- 개인미션 1단계 리뷰 반영 및 Approve 받기
- 개인미션 2단계 진행


### 구구 퀘스트 - 실전 캐싱 전략 설계하기
**무엇을 관찰했나요?**
- HTML에 no-cache를 사용하는 이유: 서버와의 최신성을 항상 보장하기 위해서.
- 정적 리소스에 immutable을 추가하는 효과: 브라우저에서 캐시가 만료되지 않았으면 조건부 검증을 보내지 말고 그냥 로컬에서 사용하도록 함으로써, 불필요한 네트워크 리소스 낭비를 막는다.
- 파일명 버전과 쿼리 파라미터 버전의 차이: 대부분 파일 경로를 캐시의 키로 활용하기 때문에, 버전이 바뀌었을 때 파일명이 바뀔 경우 경로도 바뀌게 되어 전 구간에서 캐시가 확실히 분리되게 된다. 쿼리 파라미터는 CDN/프록시 설정에 따라 반영 여부가 다르기 때문에 권장되지 않는다. 동일 파일로 간주될 여지가 있다.
- private과 public 선택 기준: CDN에서 캐싱하면 안되는, 사용자 개인마다 달라야 하는 데이터는 private으로 지정한다.

작성 공간:
- 질문 1: 만약 CDN 업체를 바꾼다면 캐싱 전략도 바꿔야 할까?
	- 대부분의 상황에서는 CDN 업체가 변경되었다고 해서 캐싱 전략을 바꿀 필요는 없을 것 같다. CDN측의 설정만 올바르게 재검토하면 될 것 같다.
- 질문 2: 왜 구글은 로고를 1년 동안 캐시하도록 설정했을까?
	- 로고는 매우 긴 시간동안 변경되지 않는다. 하지만 로고는 사이트의 대부분 화면에 항상 등장한다. 따라서 캐싱을 통해 네트워크 비용을 아끼는 것이 효과적이다.
- 질문 3: 서버에서 Cache-Control 응답이 안 오면 어떻게 될까?
	- 서버가 Cache-Control 헤더를 아예 안 보내면, 브라우저나 중간 캐시는 기본 규칙(fallback)에 따라 동작한다. HTTP/1.1 규격에서는 대신 Expires 헤더를 참고한다. Expires도 없다면 휴리스틱 캐싱을 적용한다. 휴리스틱 캐싱은 어림짐작해서 캐싱을 한다는 뜻이다. Last-Modified 값이 있으면 → 수정 시각의 10%를 캐시 만료 시간으로 추정 (RFC 7234 규정)한다.

---

### 구구 퀘스트 - Cookie에서 Session으로


**무엇을 관찰했나요?**

브라우저 개발자도구에서 관찰한 내용을 구체적으로 기록해보세요:

- Set-Cookie 헤더와 Cookie 헤더가 각각 어디에 있었고, 브라우저가 쿠키를 자동으로 전송하는 것을 확인했나요?: 네. Set-Cookie 헤더는 서버의 302 응답에 있었습니다. Cookie 헤더는 이후 리다이렉트된 클라이언트의 요청에 있었습니다.
- 4KB를 초과하는 데이터를 쿠키에 저장하려 했을 때 실제로 어떤 일이 발생했나요?: 콘솔창에서 오류는 발생하지 않았지만, 쿠키가 저장되지 않는 문제가 발생했습니다.
- document.cookie로 값을 조작했을 때 서버가 조작된 값을 그대로 받아들였나요? 이것이 왜 위험한가요?: 네. 그대로 받아들였습니다. 클라이언트에서 임의적으로 쿠키를 조작할 수 있기 때문에, 서버가 이를 신뢰할 경우 매우 위험합니다.
- Session ID를 복사해서 다른 브라우저에 붙여넣었을 때 실제로 세션이 공유되었나요?: 네. 세션 ID 값이 바뀌었습니다.

### ❓ 나만의 탐구 질문 만들기

작성 공간:

- 질문 1: 만약 브라우저를 시크릿 모드로 열면 쿠키는 어떻게 될까?
	- 브라우저를 시크릿 모드로 열면, 쿠키도 아예 격리된 환경에서 생성된다.
- 질문 2: 왜 쿠키 크기가 정확히 4KB로 제한되었을까?
	- 쿠키는 처음 도입되었을 때 헤더 기반 상태 저장 수단으로 사용되었다. 쿠키는 매 요청마다 Cookie 헤더로 자동 전송되기 때문에, 쿠키의 크기가 클 경우 네트워크 오버헤드가 늘어나기 때문에 4KB 정도로 제한되었다. **RFC 6265** 에 정의된 쿠키 관련 명세를 확인해보면, 브라우저가 최소 4KB는 지원하도록 명시되어 있다. 
- 질문 3: Session ID를 예측 가능한 패턴으로 만들면 어떤 문제가 생길까?
	-  세션 ID를 예측 가능한 형태로 만들면 (예를 들어서 시간이 들어가 있다거나, 1씩 증가하는 ID로 발급된다거나) 세션 하이재킹 위험이 크게 높아진다. 악의적인 클라이언트가 좁은 범위에서 브루트 포스 공격을 통해 다른 유저의 세션을 탈취할 수 있다.
- 질문 4: Session ID를 유저가 임의적으로 브루트포스 해볼 수 있다면, 결국에 보안 탈취 위협은 생기지 않을까?
	- 맞다. 브루트포스 위협은 여전히 존재하기 때문에 Session ID를 적절한 난수로 지정하는 것이 중요하다. 주로 사용되는 난수 생성 방식은 CSPRNG(Cryptographically Secure Pseudo Random Number Generator) 로, 랜덤 시드로 MAC 주소나 시간 값(예측 가능함)을 사용하지 않고 커널 난수 풀에 모인 엔트로피 소스를 활용한다. 엔트로피 소스란 예측 불가능하고 비결정적인 이벤트를 모은 무작위 소스를 말한다. 예를 들면 키보드 입력 간격, 마우스 움직임, 디스크 I/O 완료 시점. 네트워크 패킷 도착 시간, CPU 클럭 드리프트, 전압 변동 등이 있다. 이런 정보는 사람이 예측하기 매우 힘드므로 랜덤 시드의 재료로 쓰인다. 또, 세션 ID는 최소 128비트의 엔트로피를 가져야 한다고 권장한다(https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)
	- 128비트 난수 세션 ID를 한 번에 맞출 확률은 1 / 2^128 ≈ 2.9 × 10^-39**로 사실상 불가능에 가깝다.
	- 초당 **10^9회(10억)** 시도 가능하다고 가정해도: 걸리는 시간 ≈ 1.7 × 10^29초 ≈ **5.4 × 10^21년** 이므로 초당 **10^12회(1조)** 시도해도 ≈ **5.4 × 10^18년**. 즉, 우주의 나이(≈ **1.38 × 10^10년**)와 비교하면 **압도적으로 크다.** 


---


### 구구 퀘스트 - Scale-out 환경의 세션 문제와 해결
##### 상황 시나리오
온라인 쇼핑몰이 인기를 끌면서 서버 1대로는 부족해져서 서버 3대로 확장했습니다. 로드밸런서가 Round-robin 방식으로 요청을 분배합니다.

```
어떤 문제가 발생했나요?: 로드 밸런서를 통해 로그인을 했던 서버로 다시 돌아오기 전까지, 세션 정보를 잃어버림. 로그인이 되지 않음. 
왜 이런 문제가 생겼을까요?: 세션은 각 서버에 저장되어 있는데, 로드밸런서는 세션이 저장되어 있지 않은 다른 서버로 클라이언트를 보내기 때문에.
```


##### 해결방안 조사하기
- Sticky Session
```
한줄 소개: 로드 밸런서를 사용하는 웹 서버 환경에서 클라이언트의 요청이 항상 같은 서버로 전달되도록 하는 방식
장점: 쉽게 사용자의 상태를 일관되게 유지할 수 있음.
단점: 특정 서버에 트래픽이 집중될 수 있음. 세션을 저장하던 서버에 장애가 나면 세션 데이터가 유실될 수 있음. 서버 확장/축소(Auto Scaling) 환경에서 유연성이 떨어진다.
```

- Session Clustering
```
한줄 소개: 여러 대의 서버(WAS 등)가 세션 정보를 공유하여, 어떤 서버에 접속하더라도 동일한 세션 상태를 유지할 수 있도록 하는 기술
장점: 고가용성(서버 장애시에도 다른 서버가 세션을 이어받아 서비스가 중단되지 않음), 확장이 쉬움. Sticky Session에 비해 트래픽이 몰릴 위험 없음.
단점: 여러 서버간의 데이터 동기화 오버헤드
```

- Redis 세션 저장소
```
한줄 소개: 외부 Redis 인메모리 DB에 세션을 저장함. 모든 WAS에서는 해당 DB를 참조함.
장점: 고가용성, 메모리 기반 저장소라 속도가 빠름.
단점: Redis 서버 자체 장애 시 모든 세션 정보가 유실될 수 있음. (단일 장애점) 인메모리 특성상 DB보다는 신뢰도가 떨어지고 데이터 유실 위험이 있음. 대규모 사용자 트래픽이 있을 경우 메모리 부족 현상 발생 가능. 모든 WAS가 Redis 서버에 접근하므로 Redis 서버에 트래픽이 많이 몰림.
```


##### 상황별 선택하기
- 상황 1: 스타트업 초기 (서버 2-3대)
```
선택: Sticky Session
한 줄 이유: 스타트업이면 빠르게 서비스 가치를 증명하는 게 중요함. 즉 구현이 간단하면서 문제를 해결할 수 있는 Sticky Session 선택.
```

- 상황 2: 성장한 서비스 (서버 10대)
```
선택: Redis 
한 줄 이유: Sticky Session의 단점이 부각되면 (LB를 자유롭게 조정 불가능함으로써 생기는 트래픽 집중 등) Redis로 전환. Session Clustering는 서버마다 세션을 동기화하는 과정의 오버헤드가 꽤 있고, 각 서버가 각각의 세션 저장소를 갖고 있는 게 효율적이지 않기에 고려하지 않음. Redis를 통해 복잡한 동기화 오버헤드 없이 고가용성을 챙김.
```

- 상황3: 대규모 서비스 (서버 100대+)
```
선택: Redis + Master-Slave(Replica) 구성
한 줄 이유: Redis가 가진 단일 장애점을 극복하기 위해서 Master-Replica 구성을 추가한다. Redis를 여러개의 인스턴스로 구성하고 읽기 전용에 복제하면 장애 대응과 읽기 성능을 향상시킬 수 있다. 복제 오버헤드 때문에 더 많은 비용이 필요하겠지만 전체적인 유저 경험과 서비스의 가용성을 향상시킬 수 있다.
```

결국엔 CAP 정리처럼 _**일관성(consistency)**, **가용성(availability)**, **파티션 허용(partition tolerance)**_ 을 모두 완벽하게 제공하는 아키텍처는 없는 것 같다.



---


### 구구 퀘스트 - JWT
**무엇을 관찰했나요?**
- Payload에 role을 ROLE_ADMIN으로 바꿨을 때 Invalid Signature가 뜬 이유는 무엇인가요?: payload의 값을 통해 서명을 생성하기 때문에, payload의 값을 변경할 경우 서명이 Invalid 해진다.
- 장바구니 데이터를 추가했을 때 토큰이 몇 바이트까지 커졌고, Session ID(32바이트)와 비교하면 몇 배인가요?: 토큰이 692바이트까지 커졌습니다.


**관찰한 현상에 대해 궁금한 점을 질문으로 만들어보세요**
- 질문 1: 만약 Secret 키가 해커에게 유출되면 어떤 일이 벌어질까?
	- JWT Secret키가 유출되면, payload 값을 바꾸고도 올바르게 서명 받을 수 있다. 즉 심각한 보안 위협이 생긴다.
- 질문 2: 왜 JWT를 Cookie가 아닌 Authorization 헤더에 넣을까?
	- 쿠키는 Stateless한 HTTP에서 상태를 추가하는데 주로 사용된다. JWT는 별도의 상태를 유지하지 않아도 되므로, 쿠키에 넣는 것은 자연스럽지 않다. 또한 쿠키의 경우 브라우저에서 매 요청 시 자동으로 붙여주고, Authorization 헤더는 클라이언트에서 명시적으로 담아야 하므로, CXRF 공격을 방지할 수 있고 CORS 제약에서 자유롭다.
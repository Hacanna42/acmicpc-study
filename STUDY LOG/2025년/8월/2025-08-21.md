- 런칭 페스티벌 하루 전
- 4차 요구사항 구현을 시작했다.
	- 무중단 배포
	- 배포 환경에 실수로 접근할 수 없도록 환경 완전히 분리 및 보안 조치
	- Soft Delete 구현
	- 배포 오류 시 바로 롤백되도록



# 푹신한 삭제(Soft Delete) 및 DROP 방지

## LMS 요구사항

- 데이터를 지워야 해도 DROP하지 않는다. (Soft Delete)
- 테이블 구조를 바꿔야 해도 DROP하지 않는다.
- 실수 방지 시스템을 만든다(권한 제거 등)
- 왜? 고객 데이터 = 회사의 생명입니다
- 실수로 DROP 명령어를 써도 막을 수 있어야한다.

위 요구사항을 정리하면 고려해야 할 것은 크게 3가지이다.

### 고려해야 하는 것

1. Soft Delete 시스템
2. DROP 제한 시스템
3. 테이블 구조 마이그레이션 시스템 (모코가 작업 중?)

그러면 하나씩 고려해보자.

# Soft Delete

### Soft Delete가 필요한 이유

1. ~~실수를 방지할 수 있다.~~
2. 삭제된 데이터를 쉽게 복구 가능하다.
3. 빅데이터를 쌓을 수 있다. (데이터는 자산이다)

### Soft Delete의 단점

1. 조회마다 필터링이 필요하기에 로직이 복잡해진다.
2. DB에 데이터가 쌓이기 때문에 조회 성능이 하락한다.

### 결론

- `DROP 명령어` 를 통한 데이터 임의 삭제는 실수가 많이 생길 수 있다. 따라서 DROP 사용을 막기 위해 논리적 삭제인 soft delete를 도입한다.
- 휴지통 기능 구현같은 기능적인 부분을 위해 도입하는 것은 절대 아니다.

### 구현 방법들

1. 테이블에 `is_deleted` 같은 플래그를 추가해서, 조회시마다 필터링한다. **(플래그 방법)**
2. Soft Delete를 위한 테이블을 하나 만든다. 특정 테이블에서 삭제된 데이터는 1:1 매핑된 삭제용 테이블로 이동된다. **(테이블 분리 방법)**

### 플래그 방법의 장/단점

- 장점
    - 구현이 단순하고 직관적이다.
- 단점
    - 조회시마다 필터링이 필요해서, 약간 복잡하다.
    - 조회용 테이블에 삭제된 데이터도 쌓이므로 조회 비용이 증가한다.

### 테이블 분리 방법의 장/단점

- 장점
    - 조회용 테이블에는 삭제되지 않은 데이터만 있기에 조회 비용에 악영향이 없다.
- 단점
    - 매 삭제마다 테이블의 데이터를 DROP하고, 그 정보를 그대로 삭제용 테이블에 옮기는 작업이 복잡하다.
    - 전체 테이블에 대한 삭제용 테이블이 1:1로 생긴다. 즉 현재 테이블이 총 7개이니까, 삭제용 테이블도 7개 생긴다.
    - API를 통한 삭제가 아니라, DB에서 직접 쿼리를 날릴 때 결국엔 DROP을 사용해야 한다.

### 구현 방법 결론

- 테이블 분리 방법은 조회 성능에 유리하지만, 고려해야 할 것이 너무 많다. (댓글 참고)
- **플래그 방법으로 구현**하고, 조회 성능에 관한 개선이 필요할 때 테이블 분리 방법을 고려해본다.
- 
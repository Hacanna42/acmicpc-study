- 구구의 JVM, 스레드 강의
- 구구의 퀘스트 3개

무엇을 관찰했나요? 이 퀘스트의 핵심 관찰 사항을 구체적으로 기록해보세요:
- **Thread 생성 방식에 대한 관찰:** Thread 클래스 상속과 Runnable 인터페이스 구현 방식에서 어떤 코드 구조의 차이점을 발견했나요? 두 방식 모두 동일한 결과를 만들어냈지만, 어떤 차이점이 있었는지 구체적으로 적어보세요. Thread 클래스 상속 방식은 Thread를 extends해서 구현했고, Runnable 인터페이스 구현 방식은 Runnable을 implements하고 그것을 다시 Thread로 객체로 생성했습니다.
- **동시성 문제에 대한 관찰:** synchronized 키워드를 추가하기 전의 sum 값이 정확히 얼마였나요? 1000개의 작업을 실행했는데 왜 그보다 작은 결과가 나왔을까요?: 972
- **스레드 풀 동작에 대한 관찰:** FixedThreadPool의 poolSize와 queueSize는 각각 몇이었나요? CachedThreadPool의 값들은 어떻게 달랐나요? 이 숫자들의 차이가 실제 애플리케이션에서 어떤 의미를 가질까요?: FixedThreadPool의 poolSize는 2, queueSize는 1 이었습니다. CachedThreadPool의 경우 PoolSize 3, queueSize 0 이었습니다. 


관찰한 현상에 대해 궁금한 점을 질문으로 만들어보세요
- 질문 1: `newFixedThreadPool` 과 `newCachedThreadPool`의 차이
	- 답변: newFixedThreadPool은 스레드 개수가 2개로 고정되어 있다. 따라서 3개의 작업을 시작하면 poolSize = 2, queeSize = 1이 된다. (실행 작업 2개, 대기 작업 1개이기 때문) newCachedThreadPool은 필요할때마다 스레드를 새로 만들고, 쓰지 않는 스레드는 일정 시간 이후 제거하는 스레드 풀이다. 따라서 요청이 갑자기 몰릴 때 빠르게 스레드를 늘려서 처리할 수 있고, 자원 낭비를 막을 수 있다. 다만 제한이 없으므로 부하가 지속될 경우 주의해야 한다.
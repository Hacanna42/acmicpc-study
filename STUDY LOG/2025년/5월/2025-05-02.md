- [x] 오브젝트 8장 읽기
- [ ] 네트워크 테코톡 준비: IP에 대한 학습
- [ ] PR 리뷰 답장






---

# 오브젝트 정리 CHAPTER 08 - 의존성 관리하기

# 의존성이란?

- **한 객체가 정상적으로 동작하기 위해 다른 객체를 필요로 하는 관계**.
- 잘 설계된 애플리케이션은 작은 객체들이 협력하여 기능을 완성함.

### 왜 의존성을 관리해야 하는가?

- 객체는 혼자 일하지 않는다.
- 그러나 **과도한 의존성은 객체 간 결합을 강하게 만들고**, 이는 유지보수성과 재사용성을 해친다.

---

## 의존성의 종류와 구분

### 컴파일 타임 vs 런타임 의존성

|종류|설명|
|---|---|
|컴파일 타임 의존성|코드 상에서 특정 타입이나 클래스를 참조할 때 발생.|
|런타임 의존성|실제 실행 중에 협력 객체가 필요한 경우. 실행 환경에 따라 결정됨.|

### 직접 의존 vs 간접 의존 (전이 의존성)

- A → B → C 구조라면, A는 C에 **간접 의존**하게 된다.
- 전이 의존성이 많아질수록 의존 관계가 복잡해진다 → 구조 이해 및 변경 어려움 증가.

### 컨텍스트 독립성

- 클래스가 사용될 특정한 문맥에 대해 최소한의 가정으로만 이루어져 있다면 재사용 하기 수월해진다. 이를 **컨텍스트 독립성**이라고 부른다.

---

## 의존성 해결하기

### 1. 생성자 주입 (Constructor Injection)

- 생성 시 필요한 협력 객체를 명확히 전달받는다.
- 가장 명시적이고 안전한 방식.

### 2. 세터 주입 (Setter Injection)

- 객체 생성 후 설정을 통해 협력 객체를 주입.
- 유연하나, 객체 불완전 상태 가능성 존재.

### 3. 메서드 인자 주입

- 일시적인 협력만 필요할 때 사용.
- 지속적인 의존보다는 느슨한 협력을 지향할 때 유용.

---

## 좋은 의존성과 나쁜 의존성

### 바람직한 의존성의 기준

- 협력에 필요한 최소한의 정보만을 안다.
- **추상화에 의존**한다 (인터페이스나 추상 클래스).
- 다양한 컨텍스트에서도 재사용 가능하다.

### 나쁜 의존성의 특징

- 구체 클래스에 직접 의존.
- 실행 컨텍스트가 바뀌면 협력 불가능.
- 다른 할인 정책, 저장 방식 등 확장에 제약.

---

## 설계 유연성 - 주요 개념

### 결합도(Coupling)

|결합도|설명|
|---|---|
|강한 결합 (Tight Coupling)|구체적인 구현에 깊이 의존. 변경에 민감.|
|약한 결합 (Loose Coupling)|추상화에 의존. 유연하고 재사용 가능.|

- **결합도가 높을수록 재사용과 테스트가 어려움**.
- **결합도를 낮추기 위한 전략 = 추상화, 인터페이스, 의존 역전**.

---

### 지식의 결합도 (Knowledge Coupling)

- 한 객체가 협력 객체에 대해 **많이 알고 있을수록 결합도는 높아짐**.
- 필요한 메시지만 알고 있고 타입 정도만 알면 되는 구조가 바람직.

### 명시적인 의존성

- 의존 객체는 외부로부터 주입받는 것이 바람직.
- 클래스 내부에서 직접 생성하면 명시적이지만 유연성이 떨어짐.

---

## 표준 클래스에 대한 의존은 괜찮다

- `ArrayList`, `HashMap` 등 변경 가능성이 낮고 안정적인 클래스는 예외.
- 그러나 인터페이스인 `List`로 선언해두면 더 유연.

### 조합 가능한 행동

- 다양한 정책 객체들을 조합하여 새로운 행동을 생성할 수 있는 설계.
- 클래스는 **무엇(what)을 하는가**에 집중하고, 그 **구현(how)** 은 외부에서 주입.

---

## 결론: 객체지향 설계와 의존성

> 객체지향 설계의 핵심은 "객체들이 무엇을 하는지를 선언적으로 표현"하는 것이다.
> 
> **어떻게 하는지는 협력 관계와 의존성으로 대체**된다.

- 시스템은 메시지를 주고받는 **객체들의 협력 네트워크**.
- 시스템의 변경을 용이하게 만드는 핵심은 **의존성 구조를 잘 설계하는 것**.
- 객체의 조합만 바꿔도 시스템의 동작을 바꿀 수 있는 구조 → 진정한 객체지향 설계.
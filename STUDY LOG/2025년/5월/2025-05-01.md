# Prolog: Question
- HTTP 프로토콜이란 무엇이며, 어떤 특성을 가지고 있는가? 이번 미션 구현에 어떤 영향을 미쳤는지 구체적인 사례를 들어 설명.
> HTTP(Hyper Text Transfer Protocol)은 인터넷 하이퍼 텍스트 전송 규약으로, 데이터를 전송하는 하나의 규칙입니다. 헤더와 바디로 이루어져 있는데, 헤더는 key:value 타입의 값이며 주로 Version, Method, Location, Status Code등의 정보가 포함됩니다. body는 텍스트를 담을 수 있으며 json을 반환하는데 주로 쓰입니다. 이번 미션 구현에서, ResponseEntity라는 Spring의 HTTP 응답 추상화 도구를 사용해서 응답을 생성했습니다.

- 좋은 웹 API는 무엇이라고 생각하나요? API를 설계할 때 RESTful 원칙을 어떻게 적용했나요?
> 좋은 웹 API라는 기준은 딱히 정의되지 않았지만, 이해하기 쉽고 사용하기 쉽다면 좋은 API가 아닐까요? 이를 지키기 위한 규칙인 REST 아키텍처가 있습니다. URI는 자원의 위치만을 서술하고, 행동은 POST, GET등의 method로만 처리하는 아키텍처입니다. RESTful API를 프로젝트 전반에 걸쳐 적용했지만, 랭킹 별 조회 기능이라던가, 가능한 예약 시간 조회 API의 경우 자원의 위치만을 서술하는 REST 아키텍처를 지키지 못했습니다. 하지만 직접 조사해본 결과 다양한 유명 사이트에서도 특정 상황에서는 REST 아키텍처를 지키지 않으며, 특정 상황에서는 REST 원칙을 지키지 않는 것이 오히려 이해하기 쉽고, 사용하기 좋다고 생각했습니다. 예를 들면 가장 인기 테마 10개를 조회하는 API의 주소는 `themes/lists?order_type=desc&list_num=10` 입니다.

- 에러 처리를 설계할 때 어떤 기준을 고려했나요? 에러 응답에 포함해야 할 정보는 어떤 무엇이며, 이를 포함하는 이유는 무엇인가요?
> Java의 Exception class가 세부적이어야 최대한 유연하게 상황에 맞춰 catch할 수 있는데, 현재 프로젝트에서 사용할만한 Java의 기본 RuntimeException은 IllegalArgumentException과 IllegalStateException밖에 없어서 커스텀 Exception class를 정의했습니다.
   하지만, CustomException class가 클래스 명으로 너무 구체적인 정보를 포함하고 있으면 코드의 구조가 복잡해지고 Exception Handling에 너무 많은 중복 코드가 작성될 것이라고 생각했습니다.
   따라서, 적절한 추상화 수준으로 CustomException 클래스를 작성하고, 클라이언트에게 보내주는 세부 오류 사항은 message를 통해 전달하도록 했습니다.
# PR Description - 1~3단계 방탈출 사용자 예약


## 🚧 고민했던 사항들

### 1. 예외 처리의 적절한 추상화 수준

시간 생성이나 예약 과정에서 잘못된 값 입력, 이미 예약된 시간을 삭제하려 할 때 등의 다양한 예외가 발생했습니다. 처음에는 커스텀 예외 클래스를 매우 세분화하여 상세한 정보를 제공하고자 했지만, 코드 분기가 복잡해지고 중복 코드가 많아지는 단점이 있었습니다. 따라서 적절한 수준으로 예외를 추상화하여 중복을 최소화하면서도 충분히 의미 있는 정보를 전달할 수 있도록 설계를 개선했습니다.

### 2. 도메인 모델의 설계 방향

기능이 점점 추가될수록 도메인 객체의 복잡도가 급격히 증가했습니다. 특히 `Reservation` 객체 설계 시 DB의 외래키(`timeId`, `themeId`)를 직접 보관하는 방식과 Java 객체인 `Time`, `Theme` 객체를 직접 참조하는 방식 중 많은 고민이 있었습니다. 객체 간 관계의 명확성을 위해 후자를 선택했으나, 이로 인해 복잡도가 크게 증가하여 아직도 추가적인 고민과 개선 방안을 모색 중입니다.

### 3. Repository와 Service 계층의 역할 분리

Repository는 순수하게 데이터 접근만을, Service는 비즈니스 로직 수행만을 담당하게끔 역할과 책임을 명확히 나누려고 노력했습니다. 현재 계층/역할 분리 수준이 적절한지 확인이 필요합니다.

### 4. 테스트 코드 작성 전략 (통합 테스트 vs 단위 테스트)

Service 계층은 실제 Repository를 이용한 통합 테스트를 작성했습니다. 그러나 Controller까지 Repository를 포함한 통합 테스트를 하면 계층 간 중복 테스트가 많아지고, Repository에 문제가 있을 때 Controller 테스트도 실패하는 문제가 생겨 테스트가 제공하는 빠른 문제 파악이라는 장점을 활용하기 어렵다고 판단했습니다. 따라서 Controller는 Stub Service를 DI받아 요청과 응답 형식만 검증하는 단위 테스트 방식을 택했습니다. 이 방식이 합리적이고 효과적인지 리뷰어 분의 의견을 듣고 싶습니다.

### 5. Spring 테스트 어노테이션 활용

테스트 환경의 편의를 위해 `@DirtiesContext`, `@TestConfiguration` 등 특정 Spring 테스트 어노테이션을 사용했지만, 이로 인해 테스트 성능 저하(컨텍스트 재생성 비용)를 우려했습니다. 이러한 어노테이션 사용이 적절한 수준에서 이루어졌는지, 또는 성능적으로 더 나은 방법이 있는지에 대한 의견을 부탁드립니다.

### 6. Repository `.save()` 이후 반환 객체 처리 방식

Repository에서 `.save()`를 수행한 후, pk(id)를 통해 다시 `.read()`하여 일관성을 확실히 보장할지, 아니면 리소스를 절약하기 위해 저장 후 반환된 pk를 기존의 요청 객체와 조합하여 사용할지 고민했습니다. 결과적으로는 이번 상황에서는 성능 이점을 위해 바로 조합하여 사용하도록 했습니다. 이에 대한 추가적인 피드백이나 더 좋은 접근 방법이 있으면 의견 부탁드립니다.

### 7. HTTP Status Code의 추상화 수준

다양한 HTTP Status Code를 활용할 수 있지만, 실제로는 400(Bad Request)과 404(Not Found) 정도로만 제한하여 사용했습니다. 이는 상태 코드 사용에 대한 명확한 문서화가 부족하여, 매번 프론트엔드 개발자가 백엔드에게 문의해야 하는 비효율을 방지하기 위함이었습니다. 이에 대해 상태 코드 활용의 적정성이나 더 나은 접근법이 있다면 조언 부탁드립니다.




---


# 고민 사항들에 대한 좀 더 구체적인 사항 (PR용 X)
## 1. 예외 처리에 대한 고민

- **상황**
    
    - 시간 생성 시 잘못된 값 입력, 예약 시 잘못된 예약자명, 날짜, 시간 입력, 이미 예약된 시간을 삭제하려는 예외 등 다양한 예외 상황 발생.
        
- **고민한 점**
    
    - 커스텀 예외 클래스를 세분화하면 상세한 정보 제공이 가능하지만 코드의 분기 처리가 복잡해지고 중복 코드가 많아짐.
        
    - 추상화된 예외 계층을 통해 중복 코드를 없애면서도 필요한 정보는 충분히 전달할 수 있는 적절한 수준의 설계를 고민함.
        
- **트레이드 오프**
    
    - 커스텀 예외의 세분화 (상세한 정보 전달) vs. 추상화를 통한 코드 간결성 확보.
        
- **최종 결정**
    
    - 적절한 추상화 수준을 찾아서 중복을 최소화하면서 충분한 예외 정보를 제공하는 방식 선택.
        

---

## 2. 도메인 객체 설계에 대한 고민 (Reservation 객체 중심)

- **상황**
    
    - 기능이 추가될수록 도메인 복잡성이 급격히 증가했고 이를 효과적으로 관리할 수 있는 방법에 대한 고민이 필요했음.
        
- **고민한 점**
    
    - Reservation 객체가 DB의 외래키인 `timeId`, `themeId`를 직접 가지고 있는 설계와, Java 레벨에서 실제 `Time`과 `Theme` 객체를 직접 참조하는 설계 중 고민.
        
    - DB 관계성을 객체 간의 관계로 표현하기 위해 후자를 선택했으나, 객체 간 의존성이 높아지며 복잡도가 지나치게 증가함.
        
- **트레이드 오프**
    
    - 단순한 외래키 관리로 객체 간 결합도 낮추기 vs. 객체 직접 참조로 비즈니스 로직의 명확성 확보.
        
- **최종 결정**
    
    - 후자의 설계를 채택했으나, 객체 간의 복잡성이 과도해지는 문제를 해결하기 위한 추가 설계 고민이 필요하다고 판단.
        

---

## 3. Repository와 Service의 추상화 계층 구분

- **상황**
    
    - Repository와 Service 계층의 역할과 책임이 명확히 분리되었는지 점검이 필요함.
        
- **고민한 점**
    
    - Repository가 순수한 데이터 접근만 담당하고, Service는 비즈니스 로직을 명확히 수행하는지 확인 필요.
        
- **트레이드 오프**
    
    - 계층 간 명확한 역할 분리로 유지보수성 향상 vs. 지나친 추상화로 인한 코드 복잡성 증가.
        
- **최종 결정**
    
    - 현재 추상화 수준이 적절한지 계속해서 모니터링하며, 역할의 명확성을 유지하는 방향으로 개선이 필요함.
        

---

## 4. 테스트 코드 작성 수준에 대한 고민 (통합 테스트 vs 단위 테스트)

- **상황**
    
    - Service 계층은 실제 Repository를 사용하는 통합 테스트 형태로 작성되어 있음.
        
    - Controller도 실제 Repository를 포함한 통합 테스트로 작성할 경우 중복 테스트가 증가하고, 하부 계층에서 문제가 발생하면 상부 계층까지 연쇄적인 테스트 실패가 발생해 문제의 위치를 빠르게 파악하기 어려움.
        
- **고민한 점**
    
    - Controller의 테스트는 Stub Service를 DI 받아서 요청과 응답의 형식만 검증하는 단위 테스트 방식으로 작성하는 것을 고민함.
        
- **트레이드 오프**
    
    - 모든 계층의 통합 테스트로 높은 신뢰도 확보 vs. 불필요한 중복 테스트와 문제 파악의 어려움.
        
    - Stub을 활용한 Controller 단위 테스트로 문제 원인 파악의 용이성 확보 vs. 통합 상황에서 발견 가능한 문제 누락 가능성.
        
- **최종 결정**
    
    - Controller 계층은 Stub Service를 DI 받아 요청-응답의 형식만 검증하는 단위 테스트를 수행.
        
    - Service와 Repository의 통합 테스트로 비즈니스 로직과 데이터 접근의 정확성을 보장.
        
    - 이 방법이 합리적이며, 향후 요구사항 추가 시 변경 사항을 더 명확히 파악할 수 있을 것으로 판단.
        

---

## 5. Spring 어노테이션 사용에 대한 고민

- **상황**
    
    - `@DirtiesContext`, `@TestConfiguration` 등의 특정 Spring 테스트 관련 어노테이션을 사용하는 것이 적절한지 판단 필요.
        
- **고민한 점**
    
    - 테스트 환경의 분리 및 설정의 편리함을 위해 사용했지만, 애플리케이션 컨텍스트 재생성으로 인한 테스트 성능 저하 등을 우려함.
        
- **트레이드 오프**
    
    - 테스트 설정 편리성과 독립적인 환경 구성 vs. 빈번한 컨텍스트 재생성으로 인한 성능 이슈.
        
- **최종 결정**
    
    - 필요한 상황에서만 제한적으로 사용하며, 컨텍스트 재생성 비용을 최소화할 수 있도록 추가적인 테스트 환경 개선이 필요함.
        

---

## 6. Repository의 `.save()` 이후 객체 반환 방식에 대한 고민

- **상황**
    
    - Repository에서 데이터를 저장한 후, 반환된 객체를 어떻게 처리할지 고민이 있었음.
        
- **고민한 점**
    
    - `.save()` 이후 다시 pk(id)를 기반으로 `.read()`를 수행해 영속성 계층과의 완벽한 일관성을 보장할 것인지,
        
    - 혹은 저장 후 반환된 pk만을 기존의 Request Entity와 조합하여 리소스를 절약할 것인지의 선택.
        
- **트레이드 오프**
    
    - 영속성 계층과의 완벽한 일관성 보장 (추가적인 DB 접근) vs. 리소스 절약을 통한 성능 최적화.
        
- **최종 결정**
    
    - 일관성 유지가 중요한 핵심 비즈니스 로직에서는 pk로 다시 읽어오는 방식을 사용하고, 성능이 중요한 비즈니스 로직에서는 요청 Entity를 조합하는 방식으로 사용 맥락에 따라 유연하게 선택함.
        
